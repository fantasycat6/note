# 1.隐私合规

## 一.隐私合规评估依据

1. 《⽹络安全法》

2. 《信息安全技术个⼈信息安全规范》
3. 《关于开展纵深推进APP侵害⽤户权益专项整治⾏动》 
4. 《App违法违规使⽤个⼈信息⾃评估指南》 
5. 《app弹窗治理》 
6. 《⽤户感知提升和信息共享公开通知》

## 二.隐私合规覆盖重点问题

1. 违规收集/超范围收集个⼈信息 
2. 强制⽤户使⽤定向推送功能 
3. APP强制.频繁.过度索取权限.APP频繁⾃启动和关联启动
4. 欺骗诱导强迫⾏为.欺骗误导⽤户提供个⼈信息 
5. 具有分发功能的APP信息明示不到位

## 三.隐私合规注意事项

###   一.未公开收集使⽤规则  

1. 
   在App中没有隐私政策，或者隐私政策中没有收集使⽤个⼈信息规则；  

2. 在App⾸次运⾏时未通过弹窗等明显⽅式提示⽤户阅读隐私政策等收集使⽤规则  

3. 隐私政策等收集使⽤规则难以访问，如进⼊App主界⾯后，需多于4次点击等操作才能访问到  
4. 隐私政策等收集使⽤规则难以阅读，如⽂字过⼩过密.颜⾊过淡.模糊不清，或未提供简体中⽂版等  

###  ⼆ .未明示收集使⽤个⼈信息的⽬的.⽅式和范围

1. 未逐⼀列出App（包括委托的第三⽅或嵌⼊的第三⽅代码.插件）收集使⽤个⼈信息的⽬ 的.⽅式.范围等；  

2. 收集使⽤个⼈信息的⽬的.⽅式.范围发⽣变化时，未以适当⽅式通知⽤户，适当⽅式包 括更新隐私政策等收集使⽤规则并提醒⽤户阅读等  
3. 在申请打开可收集个⼈信息的权限，或申请收集⽤户身份证号.银⾏账号.⾏踪轨迹等个⼈敏感信息时，未同步告知⽤户其⽬的，或者⽬的不明确.难以理解  
4. 有关收集使⽤规则的内容晦涩难懂.冗⻓繁琐，⽤户难以理解，如使⽤⼤量专业术语等。  

### 三.未经⽤户同意收集使⽤个⼈信息  

1. App虽然具备隐私政策也在⾸次运⾏时通过弹窗等⽅式提示⽤户阅读隐私政策，但在⽤户可 阅读并决定是否同意隐私政策前，App已要求⽤户提交个⼈信息（如⽤户⼿机号.⽹络（含 三⽅登录）账号.IP地址等）或授权使⽤收集个⼈信息的权限（如电话.存储.位置等）  
2. 
   征得⽤户同意前就开始收集个⼈信息或打开可收集个⼈信息的权限 (例如，未经⽤户 同意收 集或打开收集以下信息的权限：IMEI.IMSI.设备MAC地址.软件安装列表.位置.联系 ⼈.通话记录.⽇历.短信.本机电话号码.图⽚.⾳视频信息或权限)；  

3. 
   ⽤户明确表示不同意后，仍收集个⼈信息或打开可收集个⼈信息的权限；或⽤户明确拒绝 与当前服务场景⽆关权限，频繁弹窗.反复申请，⼲扰⽤户正常使⽤；  

4. 
   实际收集的个⼈信息或打开的可收集个⼈信息权限超出⽤户授权范围；  

5. 
   以默认选择同意隐私政策等⾮明示⽅式征求⽤户同意；  

6. 
   未经⽤户同意更改其设置的可收集个⼈信息权限状态，如App更新时⾃动将⽤户设置的权限 恢复到默认状态；  

7. 
   收集⽤户个⼈信息⽤于定向推送或⼴告精准营销，未以显著⽅式标示且未经⽤户同意，且 未提供关闭定向推送功能的选项；  

8. 
   以欺诈.诱骗等不正当⽅式误导⽤户同意收集个⼈信息或打开可收集个⼈信息的权限，如 故意欺瞒.掩饰收集使⽤个⼈信息的真实⽬的；  

9. 
   ⾮服务所必需或⽆合理场景，通过积分.奖励.优惠等⽅式欺骗误导⽤户提供身份证号码 以及个⼈⽣物特征信息的⾏为  

10. 
    未向⽤户提供撤回同意收集个⼈信息的途径.⽅式  

11. 
    违反其所声明的收集使⽤规则，收集使⽤个⼈信息；  


### 四.违反必要原则，收集与其提供的服务⽆关的个⼈信息  

1. 
   APP.SDK⾮服务所必需或⽆合理应⽤场景，特别是在静默状态下或在后台运⾏ 时，超范 围收集个⼈信息  

2. 
   ⾸次安装运⾏，⽤户未同意隐私政策前或同意隐私政策后⾮服务所必需或⽆应⽤场景时， App申请打开的可收集个⼈信息权限，⽤户拒绝后，应⽤⾃动退出或关闭  

3. 
   App⾸次安装及运⾏期间，收集的个⼈信息类型或打开的可收集个⼈信息权限与现有业务功 能⽆关；  


### 五.应⽤分发平台管理责任落实不到位  

1. 应⽤分发平台管理责任落实不到位。APP上架审核不严格.违法违规软件处理不及时和APP 提供者.运营者.开发者身份信息不真实.联系⽅式虚假失效  



#  2.测评需要工具及环境

模拟器，`adb` ,`frida`,`camille` 先配置adb，添加环境变量。 配置模拟器，进⾏adb连接  

## 一.ADB

### 1.1.ADB简介


ADB 全称为 Android Debug Bridge，起到调试桥的作⽤，是⼀个客户端-服务器端程序。其中客户端
是 ⽤来操作的电脑，服务端是 Android 设备。 


ADB 也是 Android SDK 中的⼀个⼯具，可以直接操作管理 Android 模拟器或者真实的 Android 设备

### 1.2.ADB安装与配置 

#### adb下载安装 

- 
  adb官⽅⽹址：https://developer.android.google.cn/studio/command-line/adb?hl=zh-cn  

- 
  下载地址： https://developer.android.com/studio/releases/platform-tools?hl=zh-cn


#### 下载后解压  

### 1.3.adb环境变量配置


 把解压路径放到系统变量⾥去（Path）

### 1.4.adb使用

#### 连接

- 通过模拟器连接或者⼿机数据线连接。 

- 
  通过数据线连接时，⼿机进⼊"**开发者选项**" ，打开" **usb调试**" 。  


#### 连接模拟器

```python
adb connect ip:port

adb connect 127.0.0.1:62001
```



#### 断开连接

```python
adb disconnect ip:port

adb disconnect 127.0.0.1:62001
```

#### 显示 adb 版本

```python
adb version
```

![image-20240921145904136](../../../../repo/assets/35.APP/image-20240921145904136.png)

#### 帮助信息

```python
adb help
```

![image-20240921150002852](../../../../repo/assets/35.APP/image-20240921150002852.png)

```bash
# adb help
Android Debug Bridge version 1.0.41
Version 34.0.4-10411341
Installed as D:\environment\Android\platform-tools\adb.exe
Running on Windows 10.0.22631

global options:
 -a     listen on all network interfaces, not just localhost
 -d     use USB device (error if multiple devices connected)
 -e     use TCP/IP device (error if multiple TCP/IP devices available)
 -s SERIAL    use device with given serial (overrides $ANDROID_SERIAL)
 -t ID  use device with given transport id
 -H     name of adb server host [default=localhost]
 -P     port of adb server [default=5037]
 -L SOCKET    listen on given socket for adb server [default=tcp:localhost:5037]
 --one-device SERIAL|USB  only allowed with 'start-server' or 'server nodaemon', server will only connect to one USB device, specified by a serial number or USB device address.
 --exit-on-write-error    exit if stdout is closed

general commands:
 devices [-l] list connected devices (-l for long output)
 help   show this help message
 versionshow version num

networking:
 connect HOST[:PORT]connect to a device via TCP/IP [default port=5555]
 disconnect [HOST[:PORT]]
     disconnect from given TCP/IP device [default port=5555], or all
 pair HOST[:PORT] [PAIRING CODE]
     pair with a device for secure TCP/IP communication
 forward --list     list all forward socket connections
 forward [--no-rebind] LOCAL REMOTE
     forward socket connection using:
 tcp:<port> (<local> may be "tcp:0" to pick any open port)
 localabstract:<unix domain socket name>
 localreserved:<unix domain socket name>
 localfilesystem:<unix domain socket name>
 dev:<character device name>
 jdwp:<process pid> (remote only)
 vsock:<CID>:<port> (remote only)
 acceptfd:<fd> (listen only)
 forward --remove LOCAL   remove specific forward socket connection
 forward --remove-all     remove all forward socket connections
 reverse --list     list all reverse socket connections from device
 reverse [--no-rebind] REMOTE LOCAL
     reverse socket connection using:
 tcp:<port> (<remote> may be "tcp:0" to pick any open port)
 localabstract:<unix domain socket name>
 localreserved:<unix domain socket name>
 localfilesystem:<unix domain socket name>
 reverse --remove REMOTE  remove specific reverse socket connection
 reverse --remove-all     remove all reverse socket connections from device
 mdns check   check if mdns discovery is available
 mdns serviceslist all discovered services

file transfer:
 push [--sync] [-z ALGORITHM] [-Z] LOCAL... REMOTE
     copy local files/directories to device
     --sync: only push files that are newer on the host than the device
     -n: dry run: push files to device without storing to the filesystem
     -z: enable compression with a specified algorithm (any/none/brotli/lz4/zstd)
     -Z: disable compression
 pull [-a] [-z ALGORITHM] [-Z] REMOTE... LOCAL
     copy files/dirs from device
     -a: preserve file timestamp and mode
     -z: enable compression with a specified algorithm (any/none/brotli/lz4/zstd)
     -Z: disable compression
 sync [-l] [-z ALGORITHM] [-Z] [all|data|odm|oem|product|system|system_ext|vendor]
     sync a local build from $ANDROID_PRODUCT_OUT to the device (default all)
     -n: dry run: push files to device without storing to the filesystem
     -l: list files that would be copied, but don't copy them
     -z: enable compression with a specified algorithm (any/none/brotli/lz4/zstd)
     -Z: disable compression

shell:
 shell [-e ESCAPE] [-n] [-Tt] [-x] [COMMAND...]
     run remote shell command (interactive shell if no command given)
     -e: choose escape character, or "none"; default '~'
     -n: don't read from stdin
     -T: disable pty allocation
     -t: allocate a pty if on a tty (-tt: force pty allocation)
     -x: disable remote exit codes and stdout/stderr separation
 emu COMMAND  run emulator console command

app installation (see also `adb shell cmd package help`):
 install [-lrtsdg] [--instant] PACKAGE
     push a single package to the device and install it
 install-multiple [-lrtsdpg] [--instant] PACKAGE...
     push multiple APKs to the device for a single package and install them
 install-multi-package [-lrtsdpg] [--instant] PACKAGE...
     push one or more packages to the device and install them atomically
     -r: replace existing application
     -t: allow test packages
     -d: allow version code downgrade (debuggable packages only)
     -p: partial application install (install-multiple only)
     -g: grant all runtime permissions
     --abi ABI: override platform's default ABI
     --instant: cause the app to be installed as an ephemeral install app
     --no-streaming: always push APK to device and invoke Package Manager as separate steps
     --streaming: force streaming APK directly into Package Manager
     --fastdeploy: use fast deploy
     --no-fastdeploy: prevent use of fast deploy
     --force-agent: force update of deployment agent when using fast deploy
     --date-check-agent: update deployment agent when local version is newer and using fast deploy
     --version-check-agent: update deployment agent when local version has different version code and using fast deploy
     (See also `adb shell pm help` for more options.)
 uninstall [-k] PACKAGE
     remove this app package from the device
     '-k': keep the data and cache directories

debugging:
 bugreport [PATH]
     write bugreport to given PATH [default=bugreport.zip];
     if PATH is a directory, the bug report is saved in that directory.
     devices that don't support zipped bug reports output to stdout.
 jdwp   list pids of processes hosting a JDWP transport
 logcat show device log (logcat --help for more)

security:
 disable-verity     disable dm-verity checking on userdebug builds
 enable-verityre-enable dm-verity checking on userdebug builds
 keygen FILE
     generate adb public/private key; private key stored in FILE,

scripting:
 wait-for[-TRANSPORT]-STATE...
     wait for device to be in a given state
     STATE: device, recovery, rescue, sideload, bootloader, or disconnect
     TRANSPORT: usb, local, or any [default=any]
 get-state    print offline | bootloader | device
 get-serialno print <serial-number>
 get-devpath  print <device-path>
 remount [-R]
remount partitions read-write. if a reboot is required, -R will
will automatically reboot the device.
 reboot [bootloader|recovery|sideload|sideload-auto-reboot]
     reboot the device; defaults to booting system image but
     supports bootloader and recovery too. sideload reboots
     into recovery and automatically starts sideload mode,
     sideload-auto-reboot is the same but reboots after sideloading.
 sideload OTAPACKAGEsideload the given full OTA package
 root   restart adbd with root permissions
 unroot restart adbd without root permissions
 usb    restart adbd listening on USB
 tcpip PORT   restart adbd listening on TCP on PORT

internal debugging:
 start-server ensure that there is a server running
 kill-server  kill the server if it is running
 reconnect    kick connection from host side to force reconnect
 reconnect device   kick connection from device side to force reconnect
 reconnect offline  reset offline/unauthorized devices to force reconnect

usb:
 attach attach a detached USB device
 detach detach from a USB device to allow use by other processes
environment variables:
 $ADB_TRACE
     comma-separated list of debug info to log:
     all,adb,sockets,packets,rwx,usb,sync,sysdeps,transport,jdwp
 $ADB_VENDOR_KEYS   colon-separated list of keys (files or directories)
 $ANDROID_SERIAL    serial number to connect to (see -s)
 $ANDROID_LOG_TAGS  tags to be used by logcat (see logcat --help)
 $ADB_LOCAL_TRANSPORT_MAX_PORT max emulator scan port (default 5585, 16 emus)
 $ADB_MDNS_AUTO_CONNECT   comma-separated list of mdns services to allow auto-connect (default adb-tls-connect)

Online documentation: https://android.googlesource.com/platform/packages/modules/adb/+/refs/heads/master/docs/user/adb.1.md
```

## 二.模拟器使用

设置开发者模式,

模拟器进⼊开发者模式

![image-20240921164850733](../../../../repo/assets/35.APP/image-20240921164850733.png)

### 开启UDB调试

#### 夜神模拟器

![image-20240921164822171](../../../../repo/assets/35.APP/image-20240921164822171.png)

第一个模拟器端口是`62001`，

第二个模拟器端口是`62025`，

第三个是`62026`，

依此类推。

### 连接模拟器 

```python
adb connect 127.0.0.1:62001
adb devices
adb shell
```

![image-20240921150621630](../../../../repo/assets/35.APP/image-20240921150621630.png)

## 三.Frida

### 3.1.Frida简介

`frida`是⼀款基于`python` + `javascript` 的`hook`框架，可运⾏在`Android,iOS,Linux,Windows`等各平台，主要使⽤**动态⼆进制插桩技术**。

`Hook`翻译成中⽂就是勾⼦的意思，在java中它表示在事件到达终点前进⾏**拦截或监控**的⼀种⾏为。 

**插桩技术**是指将额外的代码注⼊程序中以收集运⾏时的信息，可分为两种：

1. 源代码插桩

2. ⼆进制插桩 

   - 静态⼆进制插桩


   - 动态⼆进制插桩


### 3.2.Frida 安装与配置

#### frida框架分为两部分： 

- ⼀部分是运⾏在系统上的交互⼯具`frida CLI`; 
- ⼀部分是运⾏在⽬标机器上的代 码注⼊⼯具 `frida-server`。  

众所周知，frida是一个轻量级的HOOK工具，多个平台可以使用，Android，ios，Windows等`fida`分为两部分，

服务端运行在目标机上面，通过进程注入的方式来实现劫持应用函数，另一部运行在系统机器上。

#### python安装

##### 安装frida

```python
python -m pip install frida
```

![image-20240921161839193](../../../../repo/assets/35.APP/image-20240921161839193.png)

##### 安装frida-tools

```python
python -m pip install frida-tools
```

![image-20240921161821634](../../../../repo/assets/35.APP/image-20240921161821634.png)

#### github下载

通过GitHub上下载**手机服务端**，通电脑上下载`frida`**版本一样**

github：https://github.com/frida/frida/releases

![image-20240921162054539](../../../../repo/assets/35.APP/image-20240921162054539.png)

下载链接：https://github.com/frida/frida/releases/download/16.5.2/frida-server-16.5.2-android-x86_64.xz

解压

![image-20240921165207449](../../../../repo/assets/35.APP/image-20240921165207449.png)

####  查看电脑上frida的版本

```python
frida version
```

![image-20240921161856641](../../../../repo/assets/35.APP/image-20240921161856641.png)

#### frida放⼊Android

```python
adb push frida-server-16.5.2-android-x86_64 /data/local/tmp
```

### 3.3. Frida的使用

#### 1.启动Frida服务

启动Frida服务 保持模拟器的打开状态

```python
adb devices
adb shell
su
cd /data/local/tmp/
chmod 755 frida-server-16.5.2-android-x86_64
./frida-server-16.5.2-android-x86_64
```

![image-20240921165419451](../../../../repo/assets/35.APP/image-20240921165419451.png)

#### 2.停止frida-service 服务

```bash
ps | grep frida     //查看服务是否启动

kill -s 9 3082  		//杀死服务(4743是进程id)
```

![image-20240921165807978](../../../../repo/assets/35.APP/image-20240921165807978.png)

#### 3.查看进程

```python
frida-ps -U
```

![image-20240921170055346](../../../../repo/assets/35.APP/image-20240921170055346.png)

https://blog.csdn.net/qq910689331/article/details/124115640

## 四.Camille

### 4.1.camille简介

github：https://github.com/zhengjim/camille

Android **App隐私合规检测**辅助⼯具 

现如今APP隐私合规⼗分重要，各监管部⻔不断开展APP专项治理⼯作及核查通报，不合规的APP通知整改或直接下架。

`camille`可以hook住Android敏感接⼝，检测是否第三⽅`SDK`调⽤。

根据隐私合规的场景，辅助检查是否符合隐私合规标准。

### 4.2.camille安装与配置

```python
git clone https://github.com/zhengjim/camille.git
cd camille
pip install -r requirements.txt
python camille.py -h
```

![image-20240921171521645](../../../../repo/assets/35.APP/image-20240921171521645.png)

### 4.3.运行camille

####  1.需要安装预先模块进行使用

```python
pip install xlwt
pip install opencv-contrib-python
pip install opencv-python
```

####  2.进⼊后进⾏如下操作 

 `Camille`的运⾏需要知道待检测的APP包名，如何知道呢？

##### 检测的APP包名

这⾥我们需要在`bin`⽬录下打开⼀个新的CMD 窗⼝，运⾏下⾯的指令：  

```python
adb shell am monitor
```

###### 打开程序

之后在模拟器中**打开程序**，就可以看到包名 

![image-20240925094341065](../../../../repo/assets/35.APP渗透/image-20240925094341065.png)

这⾥可以看到包名是：`oversecured.ovaa` 可以做⼀个记录，之后会⽤到。 

#### oversecured.ovaa

```python
python camille.py oversecured.ovaa
python camille.py oversecured.ovaa -ns -f 1.xls
```

![image-20240925094737868](../../../../repo/assets/35.APP渗透/image-20240925094737868.png)

#### com.android.browser

```python
python camille.py com.android.browser
```

![image-20240925095816456](../../../../repo/assets/35.APP渗透/image-20240925095816456.png)

```python
python camille.py com.android.browser -ns -f yin.xls
```

![image-20240925100018272](../../../../repo/assets/35.APP渗透/image-20240925100018272.png)

![image-20240925100058077](../../../../repo/assets/35.APP渗透/image-20240925100058077.png)

###  4.5.不合规项目确定  

https://github.com/zhengjim/camille/blob/master/docs/use.md

## 五.APP隐私合规检测实操案例

### 1.打开Frida服务

打开Frida服务  ，保持模拟器的打开状态

```python
adb connect 127.0.0.1:62001
adb devices
adb shell
su
cd /data/local/tmp/
chmod 755 frida-server-16.5.2-android-x86_64
./frida-server-16.5.2-android-x86_64
```

### 2. 查看需要检测的APP包名  

 `Camille`的运⾏需要知道待检测的APP包名，如何知道呢？

这⾥我们需要在`bin`⽬录下打开⼀个新的CMD 窗⼝，运⾏下⾯的指令：  

```python
adb shell am monitor
```

之后在模拟器中打开程序，就可以看到包名  

这⾥可以看到包名是：`com.android.browser` 可以做⼀个记录，之后会⽤到。  

### 3.运行camille.py

```python
python camille.py com.android.browser
python camille.py com.android.browser -ns -f yin.xls
```

#  3.drozer

## 一.安装

### Python 2.7.13

#### 1.Python 2.7.13 安装

##### 下载

python 2.7.13

下载路径：https://www.python.org/ftp/python/2.7.13/python-2.7.13.amd64.msi

![image-20240925150905140](../../../../repo/assets/35.APP渗透/image-20240925150905140.png)

> 注：在Windows上，请确保将**Python安装的路径**和**Python安装下的安装⽂件夹**添加到**PATH环境变量**中。
>

##### 设置环境变量

![image-20240925150943612](../../../../repo/assets/35.APP渗透/image-20240925150943612.png)

![image-20240925151006060](../../../../repo/assets/35.APP渗透/image-20240925151006060.png)

#### 2.drozer安装

github：https://github.com/WithSecureLabs/drozer

##### 2.4.4

python 2.7.13

下载路径：https://github.com/WithSecureLabs/drozer/releases/download/2.4.4/drozer-2.4.4.win32.msi

![image-20240925152058150](../../../../repo/assets/35.APP渗透/image-20240925152058150.png)

![image-20240925152006537](../../../../repo/assets/35.APP渗透/image-20240925152006537.png)

#### 3.agent代理安装  


 直接将apk拖动到模拟器  

 sieve(管理密码的APP)端设置密码和pin

##### 2.3.4

![image-20240925153059943](../../../../repo/assets/35.APP渗透/image-20240925153059943.png)

### python 3.8

#### drozer安装

github：https://github.com/WithSecureLabs/drozer

##### 3.1.0

python 3.8以上

![image-20240925152217010](../../../../repo/assets/35.APP渗透/image-20240925152217010.png)

```python
pip install drozer
```

![image-20240925152512872](../../../../repo/assets/35.APP渗透/image-20240925152512872.png)

#### agent代理安装  

 直接将apk拖动到模拟器

##### 3.1.0

下载链接：https://github.com/WithSecureLabs/drozer-agent/releases/download/3.1.0/drozer-agent.apk

![image-20240925152859089](../../../../repo/assets/35.APP渗透/image-20240925152859089.png)

![image-20240925153540600](../../../../repo/assets/35.APP渗透/image-20240925153540600.png)

###### 使用

```python
adb connect 127.0.0.1:62001
adb forward tcp:31415 tcp:31415
drozer console connect
```

![image-20240925153406129](../../../../repo/assets/35.APP渗透/image-20240925153406129.png)

![image-20240925153436657](../../../../repo/assets/35.APP渗透/image-20240925153436657.png)

## 二.使用

> python 2.7 环境

###  1.adb连接模拟器 


确定模拟器的IP与端⼝ 


连接模拟器，`ip:port`  

```python
adb connect 127.0.0.1:62001
adb devices
```

![image-20240925112623191](../../../../repo/assets/35.APP渗透/image-20240925112623191.png)

### 2.PC端运行drozer

将PC端31415收到的数据转发给终端的agent默认监听的31415端口

```python
adb forward tcp:31415 tcp:31415
adb forward --list
```

![image-20240925112643746](../../../../repo/assets/35.APP渗透/image-20240925112643746.png)

```python
python -m pip install --upgrade pip --index-url https://pypi.org/simple
python -m pip install certifi
pip install protobuf
pip install pyOpenSSL
pip install twisted
```

#### 连接终端agent

```python
d:
cd D:\environment\Python\Python27\Scripts
drozer.bat console connect	
```

![image-20240925140903032](../../../../repo/assets/35.APP渗透/image-20240925140903032.png)

开启模拟器端的drozer

![image-20240925143335067](../../../../repo/assets/35.APP渗透/image-20240925143335067.png)

### 3. 查找终端设备所有APK信息

#### 查找APK信息

```python
run app.package.list
```

![image-20240925142653960](../../../../repo/assets/35.APP渗透/image-20240925142653960.png)

```python
list
```

![image-20240925142231915](../../../../repo/assets/35.APP渗透/image-20240925142231915.png)

#### 解决问题

##### 出现unknown module

出现 `unknown module: 'aap.package.list'`

这个时候在`dz>`中输入`list`，返回结果也是**空白**。

解决方法是在cmd中将当前目录**切换到**`drozer`的安装路径下，

```python
d:
cd D:\environment\Python\Python27\Scripts
drozer.bat console connect
```

https://blog.csdn.net/bbdog86/article/details/50622963

##### 编码问题

###### 修改package.py

```python
D:\environment\Python\Python27\Lib\site-packages\drozer\modules\app
```

![image-20240925142939285](../../../../repo/assets/35.APP渗透/image-20240925142939285.png)

###### 设置utf8编码

```python
import sys
reload(sys)
sys.setdefaultencoding('utf-8')
```

![image-20240925143236787](../../../../repo/assets/35.APP渗透/image-20240925143236787.png)

###### 添加两个`u`

`359`行和`361`行，添加两个`u`。

![image-20240925143136419](../../../../repo/assets/35.APP渗透/image-20240925143136419.png)

### 4.查看指定apk信息

```python
run app.package.info -a com.android.browser
```

![image-20240925154751334](../../../../repo/assets/35.APP渗透/image-20240925154751334.png)

### 5.通过关键字过滤来匹配显示  

```python
run app.package.list -f location
```

含义：`-f`是**过滤**的意思，通过后⾯的关键字过滤来匹配显示

![image-20240925154815503](../../../../repo/assets/35.APP渗透/image-20240925154815503.png)

### 6. 查看sieve apk的可攻击点

从安卓组件⻆度出发，查看sieve apk的可攻击点

```python
run app.package.attacksurface ddns.android.vuls
```

![image-20240925155056065](../../../../repo/assets/35.APP渗透/image-20240925155056065.png)

### 7. 获取activity信息

```python
run app.activity.info -a ddns.android.vuls
```

![image-20240925155124428](../../../../repo/assets/35.APP渗透/image-20240925155124428.png)

### 8.启动activity

```python
run app.activity.start --component ddns.android.vuls ddns.android.vuls.activities.Activity.WebviewActivity
```

![image-20240925155417973](../../../../repo/assets/35.APP渗透/image-20240925155417973.png)

### 9. 获取Content Provider信息  

```python
run app.provider.info -a ddns.android.vuls
```

![image-20240925155432747](../../../../repo/assets/35.APP渗透/image-20240925155432747.png)

### 10. 获取所有可以访问的`Uri`

获取所有可以访问的`Uri`—— `Content Providers`（数据泄露）  

```python
run scanner.provider.finduris -a ddns.android.vuls
```

![image-20240925155453262](../../../../repo/assets/35.APP渗透/image-20240925155453262.png)

### 11.检测SQL注入

```python
run scanner.provider.injection -a ddns.android.vuls
```

![image-20240925155514762](../../../../repo/assets/35.APP渗透/image-20240925155514762.png)

# 4.app抓包检测

## 1.设置burp代理

注意IP是本机下的ip

![image-20240926100104706](../../../../repo/assets/35.APP渗透/image-20240926100104706.png)

## 2.模拟器设置代理

点击wifi长按鼠标修改网络

![image-20240926103521806](../../../../repo/assets/35.APP渗透/image-20240926103521806.png)

## 3.导出CA证书

### 安装burpsuite证书

模拟器中进入http://burp页面，点击黄色的地方下载

![image-20240926103558587](../../../../repo/assets/35.APP渗透/image-20240926103558587.png)

下载证书，可以选择本地下载下来然后移到模拟器里面一般下载路径在download

![image-20240926104357419](../../../../repo/assets/35.APP渗透/image-20240926104357419.png)

### 安装openssl

https://slproweb.com/products/Win32OpenSSL.html

根据自己电脑的配置选择需要的版本

无脑安装然后记住安装路径

配置环境变量path

![image-20240926105756463](../../../../repo/assets/35.APP渗透/image-20240926105756463.png)

安装成功

```python
openssl -help
openssl -version
```

![image-20240926105721713](../../../../repo/assets/35.APP渗透/image-20240926105721713.png)

### 证书格式转换

安装openssl是用来进行证书格式转换

```python
E:
cd E:\learn\6.网安世纪\5.线下班\2.课程资料\35.APP渗透
openssl x509 -inform der -in cacert.der -out burp.pem
```

![image-20240926110513089](../../../../repo/assets/35.APP渗透/image-20240926110513089.png)

在**该目录下**打开cmd输入命令(`62001`端口是**夜神模拟器**的端口，**逍遥模拟器**端口:`21503`)

```python
adb connect 127.0.0.1:62001
adb root
adb remount
openssl x509 -subject_hash_old -in burp.pem
copy burp.pem 9a5ba575.0
adb push 9a5ba575.0 /system/etc/security/cacerts/ 
```

![image-20240926111056685](../../../../repo/assets/35.APP渗透/image-20240926111056685.png)

```python
9a5ba575
-----BEGIN CERTIFICATE-----
MIIDqDCCApCgAwIBAgIFAMFa97kwDQYJKoZIhvcNAQELBQAwgYoxFDASBgNVBAYT
C1BvcnRTd2lnZ2VyMRQwEgYDVQQIEwtQb3J0U3dpZ2dlcjEUMBIGA1UEBxMLUG9y
dFN3aWdnZXIxFDASBgNVBAoTC1BvcnRTd2lnZ2VyMRcwFQYDVQQLEw5Qb3J0U3dp
Z2dlciBDQTEXMBUGA1UEAxMOUG9ydFN3aWdnZXIgQ0EwHhcNMTQxMTExMDczNzA4
WhcNMzMxMTExMDczNzA4WjCBijEUMBIGA1UEBhMLUG9ydFN3aWdnZXIxFDASBgNV
BAgTC1BvcnRTd2lnZ2VyMRQwEgYDVQQHEwtQb3J0U3dpZ2dlcjEUMBIGA1UEChML
UG9ydFN3aWdnZXIxFzAVBgNVBAsTDlBvcnRTd2lnZ2VyIENBMRcwFQYDVQQDEw5Q
b3J0U3dpZ2dlciBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKcv
JzA58edJW5Fzh7S8BX7uTJhWYS4Ii8gwfDb8Mo9JuAAIBZ9jYIJspxdOyJhlapmH
uf4XlmTiniM+COfe4eDoK8qt+aqcoPBffdrePWsdOaDH+cGH89pqtjHHyBWheGwD
x/PQWdBocHJjKtza9idh/As0c/c9JDMo7OM0TyymR5yTtSVvXVCSyPkWBfW2Vs92
vSGadfOqxNjuCGyac5+QQspJmcCKFAnhfIyWw0VAsXiw/zpCJsVF1m/XF46hDLY4
jpfTU3u5Mk3IHrYCOFQyLdwDFnL8xOgd1AQxyJehQXI6vZw04eJ7SeF9YDA4G1Sq
OyDkXMj+j5LiqM+YNV8CAwEAAaMTMBEwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG
9w0BAQsFAAOCAQEABPiCR+IURygP2U95WRWH4Pq0BKxp1yg4EpNnfBMCTezyqoYP
NzyNvbkpHZ2Ow3lSoiIb8avs2BADLE0zjU1XhBc22MOv+q4vN5ht/z/o7Ww2K3UM
SfNGupsrffIODCObsC+z52Pri8X3uqSVx1rgMKmwf+aTo3LPRmOG6UqWWVVeaIkv
IIuWUFNyU/zt/ziFRFPSsv1dakEhuW6TQ3/lWTaCgeIvxpv3FPGXTqrkxNURPRix
dEBdaBCyG94GaJz5WJgJxSlMaklr6pa6475PSLMG0uwIDEKCCCKXBL0g2//jQP56
b9vQ0/MCUhwEIFuuRDHNqhlOjKlJTOOMVbyaCA==
-----END CERTIFICATE-----
```

### 创建`9a5ba575.0`

因为android模拟器内部存储证书的名字必须是pem的hash值.0方式存储，所以需要知道他的hash值

burpsuite生成的根证书hash值是 `9a5ba575`，所以可以直接将`cacert.pem`重命名为:`9a5ba575.0`

![image-20240926110959587](../../../../repo/assets/35.APP渗透/image-20240926110959587.png)

![image-20240926111156062](../../../../repo/assets/35.APP渗透/image-20240926111156062.png)

我们最后到模拟器中查看是否安装成功

设置-->安全-->信任的任凭


https://blog.csdn.net/liaomin416100569/article/details/129176916

# 4.pixel线刷教程+进入fastboot模式

```python
pixel
一：线刷，fastboot
二：卡刷，手机都有sdcard，micro sdcarf -->USB读卡器，rom包拷贝到sdcard，recovery去刷
```

## 1.通过Google进行刷机


https://developer.android.google.cn/about/versions/oreo?hl=zh-cn 


通过 Android 平台


https://developers.google.com/android/images


选择合适的二进制映像文件

## 2.pixel刷机

线刷逻辑：电脑准备系统包和sdk工具包 —— 手机在关机状态通过usb数据线连接电脑 —— 刷入系统

前提：已解BL锁。

BL锁全称为BootLoader，字面意思就是启动加载，只有先解锁了BL才能获取root权限.刷入第三方系统包。

> 类似windows开机时会首先加载bios，然后是系统内核，最后启动完毕。
>
> 那么bootloader就相当于手机的bios，它在手机启动的时候根据基带初始化硬件，然后引导系统内核，直到系统启动。
>
> 解BL锁会清除用户数据，所以最好在拿到手机的第一时间就先把BL解了。
>
> 本人的pixel在购买时就已经被店家解锁好了。

### 1.手机进入bootloader


由于手机无法正常进入系统，循环在开机logo界面，所以必须先退出该循环，进入bootloader模
式，为随后刷机做准备。

方式：长按开机键先重启，屏幕黑屏后一直按音量减，直到出现写着Fastboot Mode的界面，且
device state显示unlocked表示已解BL。

### 2.电脑准备好系统包和SDK工具包


刷系统指的是要刷入原生Android 13系统，因此根据相应的型号和系统版本号，在[


官网](https://developers.google.cn/android/images?hl=zh-cn)上下载对应的系统包（ROM image），文件比较大耐心等待。

#### 下载SDK工具包


Android SDK Platform-Tools 是 Android SDK 的一个组件，包含一些可以在电脑上对 Android 平台进行调试的工具，主要是 adb 和 fastboot。 Platform-Tools用来辅助刷入系统包。

根据电脑系统，选择对应的Windows/Mac版本下载，地址：

https://developer.android.com/studio/releases/platform-tools?hl=zh-cn

> 注：platform-tools一般是向后兼容，所以要刷Android 13的话，用31版本和之后的都可以。
>
> 但网上反应用最新的34版本刷会有问题，所以建议下载33版本的。

### 3.手机连接电脑


找一根数据线连接电脑和pixel。在platform-tools文件夹下cmd进入，输入`fastboot devices`若返回序列号则表示连接成功。

### 4.修改配置文件，刷入系统

#### （1） 解压系统包

（ps：里面的image-flame-xxx.zip不用解压）打开目录里的`flash-all.sh`文件，编辑其中的一行命令删除`-w`以保留用户数据

删去这里的-w参数


    fastboot -w update image-flame-tp1a.221005.002.b2.zip

#### （2）platform-tools

把`platform-tools`里的所有文件复制到系统包文件夹里

#### （3）`bootloader`模式

确保手机在`bootloader`模式下连接电脑，双击`flash-all.bat`即可刷入系统。

https://www.bilibili.com/opus/782676988684926985

https://support.yeshen.com/zh-CN/qt/jssb



# 工具

## ApkToolBox

github：https://github.com/qtfreet00/ApkToolBox

下载链接：https://github.com/qtfreet00/ApkToolBox/raw/refs/heads/master/ApkToolBox_1.6.4.zip

![image-20240925160809868](../../../../repo/assets/35.APP渗透/image-20240925160809868.png)

![image-20240925160826795](../../../../repo/assets/35.APP渗透/image-20240925160826795.png)

![image-20240925160848958](../../../../repo/assets/35.APP渗透/image-20240925160848958.png)

## Android-GetAPKInfo

github地址：https://github.com/bihe0832/Android-GetAPKInfo

```python
git clone https://github.com/bihe0832/Android-GetAPKInfo.git
cd Android-GetAPKInfo
java -jar GetAPKInfo.jar --help
java -jar GetAPKInfo.jar E:\learn\6.网安世纪\5.线下班\2.课程资料\35.APP渗透\q多多.apk
```



```python
# java -jar GetAPKInfo.jar --help
usage:

  java -jar ./GetAPKInfo.jar <command> [filePath] --debug
  java -jar ./GetAPKInfo.jar --version
  java -jar ./GetAPKInfo.jar --help

such as:

  java -jar ./GetAPKInfo.jar ./test.apk
  java -jar ./GetAPKInfo.jar --version
  java -jar ./GetAPKInfo.jar --help
```

![image-20240925162439945](../../../../repo/assets/35.APP渗透/image-20240925162439945.png)

```python
java -jar GetAPKInfo.jar E:\learn\6.网安世纪\5.线下班\2.课程资料\35.APP渗透\q多多.apk
```

![image-20240925162152231](../../../../repo/assets/35.APP渗透/image-20240925162152231.png)

## AndroidKiller

github：https://github.com/liaojack8/AndroidKiller

```python
git clone https://github.com/liaojack8/AndroidKiller.git
cd AndroidKiller
```

![image-20240925212033097](../../../../repo/assets/35.APP渗透/image-20240925212033097.png)

# APP渗透测试基线

## 1 概述

该文档旨在描述Android  App安全评估工作采用的测试方法和试内容，目的是为了优化App 安全评估测试工作，最大限度的挖掘应用系统可能存在的风险点，评估测试人员应按照此文档描述开展日常的安全评估工作。 

针对新出现的重大漏洞，定期补充文档内容，及时更新。具体的测试项目参见第二章。 

### 1.1  适用人员

本标准适用者主要为专职的安全测试评估人员，也可作为APP 相关的测试人员.开发人员等参考文档。 

### 1.2  适用范围

本规范主要针对基于Android 和 IOS 系统APP 的安全测试。

本规范中的方法以攻击性测试为主。除了覆盖业界常见的APP 安全测试方法以外，也借鉴了一些业界最佳安全实践，涵盖APP 安全开发规范的内容。 

### 1.3  基本要求

测试人员熟悉常见漏洞及攻击方式，能够独立进行渗透测试并提出合理安全修复建议。 

## 2   App  标准化测试项目 

### 2.1  Android APP 客户端 

#### 2.1.1 APP 客户端敏感信息存储安全 

##### 2.1.1.1  问题描述 

​    

敏感信息可分为产品敏感信息和用户敏感信息两类，我们对产品

###### 敏感信息是这样界定的： 

泄露后直接对企业安全造成重大损失或有助于帮助攻击者获取企业内部信息，并可能帮助攻击者尝试更多的攻击路径的信息。 

以下这些信息都属于产品敏感信息：登录密码.后台登录及数据库地址.服务器部署的绝对路径.内部 IP .地址分配规则.网络拓扑.页面注释信息（开发者姓名或工号.程序源代码）。 

###### 而用户敏感信息有两个界定原则： 

用户隐私保护主要考虑直接通过该数据或者结合该数据与其它的信息，可以识别出自然人的信息。 

一旦发生数据泄露事件，可以被恶意人员利用并获取不当利润。 

由此标准参考，以下字段在数据库的存储以及传输过程中，

我们建议加密处理：密码.手机号.快捷支付手机号. Email .身 份 证 .银行卡. CVV 码.有效期。 

而这些敏感信息泄露的原因大多数情况下是因为信息未加密或储存位置不当造成的： 

- 代码中明文使用敏感信息，比如：服务器地址.数据库信息等 

- 数据库中明文保存敏感信息，比如：账号.密码.银行卡等 

- SD 卡中保存敏感信息或隐私数据，比如：聊天记录.通讯录等 

- 日志中打印敏感信息：比如：账号.密码 

- 通信过程中明文传输敏感信息 


以上这些做法都会使 APP 中的敏感信息暴露在黑客的眼皮底下，

只要黑客认为该信息有价值，他就会轻而易举的获取这些敏感信息，

最直接的损失可能就是用户的账号被盗.网银被盗刷等。 

##### 2.1.1.2  危害级别 

###### 符合： 

本地存储文件中不包含敏感信息，如：用户名和密码。 

###### 不符合： 

外部存储文件中包含敏感信息，则为低风险。 

##### 2.1.1.3  测试方法 

- 1.进入   android 手机上   APP 安装目录； 
- 2.找到如：logs等目录，查看是否存在日志文件，dbs等数据库目录，查看是否存在数据库文件； 
- 3.尝试打开该文件，是否为明文存储，且其中是否包含敏感信息，如：用户登录密码和用户名等； 

###### SDCard 敏感资源判断依据： 

首先如果app 已经申请了外部存储的权限： 

在反编译代码中搜索“`getExternalStorageDirectory`”。     

如果搜到代码被实例化使用，则需要在具体路径中找到数据存储位置进行分析。

通常外部存储目录为：`/sdcard/Android/data/app package name` 

#### 2.1.2 进程安全：内存访问 

##### 2.1.2.1  问题描述 

攻击者可利用漏洞获取内存中的敏感信息。 

##### 2.1.2.2  危害级别 

###### 符合： 

​    未查找到敏感信息。 

###### 不符合： 

查找到用户的敏感信息，比如密码，则为高风险。 

##### 2.1.2.3  测试方法 

1. 1.安装   MemSpector 工具。 
2. 2.使用用户名.密码登录系统。 

3. 3.查找用户明文密码信息。 

#### 2.1.3 APP 客户端代码混淆 

##### 2.1.3.1  问题描述 

对于缺乏抗反编译机制且未进行代码混淆的APP，攻击者可轻易获取APK 文件的  Java 源代码，造成应用运行逻辑与大量敏感信息泄露。

如果混合开发的APP 没有经过混淆，攻击者也可以查看H5 资源的源代码。

通过这种方式也可以造成应用逻辑与大量敏感信息泄露。 

##### 2.1.3.2  危害级别 

###### 符合： 

APP 存在代码混淆/抗反编译机制。 

###### 不符合： 

APP 不存在代码混淆/抗反编译机制，则为高风险。 

##### 2.1.3.3  测试方法 

1. 1.采用`apktool`等**APP 代码逆向工具**，对APP 客户端进行反编译逆向处理； 
2. 2.查看代码是否采用了混淆措施，如：文件名和函数名等混淆显示，且没有具体含义。 
3. 3.反编译apk 文件在资源文件中寻找H5 文件。用文本编辑器打开  H5 相关文件并查看代码是否采用了混淆措施。 

#### 2.1.4 客户端安装包签名 

##### 2.1.4.1  问题描述 

APK 签名不规范或版本过低将导致攻击者可以利用已知漏洞对APK 进行攻击。 

##### 2.1.4.2  危害级别 

###### 符合： 

当输出结果为“jar已验证”时且签名等级有v2，表示签名正常，则安全。 

###### 不符合： 

客户端安装包签名有异常（例如签名证书为第三方开发商而不是客户端发布方），则为高风险 

#### 2.1.4.3  测试方法 

1. 1.jarsigner -verify APK 文件 
2. 2.java -jar GetApkInfo.jar ***.apk 查看  APK 信息及签名版本

#### 2.1.5 Root 环境检测 

##### 2.1.5.1  问题描述 

针对安全要求较高的APP（如金融类.车联网），允许APP 运行在Root 环境会极大降低逆向难度。

普通APP 可不进行此项测试。 

##### 2.1.5.2  危害级别 

###### 符合： 

APP 在 Root 环境下不能运行或有相关提示则为符合。 

###### 不符合： 

APP 在 Root 环境下运行且无相关提示，则为低风险。 

##### 2.1.5.3  测试方法 

在完全   Root 环境下安装并运行  APP，人 工观察是否有相关提示。     

#### 2.1.6 模拟器检测 

##### 2.1.6.1  问题描述 

针对安全要求较高的APP（如金融类.车联网），允许APP 运行在模拟器环境会极大降低逆向难度。安全性较高的APP 需考虑  APP 实际运行的场景。

普通APP 可不进行此项测试。 

##### 2.1.6.2  危害级别 

###### 符合： 

在模拟器环境下不能直接运行则为安全。有无提示均可。 

###### 不符合： 

在模拟器环境下可直接运行，则为低风险。 

##### 2.1.6.3  测试方法 

在模拟器中安装并与逆行APP，人工观察运行情况。 

#### 2.1.7 客户端完整性校验 

##### 2.1.7.1  问题描述 

攻击者可利用此漏洞对安卓应用进行恶意篡改。 

##### 2.1.7.2  危害级别 

###### 符合： 

重新打包的文件不能安装或者不能正常使用。 

###### 不符合： 

重新打包后的APK 文件可以正常运行，则为高风险 

##### 2.1.7.3  测试方法 

1. 1.使用   `AndroidKiller` 对 APK 文件进行反编译； 
2. 2.更改   apk 文件`\res\drawable-hdpi` 目录下的资源文件，使用`AndroidKiller` 重新打包； 
3. 3.进行   APK 安装使用；     

#### 2.1.8 防 Hook框架检测 

##### 2.1.8.1  问题描述 

`Frida` 与 `Xposed` 是市面上常见的**Hook 框架**。

黑客可以通过hook的方式**读取函数参数.绕过一些安全检测.修改函数返回值**。

允许hook框架的运行会导致程序被破解的难度极大降低。 

##### 2.1.8.2  危害级别 

###### 符合： 

当对APP 进行  hook 时，较短时间内（5秒）程序直接退出或崩溃则为符合。有无提示均可。 

###### 不符合： 

当对APP 进行hook 时，程序正常运行则为中风险。 

##### 2.1.8.3  测试方法 

###### 1.PC 端安装Frida：   

###### 2.手机端安装Frida-server 

首先需要在github 上寻找对应处理器和版本的Frida-server

将Frida-server 解压放于手机/data/local/tmp目录下。

必要时需赋予执行权限。 

###### 3.进行Hook

PC 端对  APP 进行Hook 并观察程序在短时间内是否异常退出。 

命令：`frida -U 包名或者进程号`。 

对于 Frida 的详细配置说明建议去网上搜索。同样的检测思路也

可以用Xposed。

核心思路就是 APP 被 hook 时是否会退出。 

#### 2.1.9 客户端组件安全 

##### 2.1.9.1  问题描述 

该漏洞可导致客户端组件被其他应用程序恶意调用。 

##### 2.1.9.2  危害级别 
    符合： 

组件无须跨进程交互，设置exported 属性为false。 

###### 不符合： 

如果组件无须跨进程交互，而设置exported 属性为 true 时，则为低风险。 

##### 2.1.9.3  测试方法 

1. 1.使用AndroidKiller 对 APK 文件进行反编译； 
2. 2.检查AndroidManifest.xml 文件中各组件定义标签的安全属性是否设置恰当 

#### 2.1.10 组件Content Provider配置错误

组件Content Provider配置错误，导致数据泄漏 

##### 2.1.10.1 问题描述 

`Content Provider` 是安卓应用组件，以表格的形式把数据展现给外部的应用。

每个Content Provider 都对应一个以”content://”开头的特定URI，任何应用都可以通过这个URI 操作Content Provider 应用的数据库。

如果应用对权限控制不当就会造成信息泄露。 

##### 2.1.10.2 危害级别 

###### 符合: 

第二步骤中，获取到相关信息则为高风险。 

##### 2.1.10.3 测试方法 

1.   使用  `Mercury` 获取所有可以访问的URI：  

```python
run scanner.provider.finduris -a (package name)（package name是待检测的应用包名） 
```

2. 使用  Mercury 获取各个URI 的数据： 

```python
run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/

(content://com.mwr.example.sieve.DBContentProvider/Passwords/ 是上一步骤中得到的可以访问的URI) 
```

#### 2.1.11 组件Activity 配置错误

组件Activity配置错误，导致登录页面被绕过 

##### 2.1.11.1 问题描述 

Activity 是安卓应用组件，提供与用户进行交互的界面。如果应

用对权限控制不当，可以绕过登录界面直接显示该界面。 

##### 2.1.11.2 危害级别 

###### 符合： 

成功绕过登陆界面，则为高风险 

##### 2.1.11.3 测试方法 

1.   使用  Mercury 检查  APK 中是否存在暴露的activity，使用命令  

```python
run app.activity.info –a  (package name)。（ package name是待检测的应用包名） 
```

2.   `com.isi.testapp.MainActivity` 是正常启动的主界面。 

`com.isi.testapp.Welcome` 是登录鉴权后才能启动的界面。

可以使用以下命令尝试启动。 

```python
run app.activity.start --component com.isi.testapp com.isi.testapp.Welcome 
```

#### 2.1.12 组件Service配置错误

组件Service配置错误，导致非法权限提升 

##### 2.1.12.1 问题描述 

Service 是 Android 中四大组件进行后台作业的主要组件，如果被测应用对权限控制不当，导致其他应用可以启动被测应用的Service。 

##### 2.1.12.2 危害级别 

在 `AndroidManifest.xml` 文件中的    android:exported 属性未设置  false 

##### 2.1.12.3 测试方法 

1.   使用JEB 检查  APK 中是否存在暴露的Service，将apk 拖入JEB 中，然后查找暴露的Service  

2.   在上图中 com.cleanmaster.appwidger.WidgerService   属性设置错误，导致暴露。 

某被测应用暴露了com.cleanmaster.appwidget.WidgetService 服务组件

当向此服务发送action 为 com.cleanmaster.appwidget.ACTION_FASTCLEAN 的 intent 时，便可结束后台运行的一些app 进程。 

#### 2.1.13   组件  Broadcast  Receiver 配置错误

组件  Broadcast  Receiver 配置错误，导致拒绝服务.非法越权 

##### 2.1.13.1 问题描述 

Broadcast  Receiver 是 Android 中四大组件用于处理广播事件的组件，若存在配置不当则其他应用可以伪装发送广播从而可造成信息泄露，拒绝服务攻击等。 

##### 2.1.13.2 危害级别 

造成app 停止则为高危险 

##### 2.1.13.3 测试方法 

1.   使用  JEB 检查  APK 中是否存在暴露的 Receiver，将  apk 拖入  JEB 中，然后查找暴露的  Receiver 

2.   com.baidu.android.defense.push.PushMsgReceiver 属性设置错误，所以是暴露的。 

某被测应用中 com.baidu.android.defense.push.PushMsgReceiver 存在  DOS 攻击的风险。

PushMsgReceive可接收com.baidu.android.pushservice.action.MESSAGE 和 com.baidu.android.pushservice.action.RECEIVE 两种消息。

发送com.baidu.androi- d.pushservice.action.RECEIVE 消息，可使被测应用崩溃。 

#### 2.1.14   开启  allowbackup  备份权限

开启  allowbackup  备份权限，存在备份数据泄露风险 

##### 2.1.14.1 问题描述 

被测应用的AndroidManifest.xml 文件中  allowBackup 属性值被设置为    true，可通过adb backup 对应用数据进行备份，在无 root的情况下可以导出应用中存储的所有数据，造成用户数据泄露。 

##### 2.1.14.2 测试方法 

1.   使用反编译软件  ApkTool 对 apk 进行反编译。使用命令

```python
apktool d XXX.apk ABC
```

 反编译  XXX.apk 到文件夹 ABC 

2.   AndroidManifest.xml 是每个   android 程序中必须的文件，位于整个项目的根目录，描述了 package 中暴露的组件（activities, services, 等等），以及各自的实现类，各种能被处理的数据和启动位置。

     从安全角度来看，它包含了应用程序中所有使用到的组件信息，同时它还会显示应用程序使用的   permissiosns 信息。

     在其中搜索allowBackup 属性，检查是否被设置为    true。 

##### 2.1.14.3 危害级别 

未将android:allowBackup 属性设置为false，则为高风险。 

#### 2.1.15   开启  Debuggable   属性

开启  Debuggable属性，存在应用信息篡改泄露风险 

##### 2.1.15.1 问题描述 

被测应用的`AndroidManifest.xml` 文件中Debuggable属性值被设置为 `true`，可以设置断点来控制程序的执行流程 ，在应用程序运行时修改其行为。 

##### 2.1.15.2 危害级别 

未将  `android: Debuggable` 属性设置为false，则为高危险。 

##### 2.1.15.3 测试方法 

1. 使用反编译软件 ApkTool 对 apk 进行反编译。详见第一节。 

2. 在 AndroidManifest.xml 中搜索   Debuggable 属性，检查是否被设置为true。 

#### 2.1.16   webview  组件安全 

##### 2.1.16.1 问题描述 

Android 4.2 版本以下的webview 组件存在安全漏洞（CVE-2012-6636）。  

##### 2.1.16.2 危害级别 

###### 符合6： 

`target Sdk Version` 大于 17. 

###### 不符合： 

小于17 时，则为中风险。 

##### 2.1.16.3 测试方法 

1. 1.检 查应 用  `AndroidManifest.xml` 中的  `targetSdkVersion` 是否大于等于17； 
2. 2.使用测试网页进行测试（腾讯的测试页面链接，在被测应用中打开即可。http://security.tencent.com/lucky/check_tools.html） 

#### 2.1.17   开发者证书不规范

开发者证书不规范，导致开发者身份信息不明 

##### 2.1.17.1 问题描述 

被测应用的开发者证书不规范，导致被测应用的开发者身份信息不是与中国移动相关的信息。 

##### 2.1.17.2 危害级别 

在安装包中未发现签名证书，则为高风险。 

##### 2.1.17.3 测试方法 

###### 方法一：

使用`JAVA keytool` 工具查看**签名** 

1. 1.解压被测APK，将   `META-INFO` 下的  RSA 文件拷贝到本机目录下。 
2. 2.进入JAVA 安装目录的子目录  bin 下，在  dos 盘符下键入命令 

```python
keytool –printcert –file 目录\xxx.RSA 
```

###### 方法二：

使用JEB 查看签名 

1.   启动  JEB，将被测应用在  JEB 中打开，在    Certificate 页签查看签名证书。

#### 2.1.18   WebView的 JS 对象注入漏洞 

##### 2.1.18.1 问题描述 

在 webView 下有一个非常特殊的接口函数`addJavascriptInterface`，能实现本地 java 和 js 的交互。

被测应用中存在    WebView 漏洞，

没有对注册 JAVA 类的方法调用进行限制，导致攻击者利用`addJavascriptInterface` 这个接口函数穿透 `webkit` 控制  android 本机。 

##### 2.1.18.2 危害级别 

如果未对    `addJavascriptInterface` 参数做过滤，或未使用声明

`@JavascriptInterface` 来代替   `addjavascriptInterface`，则为中危险。 

##### 2.1.18.3 测试方法 

1.   利用反编译软件 dex2jar 和 jdgui.exe 得到源代码。具体步骤如下： 

     - 1）首先将    APK 文件后缀改为  zip 并解压，得到其中的classes.dex，它就是    java 文件编译再通过 dx 工具打包而成的，将classes.dex 复制到  dex2jar.bat 所在目录   dex2jar-0.0.9.9 文件夹。 

     - 2）   在命令行下定位到dex2jar.bat 所在目录，运行dex2jar.bat  classes.dex，生成   classes_dex2jar.jar  

     - 3）   进入  jdgui 文件夹双击     jd-gui.exe，打开上面生成的  jar包  classes_dex2jar.jar，即可看到源代码了。  

2.   在源代码中搜索如下的    JAVA 类。

3.   查看版本号，如果是   Android  4.2 之前版本查看源代码中是否对 addJavascriptInterface 的输入参数进行过滤；如果是Android  4.2 及之后版本，检查是否声明@JavascriptInterface     来代替  addjavascriptInterface。 

#### 2.1.19   WebView   密码明文存储 

##### 2.1.19.1 问题描述 

Android 的 WebView 组件中默认打开了提示用户是否保存密码的功能，如果用户选择保存，用户名和密码将被明文存储到该应用目录databases/webview.db 中。

而本地明文存储的用户名和密码，不仅会被该应用随意浏览，其他恶意程序也可能通过提权或者root 的方式访问该应用的webview 数据库，从而窃取用户登录过的用户名信息以及密码。 

##### 2.1.19.2 危害级别 

###### 符合： 

如果  WebView 中的  SetSavePassword 选项设置为     false 则符合。 

###### 不符合： 

如果   WebView 中的 SetSavePassword 选项设置为     true。则不符合可定义为高风险。 

##### 2.1.19.3 测试方法 

1. 1.通过与WebView js 对象注入漏洞相同的方式查看WebView 配置。 

#### 2.1.20 WebView忽略  SSL 证书错误 

##### 2.1.20.1 问题描述 

Android  WebView 组件加载网页发生证书认证错误时，会调用WebViewClient 类的onReceivedSslError 方法，如果该方法实现调用了  handler.proceed()来忽略该证书错误，则会受到中间人攻击的威胁，可能导致隐私泄露 

##### 2.1.20.2 危害级别 

###### 符合： 

如果  onReceivedSslError 方法没有实现调用 handler.proceed()来忽略证书错误，则符合。 

###### 不符合： 

onReceivedSslError 方法实现调用handler.proceed()来忽略证书错误，则不符合。中风险。 

##### 2.1.20.3 测试方法 

在反编译代码中直接搜索关键字：“`onReceivedSslError`”。    

####  2.1.21    WebView域控制不严格 

##### 2.1.21.1 问题描述 

WebView 是 Android 用于显示网页的控件，是一个基于 Webkit 引擎.展现web 页面的控件。

WebView控件功能除了具有一般View 的属性和设置外，还可对    URL 请求.页面加载.渲染.页面交互进行处理。 

该漏洞产生的原因是在Android 应用中，WebView  开启了   file 域访问，允许file 域访问http 域，且未对file 域的路径进行严格限制所致。

攻击者通过  URL Scheme 的方式，可远程打开并加载恶意HTML文件，远程获取 APP 中包括用户登录凭证在内的所有本地敏感数据。 

##### 2.1.21.2 危害级别 

###### 符合： 

WebView 中的  `setAllowFileAccessFromFileURLs` 和 `setAllowUniversalAccessFromFileURLs` 为 `false`。 

###### 不符合： 

WebView 中的  setAllowFileAccessFromFileURLs 或 setAllowUniversalAccessFromFileURLs 为 true。

WebView 可以直接被外部调用，并能够加载外部可控的HTML 文件。如果都满足则为高危险。 

##### 2.1.21.3 测试方法 

1. 1.如果activity 中使用了WebView，那么要关闭activity 的导出功能。 
2. 2.如果activity 必须导出则需确认如下属性： 

#### 2.1.22 ZipperDown漏洞 

##### 2.1.22.1 问题描述 

ZipperDown 漏洞主要是指应用在解压压缩包的时候，如果处理不当会导致路径穿越，进一步可能会覆盖应用本地文件的一类漏洞。

其具有通用性，在安卓.IOS.Web等多种应用中都可能存在。 

##### 2.1.22.2 危害级别 

###### 符合： 

APP 没有解压压缩包的功能需求或者没有使用危险代码（在测试方法中有详细信息） 

###### 不符合： 

使用危险代码则为高危漏洞。 

##### 2.1.22.3 测试方法 

1.采用   apktool 等 APP 代码逆向工具，对  APP 客户端进行反编译逆向处理。在反编译代码中寻找类似如下危险代码： 

#### 2.1.23    APP 客户端逆向敏感信息泄露 

##### 2.1.23.1 问题描述 

APK 源代码中的敏感信息会为攻击者提供便利。 

##### 2.1.23.2 危害级别 

###### 符合： 

逆向后的 APP 不存在敏感信息。 

###### 不符合： 

逆向后的 APP 包含敏感信息，则为低风险。 

##### 2.1.23.3 测试方法 

1. 1.采用   apktool 等 APP 代码逆向工具，对  APP 客户端进行反编译逆向处理； 

2. 2.查看所有代码文件，是否包含敏感信息，如：测试账号及密码.敏感链接.IP 地址.敏感邮件地址等。 

#### 2.1.24   密钥硬编码 

##### 2.1.24.1 问题描述 

在对一些数据进行加密时，密钥是最重要的一环。

密钥如果硬编码在程序中，可能会导致加密数据被直接破解。 

##### 2.1.24.2 危害级别 

###### 符合： 

如在反编译代码中没有找到硬编码的密钥则符合 

###### 不符合： 

直接在反编译代码中找到了硬编码的密钥则不符合。高风险。 

##### 2.1.24.3 测试方法 

1.   通过反编译搜索字符串的方式来尝试直接搜出硬编码密钥。如  key，privateKey 等等。 

2.   也可是尝试搜索相关加密的函数。在函数参数中寻找相对应的 key。再去定位是否硬编码

#### 2.1.25   不安全的随机数 

##### 2.1.25.1 问题描述 

在密码学实现过程中需要考虑到随机数生成的安全性。

不安全的随机数可能会导致加密数据被破解的风险。 

##### 2.1.25.2 危害级别 

如使用了不安全的随机数生成函数来生成随机数则不符合。中风险。 

##### 2.1.25.3 测试方法 

反编译代码后搜索   random，如果在反编译代码中搜索到了类似如下内容则表示不安全。 


如果搜索到了随机数的生成方式为如下表示方式则安全。

#### 2.1.26   不安全的加密算法.加密模式和密钥长度不足 

##### 2.1.26.1 问题描述 

不安全的加密算法.加密模式和密钥长度会使加密产生脆弱性。

如自定义的不安全算法.已知的不安全算法.ECB 加密模式和过短的

密钥长度。由于此类问题大多见于同一位置。所以合并成一项。 

##### 2.1.26.2 危害级别 

###### 符合： 

未使用不安全的加密算法.加密模式和密钥长度则符合。 

###### 不符合： 

如使用了不安全的加密算法/加密模式/密钥长度则为不符合。中风险 

##### 2.1.26.3 测试方法 

在反编译代码中搜索关键字如 Cipher.encryt.decrypt  等。 

- 不安全的加密算法：DES.MD2.MD4.SKIPJACK.RC2 
- 不安全的密钥长度：3DES   在密钥长度     256 以下，k1=k2=k3时不安全.RC4   和 BlowFish 当密钥长度     128 以下不安全。RSA 在密钥长度1024 以下时不安全。 
- 不安全的加密模式：EBC 

- 不安全的散列算法：md5.sha1 

#### 2.1.27   关键页面存在钓鱼劫持风险，导致用户信息泄露 

##### 2.1.27.1 问题描述 

劫持钓鱼，指恶意应用针对正常应用的特定界面进行仿冒替换，

诱骗用户在仿冒界面操作，达到钓鱼目的。此类攻击，多针对 APP 的鉴权或支付场景，诱骗用户输入关键隐私信息，如账号.登陆密码和支付密码等，达到隐私窃取的目的。 

##### 2.1.27.2 危害级别 

如关键   activity 不存在劫持提醒，则为高危险。 

##### 2.1.27.3 测试方法 

1.   编写代码获取栈顶  Activity 名称，查看关键Activity 是否可被钓鱼劫持。      

   测试包含敏感信息的界面（登录，支付等）查看是否有加钓鱼劫持保护，如提示用户等。 

#### 2.1.28    Token 缺陷绕过鉴权机制 

##### 2.1.28.1 问题描述： 

如果被测应用没有使用有效的 token 机制，对登陆响应中的服务器返回的鉴权信息进行修改，即可绕过服务器鉴权，直接访问系统内部信息。 

##### 2.1.28.2 危害级别 

篡改鉴权信息后，APP  成功登陆，则为高危险。 

##### 2.1.28.3 测试方法 

1. 1.利用   BurpSuite 监听登陆响应，对登陆响应中的服务器返回的鉴权信息进行修改。      
2. 2.修改后成功绕过登录界面，进入应用界面。 

####  2.1.29    密码修改和取消 

##### 2.1.29.1 问题描述 

手势密码易被恶意删除或篡改。 

检测客户端在取消手势密码时是否会验证之前设置的手势密码，

检测是否存在其他导致手势密码取消的逻辑问题。 

##### 2.1.29.2 危害级别 

###### 符合： 

修改手势密码时验证原密码。 

###### 不符合： 

当取消或修改手势密码时，如果不会验证之前的手势密码或普通密码，则为中风险 

##### 2.1.29.3 测试方法 

1. 1.进入客户端设置手势密码的位置，一般在个人设置或安全中心等地方。 

2. 2.进行手势密码修改或取消操作，观察进行此类操作时是否需要输入之前的手势密码或普通密码。 

#### 2.1.30    密码锁定策略 

##### 2.1.30.1 问题描述 

手势密码可被暴力破解。 

测试客户端是否存在手势密码多次输入错误被锁定的安全策略。 

##### 2.1.30.2 危害级别 

###### 符合： 

对错误次数进行限制。 

###### 不符合： 

当服务器不会验证手势密码输入错误次数时为中风险 

##### 2.1.30.3 测试方法 

1. 1.首先通过正常的操作流程设置一个手势密码。 

2. 2.输入不同于步骤  1 中的手势密码，观察客户端的登陆状态及相应提示。

若连续输入多次手势密码错误，观察当用户处于登陆状态时是否退出当前的登陆状态并关闭客户端；当客户未处于登录状态时是否关闭客户端并进行一定时间的输入锁定。 

####    2.1.31    明文传输敏感信息 

##### 2.1.31.1 问题描述 

敏感数据传输未加密容易遭受中间人攻击，导致敏感数据被窃取。 

检查认证过程中是否对关键字段进行加密 

验证传输通道是否加密 

##### 2.1.31.2 危害级别 

###### 符合： 

关键字段进行加密处理，如：用户名.密码和用户身份信息等。 

判断传输协议为 https。 

###### 不符合： 

不满足以上条件，则为低风险。 

##### 2.1.31.3 测试方法 

1. 1.采用抓包工具，如：BurpSuite    等对登陆过程进行抓包 
2. 2.验证是否对用户名密码等关键字段进行加密。 

3. 3.采用抓包工具，如：BurpSuite    等对登陆过程进行抓包 

4. 4.验证是否对传输通道进行加密，如：https。 

#### 2.1.32   登陆密码键盘按键可被截屏记录 

##### 2.1.32.1 问题描述 

客户端登陆处采用系统键盘，按键会伴有阴影，并且按下字符是原文显示后才变成“`*`”进行模糊化处理，分辨按下字母较为明显，

恶意攻击者可利用此漏洞对感染木马的手机进行截屏攻击，以获得被感染木马者的密码。 

##### 2.1.32.2 危害级别 

在输入密码是可使用截屏功能，则为中危险 

##### 2.1.32.3 测试方法 

1.在模拟器中安装手机   APP 客户端，对 所有    的需要输入密码的输入框进行输入操作，同时观察密码是否被明文显示。 

#### 2.1.33   密码软键盘安全 

##### 2.1.33.1 问题描述 

检测是否存在自开发的软键盘; 

检测是否采用软键盘并随机布局. 

##### 2.1.33.2 危害级别 

1. 1.当客户端不存在自定义而是使用系统默认键盘时，则为中风险 

2. 2.客户端存在自定义软键盘但未调用，则为中风险 

3. 3.满足要求时，安全 

##### 2.1.33.3 测试方法 

1. 1.进入密码输入框，查看系统是否调用自开发的软键盘； 
2. 2.连续两次聚焦密码.敏感信息输入框，查看键位是否随机分布. 

#### 2.1.34   客户端更新安全性 

##### 2.1.34.1 问题描述 

客户端自动更新机制不完善，可能导致系统安装危险应用。 

测试客户端自动更新机制是否安全。 

##### 2.1.34.2 危害级别 

1. 1.可以成功安装替换后的     APK，则为高风险 

2. 2.不能安装，则安全 

##### 2.1.34.3 测试方法 

1. 1.使用代理抓取检测更新的数据包，尝试将服务器返回的更新url 替换为恶意链接。看客户端是否会直接打开此链接并下载应用； 

2. 2.在应用下载完毕后，测试能否替换下载的 apk 文件，测试客户端是否会安装替换后的应用； 

#### 2.1.35   界面切换保护 

##### 2.1.35.1 问题描述 

缺少界面切换保护机制可能导致用户敏感信息泄露。 

检查客户端程序在切换到其他应用时，已经填写的账号密码等敏

感信息是否会清空，防止用户敏感信息泄露。如果切换前处于已登录状态，切换后一定时间内是否会自动退出当前会话。 

##### 2.1.35.2 测试方法 

1. 1.启动应用程序，进入登录界面； 

2. 2.输入用户名.密码，不登录，切换至其它应用界面或者主界面后，再切换回应用界面，查看密码是否清空； 

3. 3.登录应用程序，切换至其它应用界面或者主界面后，再切换回应用界面，查看是否自动退出及时间间隔； 

##### 2.1.35.3 危害级别 

1. 1.密码未清空，则为低风险 

2. 2.登录后切换界面.未退出，则为低风险 

3. 3.登录后切换界面.时间超过 5 分钟，则为低风险 

4. 4.满足要求时，则安全 

#### 2.1.36   密码复杂度 

##### 2.1.36.1 问题描述 

手势密码点数过少，会增加被破解的风险。/未对设置的密码复杂度进行有效验证。 

测试客户端手势密码复杂度，观察是否有点位数量判断逻辑。 

测试客户端注册或修改密码时是否对密码复杂度进行验证。 

##### 2.1.36.2 危害级别 

1. 1.当用户设置或修改手势密码时服务器会对手势密 码 安 全 性（使用点数）进行判断时无风险。 

2. 2.否则低风险。 

3. 3.修改密码或注册账户时，未进行复杂度校验则为中风险，可设置为弱口令则为高风险。 

##### 2.1.36.3 测试方法 

1. 1.进入客户端设置手势密码的页面进行手势密码设置。 

2. 2.进行手势密码设置，观察客户端手势密码设置逻辑是否存在最少点位的判断。 

3. 3.使用客户端进行密码修改或新账户注册，查看是否有密码复测度验证。 

#### 2.1.37   密码软键盘安全 

##### 2.1.37.1 问题描述 

按键过程尤其是密码输入过程可被录屏软件记录并识别，存在密码泄露风险。 

##### 2.1.37.2 危害级别 

1.当客户端输入密码可在密码框显示或按键可通过闪动识别则为中风险。 

##### 2.1.37.3 测试方法 

安装  RecordMyScreen(Tweak)，记录软键盘的输入过程。 

或使用录屏专家工具   recscreen 

#### 2.1.38   APP 恶意木马捆绑安全检查 

##### 2.1.38.1 问题描述 

App 内被植入木马，用户信息存在被窃取的风险。 

#### 2.1.38.2 危害级别 

1.若查杀有木马存在则为高风险。 

##### 2.1.38.3 测试方法 

1.采用杀毒软件等工具，对APP 代码进行安全扫描； 

2.检查   APP 应用是否捆绑了恶意木马，如：键盘记录恶意木马等。 

#### 2.1.39   APP 客户端敏感信息实时日志 

##### 2.1.39.1 问题描述 

App 日志中包含敏感信息。 

##### 2.1.39.2 危害级别 

1.调试日志包含敏感信息，如用户名及密码，则为高风险 

2.调试日志包含请求.响应信息，则为低风险。 

3.满足要求时，安全。 

##### 2.1.39.3 测试方法 

1.下载   sdk，并连接模拟器； 

2.输入   adb logcat 回车，查看日志。 

#### 2.1.40   手势密码校验 

##### 2.1.40.1 问题描述 

手势密码存储在本地进行验证，存在被恶意利用风险 

##### 2.1.40.2 危害级别 

1.未向服务发送请求时，本地校验，则为高风险 

2.发送请求，并做校验，则安全 

##### 2.1.40.3 测试方法 

1.正常使用手势密码进行登录操作； 

2.使用   burpsuit 抓包分析登录过程是否向服务器发送手机密码验证请求。 

#### 2.1.41   手势密码无锁定机制 

##### 2.1.41.1 问题描述 

手势密码可多次尝试，没有锁定限制。 

##### 2.1.41.2 危害级别 

未设置手势密码锁定次数，则为中危险。 

##### 2.1.41.3 测试方法 

1.   在模拟器中安装手机   APP 客户端，对其中的手势密码多次尝试，检查是否有锁定策略 

#### 2.1.42   APK 无自动锁屏功能 

##### 2.1.42.1 问题描述 

用户长时间不操作  APK，无自动锁屏功能。 

##### 2.1.42.2 危害级别 

长时间不操作app，未自动锁屏，则为中危险 

##### 2.1.42.3 测试方法 

1.在模拟器中安装手机   APP 客户端，切换到账户显示页面，5 分钟内不操作     APK，观察    APK 是否自动进行锁屏。

#### 2.1.43   账号登录限制 

##### 2.1.43.1 问题描述 

同一账号可在多个设备同时登录，无法及时识别异常登录行为。 

##### 2.1.43.2 危害级别 

1.前登录的设备，应用程序会话仍然有效，则为低风险。 

2.前登录的设备，应用程序提示，账户异地登录并退出，则安全。 

##### 2.1.43.3 测试方法 

1)   用同一账户分别在两个设备上面进行登录，当后登录设备登录成功后，查看前登录的设备，客户端是否有提示并退出 

#### 2.1.44   安全退出 

##### 2.1.44.1 问题描述 

账号退出时，未能及时终止会话。 

##### 2.1.44.2 危害级别 

1.未向服务器发送终止会话请求或者会话未失效，则为中风险。  

2.不能重发，则安全。 

##### 2.1.44.3 测试方法 

1)   点击退出功能，使用   BurpSuite 对 APP 数据包进行抓包，查看是否向服务器发送终止会话请求； 

2)   点击退出功能后，使用BurpSuite 对之前请求的功能repeat，查看服务器是否响应成功。 

#### 2.1.45   会话安全设置 

##### 2.1.45.1 问题描述 

未设置会话超时机制，会话驻留时间过长。 

测试客户端在超过  20 分钟无操作后，是否会使会话超时并要求

重新登录。超时时间设置是否合理。 

##### 2.1.45.2 危害级别 

1.20 分钟后，会话未超时，则为低风险。 

2.满足时间要求内，会话失效并退出登录，则安全。 

#### 2.1.45.3 测试方法 

1)   登录应用程序，20分钟内无操作，查看   20 分钟后，会话是否超时并退出登录； 

### 2.2 IOS APP 客户端 

#### 2.2.1 XcodeGhost  病毒 

##### 2.2.1.1  问题描述 

被测应用的开发者使用非苹果公司官方渠道下载的 Xcode 工具开发  IOS 应用程序时，会向所开发的正常 APP 中植入恶意代码。

被植入恶意程序的  APP 可以在   App  Store 正常下载并安装使用。

该恶意代码窃取应用名.应用版本号.系统版本号.语言.国家名.开发者符号.app 安装时间.设备名称.设备类型等信息，造成用户数据泄露。 

##### 2.2.1.2  危害级别 

符合： 

能搜索到远端服务器地址，并可拦截到向远端服务器发送数据请求。风险级别为高风险。 

不符合： 

未能搜索到远端服务器地址。 

##### 2.2.1.3  测试方法 

1. 对被测应用ipa 进行解压，Payload下有   xxxx.app 文件夹，xxxx 即为 APP 的主程序文件名称，在 xxxx.app 目录下，找到同名的主程序文件，拷贝到本机目录下。 

2. 使用    IDA  打开主程序文件   DHViewDhEnterprise，搜索 Xcode 病毒的关键字。 

   搜索远端服务器地址：“`init.icloud‐analysis.com`”。

3. 是否包含 POST    到服务端的数据包。 



#### 2.2.2  Match-o  静态分析 

##### 2.2.2.1  问题描述 

IPA 包中的可执行程序格式为    Match-o. 如果在经过反汇编之后

可以轻松的理解程序内部运行逻辑或者直接找到敏感信息，那么势必对安全性有巨大的影响。 

#### 2.2.2.2 危害描述 

符合： 

反汇编后的代码经过混淆 

不符合： 

反汇编后的代码未经过混淆。应用内部逻辑可以清晰实别则为中风险。 

##### 2.2.2.3 测试方法 

1.将   IPA 包中的可执行程序拖入    IDA  pro 中并搜索关键字如Login: 

2.如果汇编代码不易读可以按 F5 来生成伪代码： 可以通过伪代码来判断程序是否混淆。 

3.在字符串搜索框中搜索关键字，比如    https：//等等 通过这种方式可以判断是否敏感字符串是否为可读状态。 

#### 2.2.3  APP 客户端敏感信息存储安全（实时日志.数据库文件） 

##### 2.2.3.1  问题描述 

敏感信息可分为产品敏感信息和用户敏感信息两类，我们对产品敏感信息是这样界定的： 

- 泄露后直接对企业安全造成重大损失或有助于帮助攻击者获取
- 企业内部信息，并可能帮助攻击者尝试更多的攻击路径的信息。 


以下这些信息都属于产品敏感信息：登录密码.后台登录及数据库地址.服务器部署的绝对路径.内部 IP .地址分配规则.网络拓扑.页面注释信息（开发者姓名或工号.程序源代码）。 



而用户敏感信息有两个界定原则： 

- 用户隐私保护主要考虑直接通过该数据或者结合该数据与其它的信息，可以识别出自然人的信息。 
- 一旦发生数据泄露事件，可以被恶意人员利用并获取不当利润。 


由此标准参考，以下字段在数据库的存储以及传输过程中，我们建议加密处理：密码.手机号.快捷支付手机号. Email .身 份 证 .银行卡. CVV 码.有效期。

 

而这些敏感信息泄露的原因大多数情况下是因为信息未加密或储存位置不当造成的： 

- 代码中明文使用敏感信息，比如：服务器地址.数据库信息等 

- 数据库中明文保存敏感信息，比如：账号.密码.银行卡等 

- SD 卡中保存敏感信息或隐私数据，比如：聊天记录.通讯录等 

- 日志中打印敏感信息：比如：账号.密码 

- 通信过程中明文传输敏感信息 


以上这些做法都会使 APP 中的敏感信息暴露在黑客的眼皮底下，

只要黑客认为该信息有价值，他就会轻而易举的获取这些敏感信息，

最直接的损失可能就是用户的账号被盗.网银被盗刷等。 

##### 2.2.3.2  危害级别 

符合： 

本地存储文件中不包含敏感信息，如：用户名和密码。根据泄露

信息严重程度定义漏洞级别。 

不符合： 

外部存储文件中包含敏感信息。 

##### 2.2.3.3  测试方法 

实时日志： 

1.开启   itools 工具或   PP 助手工具，启动实时日志功能； 

2.查看日志信息中是否包含敏感信息，比如用户名.密码等。 



数据库文件： 

对客户端私有目录下的私有数据文件内容进行检查，看是否包含敏感信息。 

(对于IOS8，所有程序安装在目录/var/containers/Application/客户端名 私有数据保存在  /private/var/mobile/Containers/Data/Application/客户端名 查找数据库文件，sqlite 数据库文件通常文件名以.db. .localstorage. .sqlite 等结尾 ) 


#### 2.2.4 APP 客户端敏感信息存储安全（密钥链数据） 

##### 2.2.4.1  问题描述 

敏感信息可分为产品敏感信息和用户敏感信息两类，我们对产品

敏感信息是这样界定的： 

泄露后直接对企业安全造成重大损失或有助于帮助攻击者获取企业内部信息，并可能帮助攻击者尝试更多的攻击路径的信息。 

以下这些信息都属于产品敏感信息：登录密码.后台登录及数据库地址.服务器部署的绝对路径.内部 IP .地址分配规则.网络拓扑.页面注释信息（开发者姓名或工号.程序源代码）。 

而用户敏感信息有两个界定原则： 

用户隐私保护主要考虑直接通过该数据或者结合该数据与其它的信息，可以识别出自然人的信息。 

一旦发生数据泄露事件，可以被恶意人员利用并获取不当利润。 

由此标准参考，以下字段在数据库的存储以及传输过程中，我们建议加密处理：密码.手机号.快捷支付手机号. Email .身 份 证 .银行卡. CVV 码.有效期。 

而这些敏感信息泄露的原因大多数情况下是因为信息未加密或储存位置不当造成的： 

- 代码中明文使用敏感信息，比如：服务器地址.数据库信息等 

- 数据库中明文保存敏感信息，比如：账号.密码.银行卡等 

- SD 卡中保存敏感信息或隐私数据，比如：聊天记录.通讯录等 

- 日志中打印敏感信息：比如：账号.密码 

- 通信过程中明文传输敏感信息 

- 以上这些做法都会使 APP 中的敏感信息暴露在黑客的眼皮底下，

只要黑客认为该信息有价值，他就会轻而易举的获取这些敏感信息，

最直接的损失可能就是用户的账号被盗.网银被盗刷等。 

##### 2.2.4.2  危害级别 

符合： 

密钥链中不包含敏感信息，如：用户名和密码。根据泄露信息严重程度定义漏洞级别。 

不符合： 

密钥链中包含敏感信息。 

##### 2.2.4.3  测试方法 

使用  `Snoop-it` 工具，在   Keychain 功能中查看客户端对**密钥链的访问**。

#### 2.2.5 进程安全：内存访问 

##### 2.2.5.1  问题描述 

攻击者可利用漏洞获取内存中的敏感信息。 

##### 2.2.5.2  危害级别 

符合： 

未查找到敏感信息。 

不符合： 

查找到用户的敏感信息，比如密码，则为高风险。 

##### 2.2.5.3  测试方法 

1.运行被测客户端，然后使用 SSH 隧道连接设备，使用用户名root,密码默认为alpine 

2.使用进程查看和监视ps，获得被测客户端的PID。然后使用内存搜索工具搜索字符串，使用指令    ps –A  |  grep  Application  查看客户端     PID。 

3./var/mobile/Media/该目录下为     PP 助手拖入的目录, 将文件拖入手机目录中，修改权限为 777， 

4.dpkg  -i  包名安装     mem-check 

5.使用方法如下： （mem-check –p pid  -s string）。     

#### 2.2.6 自动引用计数 

##### 2.2.6.1  问题描述 

检测客户端是否启用   Automatic Reference Counting(ARC)编译选项，采用     ARC 选项编译的应用程序能够自动对 Objective-C 对象进行内存管理，防止造成内存破坏漏洞。 

##### 2.2.6.2  危害级别 

若客户端未启用 ARC，此时为低风险；若无异常则无风险。 

##### 2.2.6.3  测试方法 

使用`otool` 在 iOS 设备上进行操作，查找`_objc_release`关键字。 

#### 2.2.7 堆栈保护 

##### 2.2.7.1  问题描述 

检测客户端是否起启用    Stack Smashing Protector(SSP)编译选项，采用    SSP 选项编译的应用程序能够防止栈溢出等栈破坏漏洞的攻击。 

##### 2.2.7.2  危害级别 

若客户端未启用 SSP，此时为低风险；若无异常则无风险。 

##### 2.2.7.3  测试方法 

如图，使用otool 在iOS 设备上进行操作，查找`__stack_chk_guard` 关键字。 

#### 2.2.8 位置无关代码 

##### 2.2.8.1  问题描述 

检测客户端是有启用   Position Independent Executeable(PIE)编译选项，采用 PIE 选项编译的引用程序允许使用地址空间随机分布功能(ASLR, Adress Space Layout Ramdomization)，提供内存漏洞被利用的难度。 

##### 2.2.8.2  危害级别 

若客户端未启用 PIE，此时为低风险；若无异常则无风险。 

##### 2.2.8.3  测试方法 

如图，使用otool 在 iOS 设备上进行操作，查看是否设置PIE 标志。      

#### 2.2.9 不安全的随机函数 

##### 2.2.9.1  问题描述 

检测客户端是否使用伪随机数函数，若使用伪随机数进行加密可能导致被暴力破解。建议使用苹果安全随机函数 SecRandomCopyBytes。 

##### 2.2.9.2  危害级别 

若客户端使用不安全的随机函数，此时为低风险；若无异常则无风险； 

以上可使用移动应用测试框架 MobSF 进行测试。 

检测客户端是否保存明文敏感信息。 

对于iOS 每一个应用，iOS系统都会分配一个私有数据目录，用于存储应用私有数据。该目录为” `/var/mobile/Containers/Data/Application/`”。 

##### 2.2.9.3  测试方法 

如图，使用     otool 在 iOS 设备上进行操作，查找  srand 和 random关键字。 

#### 2.2.10   本地数据文件信息泄露 

##### 2.2.10.1 问题描述 

查看本地数据文件是否存在敏感信息泄露 

##### 2.2.10.2 危害级别 

若私有目录中存在存储了用户登录密码（明文或只进行过一次单项  hash），手势密码（明文或只进行一次单项   hash）或曾经访问过网址的  Cookie 等铭感信息的文件，此时为高风险，若不存在则无风险。 

##### 2.2.10.3 测试方法 

1. 检测客户端配置文件。 在检查安装数据目录   Library/Preferences/下的  plist 文件，看是否包含敏感信息。 

2. 本地数据库文件。 在数据目录下查找以.db   结尾的数据库文件。 对于使用了     Webview 控件的应用程序，会在   Library/WebKit/目录下保存Webkit 本地存储文件与   Library/Cookies/ 目录下的Cookies.binarycookies 文件。 

3. 程序缓存与测试数据。 查找程序安装目录与数据目录下的文件，检查文件中的数据是否包含敏感信息。如果包含非明文信息，在反编译程序中查找相应的加密算法，检查加密算法是否安全。（例如，采用 base64 的编码方法是不安全的）。 

#### 2.2.11   日志打印 

##### 2.2.11.1 问题描述 

检测客户端在日志中是否打印敏感信息。 

##### 2.2.11.2 危害级别 

当  syslog 日志中会显示用户输入信息（包括用户名.明文密码或单次   hash 密码）.用户范围跟服务器的     URL 和端口等核心敏感信息时为高风险；当日志中会显示调用逻辑或者一些可供攻击者猜测逻辑的报错时为中风险；当日志中会打出除上述的一些开发商的调试信息为低风险；如果不存在上述情况则无风险。 

##### 2.2.11.3 测试方法 

在  iPhone 上安装   syslogd，并使用    idevicesyslog 检查日志是否包含敏感信息。 

#### 2.2.12   硬编码 

##### 2.2.12.1 问题描述 

检测客户端程序二进制文件是否存在硬编码问题。 

#### 2.2.12.2 危害级别 

使用硬编码密钥为高风险；若无异常则无风险。 

##### 2.2.12.3 测试方法 

使用  strings 与 grep 对二进制文件进行分析，看是否将加密算法的密语硬编码在程序中。 

#### 2.2.13   后台快照 

##### 2.2.13.1 问题描述 

检测客户端程序进入后台时，后台快照时候保存敏感信息的问题。 

##### 2.2.13.2 危害级别 

若后台快照中出现敏感信息的页面，则为高风险；无异常则无风险。 

##### 2.2.13.3 测试方法 

进入程序的包含敏感信息的页面，然后进入后台，在Library/Caches/Snapshots 中查看后台快照是否包含该敏感信息页面内容。 

#### 2.2.14   随机布局软键盘 

##### 2.2.14.1 问题描述 

检测客户端实现的软键盘，是否满足键位随机分布的要求。 

##### 2.2.14.2 危害级别 

当客户端软件未进行随机处理时为低风险；当客户端软键盘只在某一个页面初始化一次而不是在点击输入框时重新进行随机化也为低风险。 

##### 2.2.14.3 测试方法 

人工检测。 

#### 2.2.15   粘贴板 

##### 2.2.15.1 问题描述 

检测客户端敏感信息（或输入框）的数据是否能被复制。 

##### 2.2.15.2 危害级别 

当客户端敏感信息能被复制时（如银行卡     CVV 号码.登录密码等）此时为高风险；若无异常则无风险。 

##### 2.2.15.3 测试方法 

人工检测。 

#### 2.2.16   密码复杂度检测 

##### 2.2.16.1 问题描述 

测试客户端程序是否检测用户输入密码强度，禁止用户设置弱口令。 

##### 2.2.16.2 危害级别 

当系统允许用户设置若密码时为低风险，如果系统存在一定的安

全策略（密码使用数字和字母组成，至少为 8 位）时无风险。 

##### 2.2.16.3 测试方法 

人工测试，尝试将密码修改为弱口令，如：123456.111111.654321.123123 等，查看客户端是否拒绝弱口令。 

#### 2.2.17   账号登录限制 

##### 2.2.17.1 问题描述 

测试同一账号是否可以同时在多个设备上成功登录客户端，进行操作。 

##### 2.2.17.2 危害级别 

若同一账号可以同时在多台移动终端设备上登录时为低风险，若不可以则无风险。 

##### 2.2.17.3 测试方法 

人工测试。 

#### 2.2.18   账户锁定策略 

##### 2.2.18.1 问题描述 

测试客户端是否限制登录尝试次数。防止攻击者暴力破解用户密码。 

##### 2.2.18.2 危害级别 

当系统不存在账户锁定策略时为中风险；若存在则无风险。 

##### 2.2.18.3 测试方法 

人工测试。 

#### 2.2.19   会话安全设置 

##### 2.2.19.1 问题描述 

测试客户端在超过一段时间无操作后，是否会使会话超时并要求重新登录。超时时间设置是否合理。 

##### 2.2.19.2 危害级别 

当系统不存在会话超时逻辑判断时为低风险；若存在则无风险。 

##### 2.2.19.3 测试方法 

人工测试。 

#### 2.2.20   界面切换保护 

##### 2.2.20.1 问题描述 

检查客户端程序在切换到其他应用时，已经填写的账号密码等敏感信息是否会清空，防止用户敏感信息泄露。如果切换前处于已登录状态，切换后一定时间内是否会自动退出当前会话。 

##### 2.2.20.2 危害级别 

当移动终端进行进程切换操作，显示界面不为客户端页面时，若客户端提示用户确认是否为本人操作，则无风险；若无相应提示则为低风险。 

##### 2.2.20.3 测试方法 

人工检测。在登录界面（或者转账界面等涉及密码的功能）填写登录名和密码，然后切出，再进入客户端，看输入的登录名和密码是否清楚。登录后切出，5分钟内自动退出为安全。 

#### 2.2.21   UI 信息泄露 

##### 2.2.21.1 问题描述 

检查客户端的各种功能，看是否存在敏感信息泄露问题。 

##### 2.2.21.2 危害级别 

若用户名输入错误和密码输入错误时提示信息不同则存在UI 信息泄露问题，此时为低风险；否则无风险。 

##### 2.2.21.3 测试方法 

人工测试。使用错误的登录名或密码登录，看客户端提示是否不同。显示卡号等敏感信息时是否进行部分遮挡。 

#### 2.2.22   验证码安全性 

##### 2.2.22.1 问题描述 

测试客户端再登录和交易时是否使用图形验证码。验证码是否符合如下要求：有数字和字母等字符混合组成；采取图片底纹干扰.颜

色变换.设置非连续性及旋转图片字体.变异字体显示样式等游戏啊哦方式，防范恶意代码自动识别图片上的信息；具有使用时间限制并仅能使用一次；验证码由服务器生成，客户端文集那种不包含图形验证码文本内容。 

#### 2.2.22.2 危害级别 

当图形验证码由本地生成而不是从服务器获取时为中风险；当验证码安全性低或不存在验证码时为中风险；不存在以上两个问题时无风险。 

##### 2.2.22.3 测试方法 

人工测试。 

#### 2.2.23   安全退出 

##### 2.2.23.1 问题描述 

测试客户端退出时是否正常终止会话。 

##### 2.2.23.2 危害级别 

若客户端退出登录时不会和服务器进行     logout 的相关操作则为中风险；否则无风险。 

##### 2.2.23.3 测试方法 

检查客户端再退出时，是否向服务器端发送终止会话请求。客户端退出后，还能否使用推出前的会话   id 访问登陆后才能访问的页面。 

#### 2.2.24   密码修改验证 

##### 2.2.24.1 问题描述 

测试客户端在修改密码时是否验证旧密码正确性；以及修改密码的逻辑。 

#### 2.2.24.2 危害级别 

当进行密码修改是是否要求原密码已验证其正确性，若不需要为中风险；如不需要输入原密码则中风险。 

##### 2.2.24.3 测试方法 

人工测试。 

#### 2.2.25   手势密码复杂度 

##### 2.2.25.1 问题描述 

测试客户端手势密码复杂度，检测是否有点位数量判断逻辑。 

##### 2.2.25.2 危害级别 

当用户设置或修改手势密码时服务器会对手势密码安全性（使用点位数量）进行判断时无风险；否则低风险。 

##### 2.2.25.3 测试方法 

1.   进入客户端设置手势密码的页面进行手势密码设置。 

2.   进行手势密码设置，观察客户端首饰密码设置逻辑是否存在最少点位的判断。 

#### 2.2.26   手势密码修改和取消 

##### 2.2.26.1 问题描述 

测试客户端在取消手势密码是否会验证之前设置的手势密码，检测是否存在其他导致手势密码取消的逻辑问题。 

##### 2.2.26.2 危害级别 

当取消或修改手势密码时，如果不会验证之前的手势密码则为中风险，若存在验证则无风险； 

##### 2.2.26.3 测试方法 

1.   进入客户端设置手势密码的页面进行手势密码设置。 

2.   进行手势密码修改或取消操作，检测进行次类操作时是否需要输入之前的手势密码或普通密码。 

3.   观察在忘记手势密码等其他客户端业务逻辑中是否存在无需原始手势或普通密码即可修改或取消手势密码的情况。 

4.   多次尝试客户端各类业务，检测是否存在客户端逻辑缺陷导致客户端可以跳转回之前业务流程所对应页面。

     若存在此类逻辑（例如手势密码设置），观察能否修改或取消手势密码。 

#### 2.2.27   手势密码本地信息保存 

##### 2.2.27.1 问题描述 

检测在输入手势密码以后客户端是否会在本地记录一些相关信息，例如明文或加密过的手势密码。 

##### 2.2.27.2 危害级别 

当本地保存了明文存储的手势密码时为高风险；当本地保存了只进行哈希散列的手势密码时为中风险；否则无风险； 

##### 2.2.27.3 测试方法 

1.   首先通过正常的操作流程设置一个手势密码。 

2.   检查/Library/的私有目录下是否存在手势密码对应的敏感文件，一般为 plist 文件。 

3.   若找到对应文件，观察手势密码是否进行加密。 

#### 2.2.28   手势密码锁定策略 

##### 2.2.28.1 问题描述 

测试客户端是否存在手势密码多次输入错误被锁定的安全策略。

防止被暴力破解。 

##### 2.2.28.2 危害级别 

当服务器不会验证手势密码输入错误次数时候为中风险；会进行验证时无风险。 

##### 2.2.28.3 测试方法 

人工测试。 

#### 2.2.29   反调试保护 

##### 2.2.29.1 问题描述 

检测客户端程序是否有反调试能力。 

##### 2.2.29.2 危害级别 

当客户端程序存在调试检测或者反调试时无风险；不存在则中风险。 

##### 2.2.29.3 测试方法 

使用  debugserver 在 iOS 设备上   attach 应用程序，在     mac 端使用  lldb 进行调试，检测客户端是否具备反调试的能力。 

在 iOS 设备上   attach 被测试的程序。 

将 1234 端口转发到本地 1234 端口，使用    lldb 进行调试。      

#### 2.2.30   反 dylib 注入 

##### 2.2.30.1 问题描述 

检测客户端程序是否有反     dylib 注入的能力。通 过注入动 态 链 接库，hook   客户端某些关键函数，从而获取敏感信息或者改变程序执行。 

##### 2.2.30.2 危害级别 

当客户端存在动态注入隐患时为中风险；否则则无风险。 

##### 2.2.30.3 测试方法 

可使用cycript 进行注入，检测程序是否被注入。 

#### 2.2.31   通信加密 

##### 2.2.31.1 问题描述 

客户端和服务端通信是否强制采用   https 传输。 

##### 2.2.31.2 危害级别 

当客户端和服务器的通信不经过 SSL 加密（或没有参考 TLS 协议，RFC4346   等实现加 密信道）时为高风险；当自实现通信算法存在漏洞可被解析或绕过时为高风险；使用低版本 SSL 协议（SSLV2，SSLV3 均存在漏洞，至少使用 TLSV1.1 以上算法）时为高风险；以上 问题均不存在时无风。 

##### 2.2.31.3 测试方法 

通过设置代理，使用   burpsuite 监听流量包，查看客户端是否采用  https 传输。 

#### 2.2.32   证书有效性 

##### 2.2.32.1 问题描述 

客户端程序和服务器端 SSL 通信是否严格检查服务器端证书有效性。

避免手机银行用户 受到 SSL 中间人攻击后，密码等敏感信息被嗅探到。 

##### 2.2.32.2 危害级别 

当客户端和服务器互相不验证证书时高风险，当只有客户端验证服务器证书时为中风险； 

当服务器不通过白名单的方式验证客户端时为中风险；

当客户端和服务器进行双向认证，并 且服务器通过白名单方式验证客户端证书时无风险。 

##### 2.2.32.3 测试方法 

通过  wifi 将手机和测试 PC 连接到同一子网。

在手机上配置代理，代理 IP 为测试 PC IP 地址，端口为代理的监听端口。

此时，客户端通信将 会转发给测试 PC 上的 burpsuite 代理。 

#### 2.2.33   关键数据加密与校验 

##### 2.2.33.1 问题描述 

测试客户端程序提交数据给服务端时，密码.收款人信息等关键字段是否进行了加密， 防止恶意用户嗅探到用户数据包中的密码等敏感信息。客户端程序提交数据给服务端时，是否对提交数据进行签名，防止提交的数据被木 马恶意篡改 

##### 2.2.33.2 危害级别 

当账号，密码，卡号等数据明文传输，未进行二次加密时为高风险；

当密码只进行了单 项散列而未经过加密时为高风险；

当返回数据中包含更新的 URL 且数据不加密时为高风险； 

当校验字段删除后服务器仍会处理所发送的数据包时为高风险；

当校验字段的散列中不包含 随机因子时为高风险。以上问题均不存在时无风险。 

##### 2.2.33.3 测试方法 

将 iOS 设置好代理，使用 burpsuite 观察客户端和服务端的交互数据。

检查关键字段是否加密。 

### 2.3 APP 业务应用安全 

#### 2.3.1 SQL 注入漏洞 

##### 2.3.1.1  问题描述 

开发过程中未对特殊字符进行过滤，攻击者可以通过把SQL 命令插入到   Web 表单提交或者输入域名或者页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL 命令的目的，这样攻击者就能够对内部数据库进行增删改操作。 

##### 2.3.1.2  危害级别 

Sqlmap 检查出注入则为高危漏洞 

##### 2.3.1.3  测试方法 

1.   利用   BurpSuite 中的  Intruder 功能对被测应用进行暴力破解。

     首先确保Burp Suite 上的“intercept is on(监听是打开的)”。然后点击登陆。提交表单的请求将被    Burp  Suite 监听拦截到，然后将请求保存为txt 格式。 

2. 使用  sqlmap 对保存的请求进行自动化    sql 注入检测，检测完毕后将会列出存在注入漏洞的点。

#### 2.3.2 反射型跨站漏洞 

##### 2.3.2.1  问题描述 

开发过程中username 等参数提交时,未对 XSS 漏洞的关键字进行过滤或者拦截，攻击者可以注入恶意代码，窃取户 Cookie 或者劫持客户的浏览器。 

##### 2.3.2.2  危害级别 

浏览器中出现弹窗，则为高危险。 

##### 2.3.2.3  测试方法 

利用   BurpSuite 中的抓取数据包，对其中的参数值改成

```python
<script>alert(111)</script>
<img/src=1  onerror=alert(111)>
```

测试语句，将篡改后的     URL 放到浏览器中访问，观察浏览器页面是否弹出   111 提示框。 

#### 2.3.3 目录浏览—漏洞级别说明 

##### 2.3.3.1  问题描述 

目录浏览漏洞主要是由于配置不当，当访问到某一目录中没有索引文件时（或是手工开启了目录浏览功能）即把当前目录中的所有文件及相关下层目录一一在页面中显示出来，通过该漏洞攻击者可获得服务器上的文件目录结构，从而下载敏感文件（数据文件.数据库文件.源代码文件等）。 

##### 2.3.3.2  危害级别 

符合： 

不存在   Directory Listing 漏洞 

不符合： 

存在  Directory Listing 漏洞，则为高风险。 

##### 2.3.3.3  测试方法 

1）通过    AWVS 扫描，查看扫描结果中，是否存在Directory Listing 漏洞 

2）使用目录扫描工具扫描目标 

3）利用浏览器打开漏洞链接，验证前面两种扫描结果，是否可以成功浏览目录  

#### 2.3.4 文件上传 

##### 2.3.4.1  问题描述 

由于文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过Web访问的目录上传任意文件，并能够将这些文件传递给解释器，就可以在远程服务器上执行任意脚本。 

测试说明： 

是否存在可以上传任意类型的文件，从而获取 webshell 

##### 2.3.4.2  危害级别 

符合： 

无法上传任意类型文件。 

不符合： 

可以上传脚本文件获取    webshell，则为高风险。 

##### 2.3.4.3  测试方法 

1.手工找到上传点，例如图片上传.附件上传 

2.采用直接上传木 马 (webshell 或者脚本文件)，例 如shell.jsp 

3.采用上传后缀为  jpg 的木马文件，使用 burp 抓包，并将后缀改为  jsp 尝试绕过客户端验证 

4.采用   00 截断方法，尝试进行上传； 

5.采用绕过服务端  MIME 类型检测，尝试进行上传。通过  burp修改   content-type,例如将其内容  application/x-httpd-php 或text/plain 改为  image/gif 

6.采用上传一个在真实图片中插入一句话木马的图片，绕过对文件内容检测； 

- 文件名大小写绕过：例如     AsP.pHp.JSp  等； 

- 黑名单绕过：例如  asa.cer 等； 

- FCKEditor 上传  php2.php4.inc.pwml.asa.cer等格式； 

- 截断绕过：1.php[\0].jpg，test.asp%00.jpg 截断绕过 解析漏洞 

- II6:上传  1.asp;1.jpg 格式的文件;test.asp/test 

- Nginx 下的   PHP  CGI 解析漏洞，上传 1.jpg 文件，

  然后访问http://website.com/1.jpg/1.php，1.jpg 文件可能会以php 文件执行；`test.jpg%00.php` 

- Apache 上传绕过：phpshell.php.rar.rar.rar.rar

#### 2.3.5 任意文件下载 

##### 2.3.5.1  问题描述 

攻击者通过在URL 或参数中构造 

```python
../ 
..%2F 
/%c0%ae%c0%ae/ 
%2e%2e%2f 
```

或类似的跨父目录字符串，完成目录跳转，读取操作系统各个目录下的敏感文件。 

##### 2.3.5.2  危害级别 

符合： 

只能下载自己权限内的文件。 

不符合： 

可以任意文件下载，则为高风险。 

##### 2.3.5.3  测试方法 

1.尝试寻找文件下载点 

2. 在不登陆情况下，尝试去下载某些文件（例如  db.doc.txt等格式的文件） 

#### 2.3.6 本地文件包含 

##### 2.3.6.1  问题描述 

服务器通过脚本语言的特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到攻击的目的。其中，能打开并包含本地文件的漏洞，称为本地文件包含漏洞。 

##### 2.3.6.2  危害级别 

符合： 

不存在上述漏洞。 

不符合： 

可以包含任意本地文件，如：/etc/passwd或 boot.ini 等，则为高风险。 

##### 2.3.6.3  测试方法 

1）通过    AWVS 扫描，查看扫描结果中，是否存在    local  file include 漏洞 

2）更改参数的值为其他路径和文件进行验证，在浏览器地址栏中尝试以下URL： 

对于  UNIX/Linux 服务器可以尝试包含/etc/passwd: 

```python
http://www.exmaple.com/viewfile.do?filename=../etc/passwd 
```

对于  Windows 服务器可以尝试包含文件  

```python
http://www.exmaple.com/viewfile.do?filename=c:\boot.ini
```

3)尝试使用截断，来绕过对文件类型的检查，例如： 

```python
http://www.exmaple.com/viewfile.do?filename=../../../../../etc/passwd%00 
```

#### 2.3.7 远程文件包含 

##### 2.3.7.1  问题描述 

服务器通过脚本语言的特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到攻击的目的。其中，能打开并包含远程文件的漏洞，称为远程文件包含漏洞。 

##### 2.3.7.2  危害级别 

符合： 

无上述漏洞则通过。 

不符合： 

可以包含远程文件，如：包含http://www.baidu.com，则为高风险。 

##### 2.3.7.3  测试方法 

1）通过   AWVS 扫描，查看扫描结果中，是否存在   file  include漏洞 

2）更改参数的值为本机的一个 web 服务根目录下的一个文件，

例如  shell.jsp 

    http://www.exmaple.com/viewfile.do?filename=http://192.168.110.160/shell.jsp 

3)尝试使用截断，来绕过对文件类型的检查，例如： 

```python
http://www.exmaple.com/viewfile.do?filename=http://192.168.110.160/etc/passwd%00 
```

#### 2.3.8 短信炸弹 

##### 2.3.8.1  问题描述 

重复发送可触发服务器短信发送的请求，可短时间内对同一手机号码发送大量无意义短信。 

##### 2.3.8.2  危害级别 

符合： 

有次数限制或频率限制等措施。 

不符合： 

无任何限制措施，则为高风险。 

##### 2.3.8.3  测试方法 

使用  BurpSuite 抓包获取发送短信报文并发送到  Repeater 模块进行重放报文，模拟向用户发送多次短信的操作； 

#### 2.3.9 恶意注册 

##### 2.3.9.1  问题描述 

未对注册过程进行有效限制，导致可批量恶意注册账户。 

##### 2.3.9.2  危害级别 

注册有动态短信验证码或图形验证码等机制；验证机制和注册请求同步进行，异步的有控制机制。无防护措施则为高风险，可绕过验证码则为高风险。 

##### 2.3.9.3  测试方法 

1）   注册过程是否有图形验证码.短信验证码防批量注册措施 

2）   再判断图形验证码或动态短信是否存在绕过漏洞 

#### 2.3.10   用户枚举 

##### 2.3.10.1 问题描述 

通过对用户ID 或用户名的枚举，可查询大量用户资料。 

##### 2.3.10.2 危害级别 

符合： 

登录错误返回信息统一。 

不符合： 

登录错误返回信息不统一，则为高风险。 

##### 2.3.10.3 测试方法 

1.输入错误账号时，提示“账号错误”，则可判断为不通过； 

2.输入正确账号时，提示“密码错误”，则可判断为不通过。 

#### 2.3.11   密码暴力破解 

##### 2.3.11.1 问题描述 

暴力破解是一种针对于密码或身份认证的破译方法，即穷举尝试各种可能，找到突破身份认证的一种攻击方法。暴力破解因场景.协议.认证方式的不同，所采用的破解方法也不尽相同。 

##### 2.3.11.2 危害级别 

符合 

对密码暴力破解存在如：账户锁定或   IP 封锁等防护措施。

另外，如果登陆机制中存在图形验证码或动态短信验证码，则相对安全。

图形验证码使用一次后失效，验证码和登陆认证同步进行，或者有异步控制机制。 

不符合： 

不满足以上条件，则为高风险。 

##### 2.3.11.3 测试方法 

1. 1.首先检查登陆机制中，是否存在图形验证码或动态短信，如果没有，则进行一下操作； 
2. 2.采用抓包工具，如：burpsuite    等对登陆过程进行抓包； 
3. 3.对用户密码进行暴力破解攻击； 

4. 4.判断服务器对该攻击过程是否具备防范措施，如，账户 锁 定 .IP 封锁等 
5. 5.采用抓包工具，如   burpsuite 等对登陆过程进行抓包； 
6. 6.多次使用同一验证码访问，验证验证码是否使用一次后失效；  

7. 7.分析验证码验证请求和登陆认证请求是否在同一个请求中，如果不在一个请求中，验证单独发送登陆认证或者一次验证码验证后多次登陆认证是否能登陆成功。 

#### 2.3.12   密码修改验证 

##### 2.3.12.1 问题描述 

密码修改机制不严格，可能导致用户密码被恶意修改 

##### 2.3.12.2 危害级别 

符合： 

重置密码必须有身份验证信息，并且同重置密码请求同步进行；

异步进行则必须控制会话机制。 

不符合： 

无旧口令或者短信验证码二次验证，则为中风险 

##### 2.3.12.3 测试方法 

1.进行密码修改时，查看是否有旧口令验证或者短信验证码校验； 

2.采用抓包工具，如如：burpsuite     等抓取密码重置过程包 

3.检查重置密码的请求是否包括验证信息，如果不包括验证信息，修改重置账号为其他用户的账号，重放重置密码请求，验证是否重置成功；如果包括验证信息，验证是否有失效或者防伪造机制。 

#### 2.3.13   短信验证码及图形验证码 

##### 2.3.13.1 问题描述 

此漏洞可导致短信验证码.图形验证码验证机制被绕过。 

##### 2.3.13.2 危害级别 

符合： 

响应中不携带验证码。 

不符合： 

响应中携带短信验证码.图形验证码，则为高风险 

##### 2.3.13.3 测试方法 

1.采用抓包工具，如   BurpSuite 等抓包； 

2.查看短信验证码.图形验证码请求的响应内容，是否包含短信验证码.图形验证码 


#### 2.3.14   业务逻辑绕过 

##### 2.3.14.1 问题描述 

攻击者可通过篡改提交数据进行越权操作。 

对于可以通过代理的方式对交互数据进行分析的客户端，可以对涉及到敏感信息操作的具体业务功能进行测试 

##### 2.3.14.2 危害级别 

符合： 

不能够通过篡改提交数据来达到业务逻辑意外的功能。 

不符合： 

能够通过篡改提交数据来达到业务逻辑意外的功能，则为高风险。 

##### 2.3.14.3 测试方法 

1.根据客户端的业务流程，使用代理截获客户端每个功能的通信数据，测试对交互数据的篡改或重放所导致的问题。 

2.具体测试内容包括但不限于：篡改造成的越权操作，交易篡改，特殊数据提交（如各种注入问题），重放导致的多次交易等等。 

#### 2.3.15   未授权访问 

##### 2.3.15.1 问题描述 

用户通过绕过权限认证可执行超出自身账号权限的操作（例如普通用户对其他人的信息进行增/删/改/查）。 

##### 2.3.15.2 危害级别 

能访问则为高风险。 

##### 2.3.15.3 测试方法 

1.使用低权限账号访问高权限账号   url 

#### 2.3.16   动态短信本地生成 

##### 2.3.16.1 问题描述 

攻击者可利用漏洞对短信内容进行恶意篡改，从而对用户或管理员进行欺骗或恐吓。 

##### 2.3.16.2 危害级别 

符合： 

动态短信服务端进行，而不是客户端发送到服务端。 

不符合： 

动态短信可在客户端进行编辑，则为高风险。 

##### 2.3.16.3 测试方法 

1）采 用抓包工具，如：burpsuite 等对获取动态短信过程进行抓包； 

2）查 看  payload 中，是否包含动态短信相关字段，如：code  等。 

#### 2.3.17   越权访问 

##### 2.3.17.1 问题描述 

系统权限验证机制不完善，导致低权限账号可访问高权限账号相关资源。 

##### 2.3.17.2 危害级别 

符合： 

不存在越权访问则通过。 

不符合： 

低权限账号能访问高权限才能访问的    URL 则为高风险； 

同级权限时，可访问其他账号特定数据，则为高风险。 

##### 2.3.17.3 测试方法 

1.低权限账号可以访问高权限账号 

1）使用高权限账号登陆，抓取一些只有高权限账号才能登陆的URL 

2）退出高权限账号，使用低权限账号登陆后，尝试访问这些高权限账号才能访问的   URL 

2.同级别越权 使用  A 账号能否访问B 账号的特定数据，实现越权访问 

#### 2.3.18   短信接口恶意调用 

##### 2.3.18.1 问题描述 

系统发送的短信内容可以被客户端修改 

##### 2.3.18.2 危害级别 

符合： 

发送短信内容无法编辑则通过。 

不符合： 

能给指定用户发送短息，（短信内容可编辑），则为高风险。 

##### 2.3.18.3 测试方法 

1）在调用短信接口过程中，使用 burp 进行抓包，修改发送目标与内容 

2)查看是否能按照预定发送短信 

#### 2.3.19   短信验证码伪随机 

##### 2.3.19.1 问题描述 

通过对验证码进行统计分析,发现验证码是逐步递增,是有规律的,不是随机的，攻击者可以事先自己收一个短信验证码，然后在这个验证码数值附近进行枚举，可预测出受害者的验证码。 

##### 2.3.19.2 危害级别 

验证码呈现规律性，则为高风险 

##### 2.3.19.3 测试方法 

对 APK 客户端所有的短信功能进行收集，手动触发每一个验证码发送功能，促使其发送几十个验证码，然后观察其是否存在递增或递减规律。 

#### 2.3.20   泄漏后台服务器地址 

##### 2.3.20.1 问题描述 

在使用   BurpSuite 等工具对应用进行监听的过程中，发现后台服务器地址。对后台服务器进行测试，若后台服务器存在漏洞，则可控制后台服务器。 

##### 2.3.20.2 危害级别 

在监听过程中，发现存在后台地址，则为高危险。 

##### 2.3.20.3 测试方法 

1.利用  BurpSuite 对被测应用进行监听。确保     Burp Suite 上的“intercept is on(监听是打开的)”。对监听到的数据包进行查看，是否有后台服务器地址。 

2.如果发现后台服务器地址，则对其进行安全测试，检查其是否存在  SQL 注入.struts2   等后台服务器漏洞。 

#### 2.3.21   利用业务逻辑缺陷制作短信炸弹 

##### 2.3.21.1 问题描述 

如果在用户注册过程中存在逻辑设计缺陷，可对指定手机号码随意发送短信，造成短信炸弹攻击，可能造成用户投诉或恶意软件传播等。 

##### 2.3.21.2 危害级别 

短时间内接收到多条短信，则为高危险 

##### 2.3.21.3 测试方法 

1. 利用 BurpSuite 对被测应用进行监听。确保     Burp  Suite 上的“intercept is on(监听是打开的)”。然后点击登 陆.。登陆请求将被  Burp Suite 监听拦截到。 

2. 对明文传输的手机号和验证码进行修改，可以向任意注册用户无限次发送任意内容短信。 

#### 2.3.22   session 

##### 2.3.22.1 问题描述 

服务端没有对sessionid 进行有效验证，导致服务可被未授权访问。 

##### 2.3.22.2 危害级别 

能访问则为高风险 

##### 2.3.22.3 测试方法 

1）   使用  burp 截取一个正常业务操作的包，并删除  session id后提交请求，查看是否可以成功访问 

2）   首先抓取正常登录后的    sessionid，注 销会话后，使用抓取的  sessionid 访问需要登录后的界面 

#### 2.3.23   struts 任意命令执行漏洞 

##### 2.3.23.1 问题描述 

系统使用的Struts2 版本存在远程代码执行漏洞 

##### 2.3.23.2 危害级别 

符合： 

无漏洞则通过。 

不符合： 

提示有漏洞则为高风险。 

##### 2.3.23.3 测试方法 

1）验证工具：http://218.207.242.28/list.php（中国移动研究院提供） 

2）选择   struts2 S2-020 0day 漏洞检测工具，填入  IP 测试      

#### 2.3.24   open ssl 心脏出血漏洞 

##### 2.3.24.1 问题描述 

OpenSSL 引入了心跳(heartbeat)机制来维持   TLS 链接的长期存在，心跳机制是作为   TLS 的扩展实现，但在代码中包括 TLS(TCP)和DTLS(UDP)都没有做边界的检测，所以导致攻击者可以利用这个漏洞来获得   TLS 链接对端（可以是服务器，也可以是客户端）内存中的一些数据 

##### 2.3.24.2 危害级别 

符合： 

无漏洞则通过。 

不符合： 

读出内存数据，则为高风险。 

#### 2.3.24.3 测试方法 

1）验证工具：http://218.207.242.28/list.php（中国移动研究院提供） 

2）选择   openssl Heartbleed 漏洞检测工具，填入   IP 测试 

#### 2.3.25   错误处理测试 

##### 2.3.25.1 问题描述 

应用系统对用户输入的特殊字符.不存在路径等没有进行正确处理，导致与系统组件相关的敏感信息泄露。 

##### 2.3.25.2 危害级别 

符合：

页面中不存在敏感信息.错误代码或版本号 

不符合： 

中风险：页面中存在敏感信息.错误代码或版本号 

##### 2.3.25.3 测试方法 

检查报错是否含有系统信息.错误代码.版本号等信息 

#### 2.3.26   客户端校验 

##### 2.3.26.1 问题描述 

服务端未校验客户端版本。 

##### 2.3.26.2 危害级别 

可通过   pc 端直接访问则为低风险 

##### 2.3.26.3 测试方法 

1)   通过  burpsuit 抓包获取    APP 请求的链接； 

2)   通过  PC 端的浏览器访问获取的链接，查看响应是否校验客户端类型； 

#### 2.3.27   SSL 协议安全性 

##### 2.3.27.1 问题描述 

服务协议版本过低或存在已知漏洞。 

##### 2.3.27.2 危害级别 

存在漏洞或版本不符合要求则为中风险 

##### 2.3.27.3 测试方法 

1)   使用  nessus 检测  Https 的 SSL 版本号是否不小于 3.0（或TLS1.1)，加密算法是否安全。      

#### 2.3.28   服务端证书有效性 

##### 2.3.28.1 问题描述 

服务端没有对证书进行有效验证。 

检查服务端证书是否是    CA 签发，客户端程序和服务器端的  SSL通信是否严格检查服务器端证书的有效性 

##### 2.3.28.2 危害级别 

能访问则为中风险 

##### 2.3.28.3 测试方法 

1.   通过  wifi 将手机和测试PC 连接到同一子网。

     然后在手机中设置代理，Host中填入测试PC  IP 地址，将客户端流量转发给测试  PC 上的代理工具（如 fiddler）。

     然后使用客户端访问服务端，查看客户端是否会提示证书无效。 

#### 2.3.29   Cookie 重放 

##### 2.3.29.1 问题描述 

服务端没有对cookie 进行有效验证，导致服务可被未授权访问。 

##### 2.3.29.2 危害级别 

能访问则为高风险 

##### 2.3.29.3 测试方法 

1）   使用  burp 截取一个正常业务操作的包，抓取正常的    cookie，使用另一台电脑使用不同网络重放数据包，查看是否可以成功访问。 
